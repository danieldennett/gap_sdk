<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GAP8 SDK Manual</title>
<title>Runtime: GAP8 SDK Manual</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="pulp.css" rel="stylesheet" type="text/css" />
<link href="gap.css" rel="stylesheet" type="text/css" />
<link href="images.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="printComponentTabs.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="titlerow">
  <td id="projectlogo"><img alt="Logo" src="gap-logo-55.png" /></td>
  <td id="projectbox">
   <div id="projectname">Runtime
   &#160;<span id="projectnumber">Version 1.0</span>
   </div>
   <div id="projectbrief">PULP Kernel Library</div>
  </td>
  <td id="extralogo"><img alt="GreenWaves" src="greenwaves-logo-55.png" /></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="CMSISnav" class="tabs1">
    <ul class="tablist">
      <script type="text/javascript">
		<!--
		writeComponentTabs.call(this);
		//-->
      </script>
	  </ul>
</div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">GAP8 SDK Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="section0"></a>
Introduction to the PULP OS</h1>
<h1><a class="anchor" id="section1"></a>
How to start compiling and running applications</h1>
<h2><a class="anchor" id="section2"></a>
Configure the GAP8 Development Environment</h2>
<p>The following command configures the shell environment correctly for the GAP8 SDK. It must be done for each terminal session:</p>
<div class="fragment"><div class="line">source ~/gap_sdk/sourceme.sh</div></div><!-- fragment --><p>Tip: You can add an "alias" command as following in your .bashrc file:</p>
<div class="fragment"><div class="line">alias GAP_SDK=&#39;cd ~/gap_sdk &amp;&amp; source sourceme.sh&#39;</div></div><!-- fragment --><p>Typing GAP_SDK will now change to the gap_sdk directory and execute the source command.</p>
<h2><a class="anchor" id="section3"></a>
What is in the gap8_sdk folder?</h2>
<p>This folder contains all the files of the GAP8 SDK, the following table illustrate all the key files and folders:</p>
<table class="doxtable">
<tr>
<th>Name </th><th>Descriptions  </th></tr>
<tr>
<td>docs </td><td>Runtime API, auto-tiler and example application documentation </td></tr>
<tr>
<td>pulp-os </td><td>a simple, PULP Runtime based, open source operating system for GAP8. </td></tr>
<tr>
<td>mbed-os </td><td>ARM Mbed OS based operating system </td></tr>
<tr>
<td>sourceme.sh </td><td>A script for configuring the GAP SDK environment </td></tr>
<tr>
<td>examples </td><td>Examples of runtime API usage </td></tr>
<tr>
<td>tools </td><td>All the tools necessary for supporting the GAP8 usage </td></tr>
</table>
<h2><a class="anchor" id="section4"></a>
How to compile and run the “Hello World” example on GAPUINO Devlopment Board</h2>
<p>The hello world example gets each core to print out a hello message. We will go through this example in detail so that you can learn how to schedule tasks on the cluster.</p>
<p>Like other examples and applications, this example is located in the "examples" folder:</p>
<div class="fragment"><div class="line">cd examples/pulp-examples/hello_world</div></div><!-- fragment --><p>Then execute this command for compiling and running the example on GAPUINO:</p>
<div class="fragment"><div class="line">make clean all run</div></div><!-- fragment --><p>You can also compile and execute the example separately.</p>
<div class="fragment"><div class="line">make clean all</div><div class="line">make run</div></div><!-- fragment --><p>In the result, you will see the Hello from all the cores in FC and in Cluster, with their Cluster IDs and Core IDs.</p>
<p>All the examples can be built and run with the same procedure.</p>
<h3><a class="anchor" id="section5"></a>
Explanation of hello world example</h3>
<p>While reviewing this please refer to the runtime API reference.</p>
<p>The hello world <code>main()</code> function is executed on the FC. The runtime uses a simple yet powerful asynchronous event system to synchronize activity between tasks on the FC and the cluster. The first thing the example does is to get a pointer to the default scheduler created when the runtime starts.</p>
<div class="fragment"><div class="line">rt_event_sched_t * p_sched = <a class="code" href="group__Event.html#ga8c7808c990317ef246848e486f2a79bd">rt_event_internal_sched</a>();</div></div><!-- fragment --><p>You can create more schedulers if your application requires more complex hierarchical scheduling structures.</p>
<p>Each scheduler can queue a certain amount of events. To save memory a fixed amount of space is reserved for queued events. To make sure that we have an adequate amount of queued event space we next add room for 4 queued events.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__Event.html#ga5e355251700ab096c5eed1caeba817f3">rt_event_alloc</a>(p_sched, 4)) <span class="keywordflow">return</span> -1;</div></div><!-- fragment --><p>Now we allocate an event and bind it to a function that will be called when it completes, <code>end_of_call()</code>. We will use this event a little bit later. Note that we bind the CID constant as an argument for the end_of_call function.</p>
<div class="fragment"><div class="line">rt_event_t *p_event = <a class="code" href="group__Event.html#ga56e7263ee9e0721e86cb52fefd3dbbde">rt_event_get</a>(p_sched, end_of_call, (<span class="keywordtype">void</span> *) CID)</div></div><!-- fragment --><p>Since our hello world example is going to dispatch a task onto the cluster we first need to switch it on. The <code><a class="el" href="group__Cluster.html#ga72e90031646f7db4cf031fd4c6d17ab7" title="Cluster power-up and power-down. ">rt_cluster_mount()</a></code> call will block until the cluster is switched on when used with a NULL 4th parameter. Many of the asynchronous event based APIs can take NULL as the event argument which transforms them into blocking calls. Whenever blocked the core is clock gated so it consumes minimal power.</p>
<div class="fragment"><div class="line"><a class="code" href="group__Cluster.html#ga72e90031646f7db4cf031fd4c6d17ab7">rt_cluster_mount</a>(MOUNT, CID, 0, NULL);</div></div><!-- fragment --><p>Each cluster task is a function called on one of the cluster cores. A cluster function first executes on cluster core 0 which acts as a dispatcher to the other cores. Each cluster core function requires an allocated portion of memory to use as a call stack. We may want to allocate slightly more stack to core 0 to cover the extra tasks associated with dispatching to and collecting results from the other cores. In the case of the hello world example there is not much to do so we allocate the same amount of stack for all the cores.</p>
<p>We allocate the stacks in the cluster level 1 shared memory (<code>RT_ALLOC_CL_DATA</code>) and we get the number of cores in the cluster using <code><a class="el" href="group__UtilsArchi.html#gac76b042c3e7173a9aad84c8c283536ea" title="Returns the number of cores on the first cluster. ">rt_nb_pe()</a></code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> *stacks = <a class="code" href="group__PortableMemAlloc.html#ga35fd6e9987550bff6fcfaa7b68efdf29">rt_alloc</a>(<a class="code" href="group__PortableMemAlloc.html#gga03674713491d0f42a17e1e18d26f91ada94e15b6effca1268d4ad014c5355ffc2">RT_ALLOC_CL_DATA</a>, STACK_SIZE*<a class="code" href="group__UtilsArchi.html#gac76b042c3e7173a9aad84c8c283536ea">rt_nb_pe</a>());</div><div class="line"><span class="keywordflow">if</span> (stacks == NULL) <span class="keywordflow">return</span> -1;</div></div><!-- fragment --><p>Now we can actually call the function that we want to execute on the cluster using the <code><a class="el" href="group__Cluster.html#gaeae91318a400749948e377d97872a8ec" title="Call a function that will execute on the cluster. ">rt_cluster_call()</a></code> function. This call will start the function <code>cluster_entry()</code> on core 0 of the cluster and will trigger the event allocated in <code>p_event</code> when the function <code>cluster_entry()</code> exits on core 0. Most APIs that use events can take a NULL pointer for the event parameter. In this case the function will block until completed.</p>
<p>We pass the pointer to the stack area that we have allocated and indicate the size of the stack for core 0 and the size for the other cores and the number of cores that we want to use for this function (all of them).</p>
<p>Just after calling the cluster we trigger events on our scheduler using <code><a class="el" href="group__Event.html#ga4b2d85a086a5d7b7a1b6a5226d965994" title="Execute all pending events. ">rt_event_execute()</a></code>. If no events are ready then this call will block and the core will sleep until one is.</p>
<div class="fragment"><div class="line"><a class="code" href="group__Cluster.html#gaeae91318a400749948e377d97872a8ec">rt_cluster_call</a>(NULL, CID, cluster_entry, NULL, stacks,</div><div class="line">      STACK_SIZE, STACK_SIZE, <a class="code" href="group__UtilsArchi.html#gac76b042c3e7173a9aad84c8c283536ea">rt_nb_pe</a>(),</div><div class="line">  p_event);</div><div class="line"><a class="code" href="group__Event.html#ga4b2d85a086a5d7b7a1b6a5226d965994">rt_event_execute</a>(p_sched, 1);</div></div><!-- fragment --><p>The function <code>cluster_entry()</code> now executes on core 0. We print a message so that you can see the order of execution and start the <code>hello()</code> function on all the cores.</p>
<div class="fragment"><div class="line"><a class="code" href="group__Team.html#ga36da80851c8684584ab6681a4fe43d1e">rt_team_fork</a>(8, hello, (<span class="keywordtype">void</span> *)0x0);</div></div><!-- fragment --><p>The <code><a class="el" href="group__Team.html#ga36da80851c8684584ab6681a4fe43d1e" title="Fork the execution of the calling core. ">rt_team_fork()</a></code> function will block on core 0 until all the cores have exited the <code>hello()</code> function. The <code>hello()</code> function is now executed on all cores <b>including core 0</b>.</p>
<p>Each core in the cluster prints our its core and cluster IDs.</p>
<p>Control now returns to after the <code><a class="el" href="group__Team.html#ga36da80851c8684584ab6681a4fe43d1e" title="Fork the execution of the calling core. ">rt_team_fork()</a></code> call which then exits triggering the <code>p_event</code> event on the FC which calls the function <code>end_of_call()</code>. This function executes on the FC and prints out the FC cluster and core IDs. The <code><a class="el" href="group__Event.html#ga4b2d85a086a5d7b7a1b6a5226d965994" title="Execute all pending events. ">rt_event_execute()</a></code> then returns since an event has been serviced. Often we would enclose the call to this function in a loop since we would want to continue waiting for and consuming events but in this simple case we then just turn the cluster off and return terminating the program.</p>
<p>Here is an example of the output:</p>
<div class="fragment"><div class="line">Entering main controller</div><div class="line">Entering cluster on core 0</div><div class="line">[clusterID: 0x 0] Hello from core 1</div><div class="line">[clusterID: 0x 0] Hello from core 0</div><div class="line">[clusterID: 0x 0] Hello from core 2</div><div class="line">[clusterID: 0x 0] Hello from core 3</div><div class="line">[clusterID: 0x 0] Hello from core 4</div><div class="line">[clusterID: 0x 0] Hello from core 5</div><div class="line">[clusterID: 0x 0] Hello from core 6</div><div class="line">[clusterID: 0x 0] Hello from core 7</div><div class="line">Leaving cluster on core 0</div><div class="line">[clusterID: 0x20] Hello from core 0</div><div class="line">Leaving main controller</div></div><!-- fragment --><p>Notice the control flow, main on FC, then cluster_entry, then hello on all the cores, then return to cluster_entry, then end_of_call and then back to main.</p>
<h2><a class="anchor" id="section6"></a>
How to console through uart</h2>
<p>In pulp os, the printf will go through JTAG by default. If you want to console via uart, please define parameter "__rt_iodev" in your program as below:</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> __rt_iodev=RT_IODEV_UART;</div></div><!-- fragment --><p>This global variable will trigger the console on serial port.</p>
<h2><a class="anchor" id="section7"></a>
How to allocate memory</h2>
<p>As mentioned before, there are three areas of memory in GAP8, the FC L1 memory, the shared L1 cluster memory and the L2 memory. The L2 memory is the home for all code and data. The L1 areas are the location for temporary blocks of data that requires very fast access from the associated core. The shared L1 cluster memory is only accessible when the cluster has been mounted.</p>
<p>All memory allocations are executed by the FC. As opposed to a classic malloc function the amount of memory allocated must be supplied both when allocated and when freed. This reduces the meta data overhead associated with the normal malloc/free logic.</p>
<p>The most portable memory allocator is the one provided by rt_alloc and rt_free.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span>* <a class="code" href="group__PortableMemAlloc.html#ga35fd6e9987550bff6fcfaa7b68efdf29">rt_alloc</a>(<a class="code" href="group__PortableMemAlloc.html#ga03674713491d0f42a17e1e18d26f91ad">rt_alloc_e</a> flags, <span class="keywordtype">int</span> size)</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__PortableMemAlloc.html#gafd71158e128a08278054f4564018aa59">rt_free</a>(<a class="code" href="group__PortableMemAlloc.html#ga03674713491d0f42a17e1e18d26f91ad">rt_alloc_e</a> flags, <span class="keywordtype">void</span> * chunk, <span class="keywordtype">int</span> size)</div></div><!-- fragment --><p>This takes a first parameter that indicates what the memory is intended to contain. In GAP8 the following areas are used:</p>
<table class="doxtable">
<tr>
<th align="center">L2 </th><th align="center">FC L1 </th><th align="center">Cluster L1  </th></tr>
<tr>
<td align="center">RT_ALLOC_FC_CODE </td><td align="center">RT_ALLOC_FC_DATA </td><td align="center">RT_ALLOC_CL_DATA </td></tr>
<tr>
<td align="center">RT_ALLOC_FC_RET_DATA </td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="center">RT_ALLOC_CL_CODE </td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="center">RT_ALLOC_L2_CL_DATA </td><td align="center"></td><td align="center"></td></tr>
<tr>
<td align="center">RT_ALLOC_PERIPH </td><td align="center"></td><td align="center"></td></tr>
</table>
<h2><a class="anchor" id="section8"></a>
How to use the event and thread scheduler APIs</h2>
<p>The asynchronous interactions between the fabric controller, the cluster and the peripherals are managed with events on the fabric controller side.</p>
<p>An event is a function callback which can be pushed to an event scheduler, for a deferred execution. All events in the same scheduler are executed in-order, in a FIFO manner.</p>
<p>In order to manage several levels of event priorities, there may be several event schedulers at the same time. The application is entered with one event scheduler already created in the runtime, which is the one which can be used as the default scheduler. However the application can then create multiple event schedulers in order to build a more complex multi-priority scenario.</p>
<p>Event schedulers are only executed when specific actions are executed by the application. They can be either invoked explicitly by calling rt_event_execute or implicitly when for example no thread is active and the application is blocked waiting for something.</p>
<p>The pool of events which can be pushed to schedulers must be explicitly managed by the application. There is by default no event allocated. They must be first allocated before they can be pushed to schedulers. This allows the application to decide the optimal number of events that it needs depending on the various actions which can occur.</p>
<p>When a scheduler is invoked, it executes all its pending events, unless the current thread is preempted to schedule another thread. To execute an event, it removes it from the queue and executes the associated callback with its argument, until the callback returns. This scheduler can not execute any other event until the callback has returned.</p>
<p>Each thread is assigned an event scheduler. By default, when a thread is created, it is assigned the internal event scheduler. Another scheduler can then be assigned by the application. This scheduler is the one implicitly invoked when the thread is calling a blocking operation such as waiting for an event.</p>
<p>The runtime on the fabric controller is always running a thread scheduler. This scheduler is priority-based and preemptive. Only the ready threads of the highest priority are scheduled following a round-robin policy. It is intended that threads be preempted at a fixed frequency in order to let other threads of the same priority run however this feature is not present in the runtime in the first release of the SDK.</p>
<p>If the application only uses one thread and uses events to schedule tasks (cooperative multi-tasking) it will always run in the main thread. If the application needs to use preemptive threading then it can use the thread API to create new threads. You can find an example of threads and events in the <code>examples/threads_events</code> directory.</p>
<h2><a class="anchor" id="section9"></a>
How to use the DMA</h2>
<p>The DMA unit that is directly used by the programmer is the cluster-DMA. The micro-DMA is used by peripheral drivers.</p>
<p>The cluster-DMA is used to move data between its 'home location' in L2 memory and the shared L1 cluster memory.</p>
<p>DMA transactions are executed in parallel with code executing on any of the cores. Cluster DMA unit transactions can only be carried out on the cluster. The API should not be used on the FC.</p>
<h3><a class="anchor" id="section10"></a>
Transfer identifier synchronization</h3>
<p>Generally core 0 will be used to set up DMA transfers and then dispatch tasks to the other cores on completion. Each transfer is assigned a transaction identifier. Optionally a new transfer can be merged with a previous one i.e. they shared the same transaction identifier. The <code><a class="el" href="group__DMA.html#gaf35378a83fc331ddd7d1ab833a0fd4c3" title="Simple DMA transfer completion wait. ">rt_dma_wait()</a></code> function waits until a specific transaction ID has completed.</p>
<h3><a class="anchor" id="section11"></a>
1D/2D copies</h3>
<p>The DMA queuing function has a 1D and 2D variant. A 1D DMA operation is a classic linear copy. The 2D functions allow a 2D tile where lines have spaces between them to be copied in a single DMA transfer to a continuous memory space.</p>
<h3><a class="anchor" id="section12"></a>
Note</h3>
<p>Take care to declare <code>rt_dma_copy_t copy</code> as a variable and use its address in functions requesting <code>rt_dma_copy_t *copy</code>.</p>
<p>By example, you can find in <code>app_release/examples/dma/test.c</code>: </p><div class="fragment"><div class="line"><a class="code" href="group__DMA.html#ga5f80e4995d06e4283e8835ff71577c80">rt_dma_copy_t</a> dmaCp;</div><div class="line"><a class="code" href="group__DMA.html#ga5ebccef75610c348959c3349d8e874bf">rt_dma_memcpy</a>((<span class="keywordtype">int</span>)l2_buff0, (<span class="keywordtype">int</span>)cluster_l1_buff, BUFF_SIZE, <a class="code" href="group__DMA.html#gga301134211274df9a4d867a9956ea8d3da93841f0fc557210d49dbdfd65d67e298">RT_DMA_DIR_EXT2LOC</a>, 0, &amp;dmaCp);</div><div class="line"></div><div class="line"><span class="comment">// Wait for the operation to finish</span></div><div class="line"><a class="code" href="group__DMA.html#gaf35378a83fc331ddd7d1ab833a0fd4c3">rt_dma_wait</a>(&amp;dmaCp);</div></div><!-- fragment --><h2><a class="anchor" id="section13"></a>
How to synchronize the cluster cores</h2>
<p>Since the cluster is viewed as a peripheral to the fabric controller the synchronization model between the two is simple. You start a task on the cluster and it reports a result with an event.</p>
<p>For some algorithms on the cluster you will launch a task on all the cores and each core will carry out the task on its data but may need to synchronize with the other cores at some intermediate step in the operation.</p>
<p>There is a simple scheme to do this using the <code><a class="el" href="group__Team.html#ga3741e3cc5593263ba0262d10eb211be7" title="Execute a barrier between all cores of the team. ">rt_team_barrier()</a></code> function. If a cluster core calls this function it will block (clock gated and therefore in a low power state) until all cluster cores in the team have executed <code><a class="el" href="group__Team.html#ga3741e3cc5593263ba0262d10eb211be7" title="Execute a barrier between all cores of the team. ">rt_team_barrier()</a></code>. The <em>team</em> is composed of all the cores that were involved in the last <code><a class="el" href="group__Team.html#ga36da80851c8684584ab6681a4fe43d1e" title="Fork the execution of the calling core. ">rt_team_fork()</a></code>.</p>
<p>You can see this mechanism in operation in the example <code>examples/cluster_sync</code>.</p>
<h2><a class="anchor" id="section14"></a>
Cluster HW Convolution Engine</h2>
<p>The GAP8 cluster includes a hardware convolution engine which accelerates convolution operations used in CNN. This is not supported in the GVSOC simulator so is not documented in this SDK release.</p>
<h2><a class="anchor" id="section15"></a>
How to measure performance</h2>
<p>You can measure performance in two ways, performance counters for cycle level performance and the 32kHz clock for overall execution time.</p>
<h3><a class="anchor" id="section16"></a>
Performance counters</h3>
<p>The cluster and the FC have a range of performance counters that can be used to measure cycle accurate performance on the GVSOC simulator and on the GAP8 hardware.</p>
<p>The following counters are supported on GAP8:</p>
<div class="fragment"><div class="line"><a class="code" href="group__Perf.html#ggac08707c4e7d4bbab84241487aa11723bae12a8ef21bc002344aef6e7e0b612d7f">RT_PERF_CYCLES</a>        <span class="comment">/* Total number of cycles (also includes the cycles where the core is sleeping). */</span></div><div class="line"><a class="code" href="group__Perf.html#ggac08707c4e7d4bbab84241487aa11723ba8f1b2984ef3d204abb70499b56fe6c8a">RT_PERF_ACTIVE_CYCLES</a> <span class="comment">/* Counts the number of cycles the core was active (not sleeping). */</span></div><div class="line"><a class="code" href="group__Perf.html#ggac08707c4e7d4bbab84241487aa11723ba6a30b83932a11cee4e3d7c46c57cb633">RT_PERF_INSTR</a>         <span class="comment">/* Counts the number of instructions executed. */</span></div><div class="line"><a class="code" href="group__Perf.html#ggac08707c4e7d4bbab84241487aa11723ba7c684cd1d2575416b9c126e341ceae2c">RT_PERF_LD_STALL</a>      <span class="comment">/* Number of load data hazards. */</span></div><div class="line"><a class="code" href="group__Perf.html#ggac08707c4e7d4bbab84241487aa11723ba9cc808514d59b6f736fcc7584f031491">RT_PERF_JR_STALL</a>      <span class="comment">/* Number of jump register data hazards. */</span></div><div class="line"><a class="code" href="group__Perf.html#ggac08707c4e7d4bbab84241487aa11723bacdaecefc7186ec6755a3bd62af28c443">RT_PERF_IMISS</a>         <span class="comment">/* Cycles waiting for instruction fetches, i.e. number of instructions wasted due to non-ideal caching. */</span></div><div class="line"><a class="code" href="group__Perf.html#ggac08707c4e7d4bbab84241487aa11723ba4a9cb4c88848b01870dbe2adfaf30936">RT_PERF_LD</a>            <span class="comment">/* Number of data memory loads executed. Misaligned accesses are counted twice. */</span></div><div class="line"><a class="code" href="group__Perf.html#ggac08707c4e7d4bbab84241487aa11723bafc8d2e26492decfaa3aa78362b930b90">RT_PERF_ST</a>            <span class="comment">/* Number of data memory stores executed. Misaligned accesses are counted twice. */</span></div><div class="line"><a class="code" href="group__Perf.html#ggac08707c4e7d4bbab84241487aa11723ba67b088388a7f51fec97dab0c8f3d37e5">RT_PERF_JUMP</a>          <span class="comment">/* Number of unconditional jumps (j, jal, jr, jalr). */</span></div><div class="line"><a class="code" href="group__Perf.html#ggac08707c4e7d4bbab84241487aa11723ba7784e3343524991c363617f0052258b7">RT_PERF_BRANCH</a>        <span class="comment">/* Number of branches. Counts both taken and not taken branches. */</span></div><div class="line">RT_PERF_BTAKEN        <span class="comment">/* Number of taken branches. */</span></div><div class="line">RT_PERF_RVC           <span class="comment">/* Number of compressed instructions executed. */</span></div><div class="line"><a class="code" href="group__Perf.html#ggac08707c4e7d4bbab84241487aa11723ba78ba7315af37c9bad5a8e1ad3c825dc3">RT_PERF_LD_EXT</a>        <span class="comment">/* Number of memory loads to EXT executed. Misaligned accesses are counted twice. Every non-TCDM access is considered external (cluster only). */</span></div><div class="line"><a class="code" href="group__Perf.html#ggac08707c4e7d4bbab84241487aa11723ba4e4806b88ddd3ca001c0796bd343a2a5">RT_PERF_ST_EXT</a>        <span class="comment">/* Number of memory stores to EXT executed. Misaligned accesses are counted twice. Every non-TCDM access is considered external (cluster only). */</span></div><div class="line"><a class="code" href="group__Perf.html#ggac08707c4e7d4bbab84241487aa11723ba234404fb9630bcf29983df2e81f63032">RT_PERF_LD_EXT_CYC</a>    <span class="comment">/* Cycles used for memory loads to EXT. Every non-TCDM access is considered external (cluster only). */</span></div><div class="line"><a class="code" href="group__Perf.html#ggac08707c4e7d4bbab84241487aa11723ba41ee2b3c0d1c7fd2ea29cc08a8e76bad">RT_PERF_ST_EXT_CYC</a>    <span class="comment">/* Cycles used for memory stores to EXT. Every non-TCDM access is considered external (cluster only). */</span></div><div class="line"><a class="code" href="group__Perf.html#ggac08707c4e7d4bbab84241487aa11723baa988e0e342ee8f128fc3ca09d83bc140">RT_PERF_TCDM_CONT</a>     <span class="comment">/* Cycles wasted due to TCDM/log-interconnect contention (cluster only). */</span></div><div class="line">RT_PERF_CSR_HAZARD    <span class="comment">/* Cycles wasted due to CSR access. */</span></div></div><!-- fragment --><p>On GAP8 you can monitor <code>RT_PERF_CYCLES</code> and one other event simultaneously on FC and cluster. On the GVSOC simulator it is possible to measure all events simultaneously.</p>
<p>To use the performance counters first initialize an rt_perf_t structure:</p>
<div class="fragment"><div class="line">rt_perf_t *perf;</div><div class="line">perf = <a class="code" href="group__PortableMemAlloc.html#ga35fd6e9987550bff6fcfaa7b68efdf29">rt_alloc</a>(<a class="code" href="group__PortableMemAlloc.html#gga03674713491d0f42a17e1e18d26f91ada05debcdaa8e6da2468cb137d5b584183">RT_ALLOC_L2_CL_DATA</a>, <span class="keyword">sizeof</span>(rt_perf_t));</div><div class="line"><a class="code" href="group__Perf.html#gaf013daf2ab420189ad6ab19fa9cd73f0">rt_perf_init</a>(perf);</div></div><!-- fragment --><p>Now set the events that you want to monitor:</p>
<div class="fragment"><div class="line"><a class="code" href="group__Perf.html#gace8fce89c8fd3a8fd96660ad4d7d1853">rt_perf_conf</a>(perf, (1&lt;&lt;<a class="code" href="group__Perf.html#ggac08707c4e7d4bbab84241487aa11723bae12a8ef21bc002344aef6e7e0b612d7f">RT_PERF_CYCLES</a>) | (1&lt;&lt;<a class="code" href="group__Perf.html#ggac08707c4e7d4bbab84241487aa11723ba6a30b83932a11cee4e3d7c46c57cb633">RT_PERF_INSTR</a>));</div></div><!-- fragment --><p>You can now start and stop the counters around any code that you want to measure.</p>
<div class="fragment"><div class="line"><a class="code" href="group__Perf.html#gaa8981c1945067b517a0cac1d4865c9cc">rt_perf_start</a>(perf);</div><div class="line"><span class="comment">/* code to monitor */</span></div><div class="line"><a class="code" href="group__Perf.html#ga5dd4e97b0a1391ad18d0b7735704c4aa">rt_perf_stop</a>(perf);</div></div><!-- fragment --><p>The counters are cumulative so you can do this multiple times. Whenever you want to get a measurement you call <code><a class="el" href="group__Perf.html#ga2d27f54edb7c0493741e075ff3d17fb6" title="Save performance counters values. ">rt_perf_save()</a></code> and then <code><a class="el" href="group__Perf.html#ga23ec016ea3e198bac1084f53bdf0bab4" title="Get performance counters values. ">rt_perf_get()</a></code> to get individual values:</p>
<div class="fragment"><div class="line"><a class="code" href="group__Perf.html#ga2d27f54edb7c0493741e075ff3d17fb6">rt_perf_save</a>(perf);</div><div class="line"><span class="keywordtype">int</span> instr = <a class="code" href="group__Perf.html#ga23ec016ea3e198bac1084f53bdf0bab4">rt_perf_get</a>(perf, <a class="code" href="group__Perf.html#ggac08707c4e7d4bbab84241487aa11723ba6a30b83932a11cee4e3d7c46c57cb633">RT_PERF_INSTR</a>);</div><div class="line"><span class="keywordtype">int</span> cycles = <a class="code" href="group__Perf.html#ga23ec016ea3e198bac1084f53bdf0bab4">rt_perf_get</a>(perf, <a class="code" href="group__Perf.html#ggac08707c4e7d4bbab84241487aa11723bae12a8ef21bc002344aef6e7e0b612d7f">RT_PERF_CYCLES</a>);</div></div><!-- fragment --><p>You can reset the counters at any time with:</p>
<div class="fragment"><div class="line"><a class="code" href="group__Perf.html#gae92c46fde4989dc8b7cd04627e450e58">rt_perf_reset</a>(perf);</div></div><!-- fragment --><p>Remember that you need to call these functions on the core that you want to monitor.</p>
<h3><a class="anchor" id="section17"></a>
32kHz timer</h3>
<p>The 32kHz timer allows you to measure overall execution time. The timer has a resolution of approximately 31us. You can get the value of the 32kHz timer using the function <code><a class="el" href="group__TimeClock.html#ga95e20c7c4f404511e9790565f33a7c04" title="Give the current time in microseconds. ">rt_time_get_us()</a></code>.</p>
<h2><a class="anchor" id="section18"></a>
Using peripherals</h2>
<h3><a class="anchor" id="section19"></a>
HyperBus</h3>
<p>The HyperBus interface allows external flash and RAM to be connected to GAP. It draws upon the legacy features of both parallel and serial interface memories, while enhancing system performance, ease of design, and system cost reduction. For GAP8 HyperBus, the read throughput is up to <code>50 MB/s</code> (Max Frequency = 25 MHz).</p>
<div class="image">
<img src="hyperbus_diagram.png" alt="hyperbus_diagram.png"/>
<div class="caption">
Hyperbus Diagram [http://www.cypress.com/products/hyperbus-memory]</div></div>
<p>{ width=300px }</p>
<h4><a class="anchor" id="section20"></a>
Connection</h4>
<p>For GAP8 HyperBus usage, we recommend implementing HyperFlash and HyperRAM together. For example : GAP8 is connected with S71KS256SC0 [1.8 V, 512 Mbit HyperFlash and 64 Mbit HyperRAM]</p>
<div class="image">
<img src="hyperbus_connection.png" alt="hyperbus_connection.png"/>
<div class="caption">
HyperBus Connection</div></div>
 <h4><a class="anchor" id="section21"></a>
Micro-DMA HyperBus Driver</h4>
<p>In GAP8 all peripheral access, including HyperBus, is controlled by the micro-DMA unit.</p>
<p>The HyperBus micro-DMA implementation has two channels which both support Flash or RAM. It is normal to configure the two channels as one for Flash and the other for RAM. For example, one for S26KS512S [1.8 V, 512 Mbit (64 Mbyte), HyperFlash™] and the other for S27KS0641 [1.8 V, 128 Mbit (16 Mbyte), HyperRAM™ Self-Refresh DRAM].</p>
<p>In the HyperBus driver, the default channel allocation is channel 0 for HyperRAM and channel 1 for HyperFlash however users can adjust the channel allocation to match their requirements. The driver is responsible for configuring the HyperBus and reading and writing in HyperFlash and HyperRAM. It supports 4 or 2 byte aligned and unaligned access in the following way:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (READ) {</div><div class="line">   <span class="keywordflow">if</span> (BYTES_LENGTH % 4 == 0) {</div><div class="line">      <span class="comment">// Read BYTES_LENGTH</span></div><div class="line">   } <span class="keywordflow">else</span> {</div><div class="line">      <span class="comment">// Read the last 4 bytes for remainder</span></div><div class="line">      <span class="comment">// Read the rest (BYTES_LENGTH - BYTES_LENGTH % 4) bytes</span></div><div class="line">   }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (WRITE) {</div><div class="line">   <span class="keywordflow">if</span> (BYTES_LENGTH % 4 == 0) {</div><div class="line">      <span class="comment">// Write BYTES_LENGTH</span></div><div class="line">   } <span class="keywordflow">else</span> {</div><div class="line">      <span class="comment">// Read the last 4 bytes for remainder, and Renew the data</span></div><div class="line">      <span class="comment">// Write back the last 4 bytes</span></div><div class="line">      <span class="comment">// Write the rest (BYTES_LENGTH - BYTES_LENGTH % 4) bytes</span></div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><h4><a class="anchor" id="section22"></a>
Examples</h4>
<p>Here are two HyperBus examples, one for HyperRAM and the other for HyperFlash. You can find the examples in the SDK/examples/peripherals/hyper folder.</p>
<h5>HyperRAM example</h5>
<p>To indicate to GVSOC that it needs to simulate the HyperRAM, the following line has been added to the Makefile:</p>
<div class="fragment"><div class="line">override CONFIG_OPT += hyperram</div></div><!-- fragment --><ul>
<li>The HyperRam example has <code>read</code> and <code>write</code> functions<ul>
<li>Firstly, it opens and configures the HyperRAM device. The function <code>rt_hyperram_open</code> opens the correct RAM according to the given device name.</li>
<li>Then the function <code>rt_hyperram_write</code> writes 1024 bytes from address 0 in HyperRAM. When it finishes, it puts the function <code>end_of_tx</code> in event queue.</li>
<li>Then the function <code>rt_hyperram_write</code> writes 1024 bytes from address 1024 in HyperRAM. When it finishes, it puts the function <code>end_of_tx</code> in event queue.</li>
<li>When the two write requests end and the two <code>end_of_tx</code> functions are executed, two read requests read from address 0 and address 1024 separately and will put two functions <code>end_of_rx</code> in event queue.</li>
<li>When the two read requests end and the two <code>end_of_rx</code> functions are executed then the program exits.</li>
</ul>
</li>
</ul>
<h5>HyperFlash example</h5>
<p>To indicate to GVSOC that it needs to simulate the HyperFlash the following line has been added to the Makefile:</p>
<div class="fragment"><div class="line">override CONFIG_OPT += hyperflash</div></div><!-- fragment --><ul>
<li>The HyperFlash example only has a <code>read</code> function.<ul>
<li>Firstly, it opens and configures the HyperFlash device. The <code>rt_flash_open</code> function opens the correct Flash according to device name.</li>
<li>Then the function <code>rt_flash_read</code> reads 128 bytes from address 0 in HyperFlash, when it finishes, it puts the function <code>end_of_rx</code> in event queue.</li>
<li>Finally the function <code>rt_flash_read</code> reads 128 bytes from address 128 in HyperFlash, when it finishes, it puts the function <code>end_of_rx</code> in event queue.</li>
<li>When the two read requests end and the two <code>end_of_rx</code> functions are executed, then the program exits.</li>
</ul>
</li>
</ul>
<h4><a class="anchor" id="section23"></a>
File system</h4>
<p>You may want to locate some external files in the HyperFlash simulated by GVSOC so you can use them in a test.</p>
<p>Since the HyperFlash is used by the simulator for the boot code we have provided a read only file system that can be initialized by GVSOC to allow the added files to be read.</p>
<p>The example in the SDK/examples/file_system folder shows how to use the mini file system to locate and read two simulated files.</p>
<p>To use the file system with GVSOC, you need to put this in your makefile:</p>
<div class="fragment"><div class="line"><span class="keyword">override</span> CONFIG_OPT += hyperflash hyperflash/fs/files=&lt;path to the file you want to load into the file system&gt;</div></div><!-- fragment --><p>This will tell GVSOC to load this file into the file system, which can then be mounted, opened, seeked and read by using the file system API.</p>
<p>As the example, you need to use these API as below:</p>
<ol type="1">
<li>Define the file system configuration structure and initialize it with default values</li>
</ol>
<div class="fragment"><div class="line"><a class="code" href="structrt__fs__conf__t.html">rt_fs_conf_t</a> conf;</div><div class="line"><a class="code" href="group__FS.html#ga0e81ac64ef81d69ff06ff4eeb53fe752">rt_fs_conf_init</a>(&amp;conf);</div></div><!-- fragment --><ol type="1">
<li>Mount a file-system from hyper_flash.</li>
</ol>
<div class="fragment"><div class="line">rt_fs_t *fs = <a class="code" href="group__FS.html#ga33f57ab1ca7c56fb2f7135d6c75a969f">rt_fs_mount</a>(<span class="stringliteral">&quot;hyperflash&quot;</span>, &amp;conf, event);</div></div><!-- fragment --><ol type="1">
<li>Open one file in this file system</li>
</ol>
<div class="fragment"><div class="line">file = <a class="code" href="group__FS.html#ga1809ef36e97a136b4addcdc0ea79cd2b">rt_fs_open</a>(fs, <span class="stringliteral">&quot;file_name&quot;</span>, flag, event);</div></div><!-- fragment --><ol type="1">
<li>Read data from this file</li>
</ol>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> size = <a class="code" href="group__FS.html#gaad8f93c4960a93120f951526959fce61">rt_fs_read</a>(file, &amp;buff_of_recv, SIZE, event);</div></div><!-- fragment --><ol type="1">
<li>Close the file when it is not needed anymore</li>
</ol>
<div class="fragment"><div class="line"><a class="code" href="group__FS.html#ga227eed5ad1de2c6b7c6ab382b57e16fb">rt_fs_close</a> (file, event);</div></div><!-- fragment --><ol type="1">
<li>Unmount the opened file-system</li>
</ol>
<div class="fragment"><div class="line"><a class="code" href="group__FS.html#ga274ea61e8bfad15c1fbe4fe208d2d343">rt_fs_unmount</a>(fs, event);</div></div><!-- fragment --><h3><a class="anchor" id="section24"></a>
Sound interface (I2S)</h3>
<p>There is an example of using the I2S interface to capture a sound in the directory: SDK/examples/i2s. The example illustrates how to use the I2S driver to connect to digital microphones.</p>
<p>GAP8 embeds 2 I2S modules. Each modules can be connected to 2 microphones so 4 digital microphone can be connected to GAP8. Each modules supports PDM or PCM transfers, sampling frequency initialization, and decimation specification in case of PDM transfer</p>
<h4><a class="anchor" id="section25"></a>
Driver Description</h4>
<p>The following structure is used to configure each I2S module:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>rt_i2s_conf_s {</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> frequency;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>  decimation_log2;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  pdm;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  dual;</div><div class="line">} <a class="code" href="structrt__i2s__conf__t.html">rt_i2s_conf_t</a>;</div></div><!-- fragment --><p>By default, this structure is initialized with :</p>
<div class="fragment"><div class="line">conf-&gt;frequency = 44100;</div><div class="line">conf-&gt;decimation_log2 = 8;</div><div class="line">conf-&gt;pdm = 1;</div><div class="line">conf-&gt;dual = 0;</div></div><!-- fragment --><p>The default settings are:</p>
<ul>
<li>44.1kHz sampling frequency is selected</li>
<li>PDM mode is selected</li>
<li>64 decimation is selected</li>
<li>Single digital microphone is connected</li>
</ul>
<p>Initialize an I2S configuration with default values.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__I2S.html#gadc46fef8b63b094934dc0496279b65e0">rt_i2s_conf_init</a>(<a class="code" href="structrt__i2s__conf__t.html">rt_i2s_conf_t</a> *conf);</div></div><!-- fragment --><p>Open an I2S device.</p>
<div class="fragment"><div class="line">rt_i2s_t *<a class="code" href="group__I2S.html#ga08b4b7c9b9863f99f43982c81258c004">rt_i2s_open</a>(<span class="keywordtype">char</span> *dev_name, <a class="code" href="structrt__i2s__conf__t.html">rt_i2s_conf_t</a> *conf, rt_event_t *event);</div></div><!-- fragment --><p>Capture a sequence of samples.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__I2S.html#gaf630a8e263da0b6c78cc95f34692e145">rt_i2s_capture</a>(rt_i2s_t *handle, <span class="keywordtype">void</span> *buffer, <span class="keywordtype">size_t</span> size, rt_event_t *event);</div></div><!-- fragment --><p>Close an opened I2S device.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__I2S.html#ga85133454c1cacca1cd277e7510a5b809">rt_i2s_close</a>(rt_i2s_t *handle, rt_event_t *event);</div></div><!-- fragment --><h4><a class="anchor" id="section26"></a>
Example description</h4>
<p>The example initializes the configuration structure, opens the microphone, and starts the transfer. The transfer is double buffered, optimizing data transfer.</p>
<h4><a class="anchor" id="section27"></a>
Test description</h4>
<p>In the folder of examples ($SDK/examples/peripherals/I2S), we provides you a test of a pdm microphones. This test shows you how to use the I2S interface to capture sounds. Thanks to the software model on the platform GVSOC, we can run the microphones without HW.</p>
<p>In this example, a 500Hz sin wave is genarated with sox. The sampling frequency is 44.1kHz. The format of this wave is the standard ".wav". The model of gvsoc will read the stim.wav, and send it to GAP8 via I2S interface. After 1024 samples are received the test will apply a check for verifing the reception is correct.</p>
<h4><a class="anchor" id="section28"></a>
Befor starting</h4>
<p>Be sure that sox and libsndfile are installed :</p>
<div class="fragment"><div class="line">sudo apt-<span class="keyword">get</span> install sox libsndfile1-dev</div></div><!-- fragment --><h4><a class="anchor" id="section29"></a>
Test on GVSOC</h4>
<p>For testing this example or your application with one microphone on GVSOC platform, please:</p>
<ol type="1">
<li>Prepare the "stim.wav" file with the wanted sample frequency:</li>
</ol>
<div class="fragment"><div class="line">make gen all SAMPLING_FREQ=44100</div></div><!-- fragment --><ol type="1">
<li>Run the test</li>
</ol>
<div class="fragment"><div class="line">make run SAMPLING_FREQ=44100 FORMAT=wav &gt; samples_wav.txt</div></div><!-- fragment --><p>At the end of the test, a file storing the received samples is created : samples_waves.hex</p>
<ol type="1">
<li>Check that the received samples are OK Use this file to check that the received frequency is correct</li>
</ol>
<div class="fragment"><div class="line">extract_freq.py --samples=samples_waves.txt --frequency=500 --error=0.1 --sample-freq=44100</div></div><!-- fragment --><h4><a class="anchor" id="section30"></a>
Makefile useful tips for I2S</h4>
<p>You can specify the following options in the CONFIG_OPT variable in the Makefile:</p>
<ul>
<li>its frequency (in Hz) : &ndash;freq=</li>
<li>if the transfer is PDM (is PCM if not specifed) : &ndash;pdm</li>
<li>if 2 micro are connected to the I2S interface : &ndash;lr</li>
<li>the stimulus file for the single or the left microphone : stim_left=</li>
<li>the stimulus file for the right microphone in the case that 2 microphones are connected</li>
</ul>
<p>For example :</p>
<div class="fragment"><div class="line"><span class="keyword">override</span> CONFIG_OPT += microphone system/microphone/stim_left=$(CURDIR)/stim.txt</div></div><!-- fragment --><h3><a class="anchor" id="section31"></a>
Camera Interface (CPI)</h3>
<p>GAP8 provides a 8 bits parallel interface to connect with an imager, such as HIMAX HM01B0 and Omnivision OV7670. Drivers for these two image sensors have already been implemented in the runtime. There is a high level API in the runtime which abstracts the interface to these cameras.</p>
<p>To use the camera API, the following sequence should be respected:</p>
<ol type="1">
<li>Initialize the configuration structure</li>
<li>Open the camera</li>
</ol>
<div class="fragment"><div class="line">rt_camera_t *   <a class="code" href="group__Camera.html#gae0fc9461d02c4f610419ff7b0dca7190">rt_camera_open</a> (<span class="keywordtype">char</span> *dev_name, <a class="code" href="structrt__cam__conf__t.html">rt_cam_conf_t</a> *conf, rt_event_t *event)</div></div><!-- fragment --><ol type="1">
<li>Configure the camera by using the control function (optional)</li>
</ol>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span>     <a class="code" href="group__Camera.html#gac913b0aa8afcf3967bf9ad297ff5109b">rt_cam_control</a> (rt_camera_t *handle, <a class="code" href="group__Camera.html#ga77607d9a77656591c964272493fb1305">rt_cam_cmd_e</a> cmd, <span class="keywordtype">void</span> *arg)</div></div><!-- fragment --><ol type="1">
<li>Capture the image</li>
</ol>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span>         <a class="code" href="group__Camera.html#gae6dbba0dea1fa9734544e542f8d8fd4e">rt_camera_capture</a> (rt_camera_t *handle, <span class="keywordtype">void</span> *buffer, <span class="keywordtype">size_t</span> size, rt_event_t *event)</div></div><!-- fragment --><ol type="1">
<li>Start/Stop the camera by using the control function</li>
<li>Close the camera if we don't need it any more.</li>
</ol>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span>     <a class="code" href="group__Camera.html#ga91a62fff2e757a607010624cda4ff2a8">rt_camera_close</a> (rt_camera_t *handle, rt_event_t *event)</div></div><!-- fragment --><h4><a class="anchor" id="section32"></a>
Camera Example</h4>
<p>In the folder of examples (SDK/examples/peripherals/camera_HIMAX), there is an example of using the camera API to capture an image from a Himax imager. Thanks to the emulation in the GVSOC simulator, we can run the camera without hardware.</p>
<p>In this example, the GVSOC reads the file imgTest0.pgm, and sends it to GAP8 via the CPI interface. Once the transfer is finished, the test will apply a check for verifying that the received image is correct. This example takes 2 pictures with different modes:</p>
<ul>
<li>Full image mode: Taking a full picture with size (324 * 244) by default</li>
<li>Sliced image mode: Taking a picture in an interest area only. The interest area is defined by your configuration:</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Activate the slice mode by configuring the camera with CMD_SLICE and the structure slicer:</span></div><div class="line"><span class="comment">// The structure of slicer contains two corner coordinates:</span></div><div class="line"><span class="comment">// ll - lower left corner</span></div><div class="line"><span class="comment">// ur - upper right corner</span></div><div class="line"><a class="code" href="structrt__img__slice__t.html">rt_img_slice_t</a> slicer;</div><div class="line">slicer.slice_ll.x = LL_X;</div><div class="line">slicer.slice_ll.y = LL_Y;</div><div class="line">slicer.slice_ur.x = UR_X;</div><div class="line">slicer.slice_ur.y = UR_Y;</div><div class="line"><a class="code" href="group__Camera.html#gac913b0aa8afcf3967bf9ad297ff5109b">rt_cam_control</a>(camera1, <a class="code" href="group__Camera.html#gga77607d9a77656591c964272493fb1305aa9d40460bdf9b2970dcbf1d28da64203">CMD_SLICE</a>, &amp;slicer);</div></div><!-- fragment --><h4><a class="anchor" id="section33"></a>
Test on GVSOC</h4>
<p>To test this example or your application with camera on GVSOC platform:</p>
<ol type="1">
<li>Prepare one or several pgm images: Please note, the HIMAX model only supports QVGA resolution (324 * 244) as the HIMAX image sensor. This means, the model will always send you 324 * 244 bytes of image whether the pgm image is larger or smaller.<ul>
<li>If the image is larger, the pixels out of the range (W &gt; 324, H &gt; 244) will be dropped</li>
<li><p class="startli">If the image is smaller, the rest of the pixels will be filled by 0xFF. For example, we use an image pgm with size (3 * 3), the image sent by model will be like this: </p><pre class="fragment">                                    W=324
    0x55, 0x55, 0x55, 0xFF, 0xFF, 0xFF, ... 0xFF
    0x55, 0x55, 0x55, 0xFF, 0xFF, 0xFF, ... 0xFF
    0x55, 0x55, 0x55, 0xFF, 0xFF, 0xFF, ... 0xFF   H=244
    0xFF, 0xFF, 0xFF, ....                  0xFF
    ............................................
    0xFF....................................0xFF
</pre><p class="startli">If you want to use more than 1 image in your application, please name all your image like this: imgTest0.pgm, imgTest1.pgm, imgTest2.pgm ... Then the model will start from the imgTest0.pgm until the last image, and restart from imgTest0.img.</p>
</li>
</ul>
</li>
<li>Put this in your Makefile:</li>
</ol>
<div class="fragment"><div class="line">override CONFIG_OPT += camera=himax system/camera/image-stream=$(CURDIR)/imgTest%d.pgm</div></div><!-- fragment --><h2><a class="anchor" id="section34"></a>
How to create your first application</h2>
<h3><a class="anchor" id="section35"></a>
Source of application</h3>
<p>Firstly, please include the runtime header file "rt/rt_api.h", which include sall the libraries in the runtime.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rt__api_8h.html">rt/rt_api.h</a>&quot;</span></div></div><!-- fragment --><p>Secondly, please refer to the reference documentation for the GAP8 runtime API.</p>
<h3><a class="anchor" id="section36"></a>
Makefile</h3>
<p>The Makefile calls the compiler to compile the application with the arguments defined in the Makefile, like how to optimize, which libraries need to be linked, etc.</p>
<p>The name of the final binary can be specified with PULP_APP variable :</p>
<div class="fragment"><div class="line">PULP_APP = test</div></div><!-- fragment --><p>The source files that must be compiled to build the binaries can be specified with the PULP_APP_FC_SRCS variable :</p>
<div class="fragment"><div class="line">PULP_APP_FC_SRCS = test.c</div></div><!-- fragment --><p>The flags (optimize, debug, defines, include paths for examples) that needed to be send to the gcc compiler can be specified with the PULP_CFLAGS variables :</p>
<div class="fragment"><div class="line">PULP_CFLAGS = -O3 -g -DDUMP_LAYER -Iinc_gen</div></div><!-- fragment --><p>The flags (library paths, libraries for example) that needed to be send to the gcc linker can be specified with the PULP_CFLAGS variables :</p>
<div class="fragment"><div class="line">PULP_LDFLAGS += -L$(PULP_SDK_HOME)/install/ws/lib -ldebugbridge-dpi</div></div><!-- fragment --><p>The flabs that need to be passed to the gvsoc simulator can be specified with the CONFIG_OPT variable. Some uses of this variable can be seen in the hyperram, cpi, i2s or file system examples :</p>
<div class="fragment"><div class="line"><span class="keyword">override</span> CONFIG_OPT += hyperram</div><div class="line"><span class="keyword">override</span> CONFIG_OPT += hyperflash</div><div class="line"><span class="keyword">override</span> CONFIG_OPT += hyperflash hyperflash/fs/files=$(CURDIR)/test.c hyperflash/fs/files=$(CURDIR)/hello.txt hyperflash/fs/files$(CURDIR)/hello2.txt</div><div class="line"><span class="keyword">override</span> CONFIG_OPT += camera=himax system/camera/image-stream=$(CURDIR)/imgTest.pgm</div><div class="line"><span class="keyword">override</span> CONFIG_OPT += camera=ov7670 system/camera/image=$(CURDIR)/frame0.img</div></div><!-- fragment --><p>At the end of your Makefile, please don't forget to add the following include:</p>
<div class="fragment"><div class="line">include $(PULP_SDK_HOME)/install/rules/pulp_rt.mk</div></div><!-- fragment --><h1><a class="anchor" id="section37"></a>
Example Applications</h1>
<p>Several larger examples are available in the applications directory. These are compiled and run as the other application.</p>
<p>In the first version of the SDK we provide 4 complete applications that highlight examples of various types of image processing:</p>
<ul>
<li>applications/cannyEdgeDetection : Shows a vectorized and parallelized version of a classic image edge detection algorithm. This example uses the simulation of the Camera Parallel Interface to read in an image and carry out edge detection.</li>
<li>applications/cifar10 : Implements a CNN that can find the class (dog, cats, etc) of an object in an image stream.</li>
<li>applications/mnist : Implements a CNN that can find a digit (0-9) in an image stream.</li>
<li>applications/countingPeople : Implements an algorithm based on HoG and boosting to count the number of people in an image. This is for people standing in front of the camera when the image is taken.</li>
</ul>
<h1><a class="anchor" id="section38"></a>
Advanced topics</h1>
<h2><a class="anchor" id="section39"></a>
Using vectors</h2>
<h3><a class="anchor" id="section40"></a>
Introduction</h3>
<p>This section is derived from the GCC documentation.</p>
<p>The first step in using these extensions is to provide the necessary data types. This should be done using an appropriate typedef:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">short</span> <span class="keywordtype">int</span>           v2s <a class="code" href="group__groupBuiltinsAPI.html#ga3dcd3f21285762bff56ed9452b41a964">__attribute__</a> ((vector_size (4))); <span class="comment">// A vector of 2 shorts</span></div><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">signed</span> <span class="keywordtype">char</span>         v4s <a class="code" href="group__groupBuiltinsAPI.html#ga3dcd3f21285762bff56ed9452b41a964">__attribute__</a> ((vector_size (4))); <span class="comment">// A vector of 4 chars</span></div><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <span class="keywordtype">int</span>  v2u <a class="code" href="group__groupBuiltinsAPI.html#ga3dcd3f21285762bff56ed9452b41a964">__attribute__</a> ((vector_size (4))); <span class="comment">// A vector of 2 unsigned shorts</span></div><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>       v4u <a class="code" href="group__groupBuiltinsAPI.html#ga3dcd3f21285762bff56ed9452b41a964">__attribute__</a> ((vector_size (4))); <span class="comment">// A vector of 4 unsigned chars</span></div></div><!-- fragment --><p>The <code>int</code> type specifies the base type, while the attribute specifies the vector size for the variable, measured in bytes. For example, the declaration above causes the compiler to set the mode for the <code>v4s</code> type to be 4 bytes wide and divided into <code>char</code> sized units. For a 32-bit <code>int</code> this means a vector of 4 units of 1 byte, and the corresponding mode of <code>foo</code> is V4QI in GCC internal parlance.</p>
<p>The <code>vector_size</code> attribute is only applicable to integral and float scalars, although arrays, pointers, and function return values are allowed in conjunction with this construct. Only sizes that are a power of two are currently allowed.</p>
<p>All the basic integer types can be used as base types, both as signed and as unsigned: <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code>. In addition, <code>float</code> and <code>double</code> can be used to build floating-point vector types.</p>
<p>Specifying a combination that is not valid for the current architecture causes GCC to synthesize the instructions using a narrower mode. For example, if you specify a variable of type <code>V4SI</code> and your architecture does not allow for this specific SIMD type, GCC produces code that uses 4 <code>SIs</code>.</p>
<p>The types defined in this manner can be used with a subset of normal C operations. Currently, GCC allows using the following operators on these types: `+, -, *, /, unary minus, ^, |, &amp;, ~, '.</p>
<p>The operations behave like C++ <code>valarrays</code>. Addition is defined as the addition of the corresponding elements of the operands. For example, in the code below, each of the 4 elements in A is added to the corresponding 4 elements in B and the resulting vector is stored in C.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">char</span> v4s <a class="code" href="group__groupBuiltinsAPI.html#ga3dcd3f21285762bff56ed9452b41a964">__attribute__</a> ((vector_size (4)));</div><div class="line"></div><div class="line">v4qi a, b, c;</div><div class="line"></div><div class="line">c = a + b;</div></div><!-- fragment --><p>Subtraction, multiplication, division, and the logical operations operate in a similar manner. Likewise, the result of using the unary minus or complement operators on a vector type is a vector whose elements are the negative or complemented values of the corresponding elements in the operand.</p>
<p>It is possible to use shifting operators <code>&lt;&lt;</code>, <code>&gt;&gt;</code> on integer-type vectors. The operation is defined as following: <code>{a0, a1, ..., an} &gt;&gt; {b0, b1, ..., bn} == {a0 &gt;&gt; b0, a1 &gt;&gt; b1, ..., an &gt;&gt; bn}</code>. Vector operands must have the same number of elements.</p>
<p>For convenience, it is allowed to use a binary vector operation where one operand is a scalar. In that case the compiler transforms the scalar operand into a vector where each element is the scalar from the operation. The transformation happens only if the scalar could be safely converted to the vector-element type. Consider the following code.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">char</span> v4s <a class="code" href="group__groupBuiltinsAPI.html#ga3dcd3f21285762bff56ed9452b41a964">__attribute__</a> ((vector_size (4)));</div><div class="line"></div><div class="line">v4s a, b, c;</div><div class="line"><span class="keywordtype">int</span> I;</div><div class="line"></div><div class="line">a = b + 1;    <span class="comment">/* a = b + {1,1,1,1}; */</span></div><div class="line">a = 2 * b;    <span class="comment">/* a = {2,2,2,2} * b; */</span></div><div class="line"></div><div class="line">a = I + a;    <span class="comment">/* Error, cannot convert int to char. */</span></div></div><!-- fragment --><p>Vectors can be subscripted as if the vector were an array with the same number of elements and base type. Out of bound accesses invoke undefined behavior at run time. Warnings for out of bound accesses for vector subscription can be enabled with <code>-Warray-bounds</code>. For example you could sum up all the elements of a given vector as shown in the following example:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">char</span> v4s <a class="code" href="group__groupBuiltinsAPI.html#ga3dcd3f21285762bff56ed9452b41a964">__attribute__</a> ((vector_size (4)));</div><div class="line"></div><div class="line">v4s A, B[10];</div><div class="line"><span class="keywordtype">int</span> R1, R2;</div><div class="line"><span class="keywordtype">int</span> index;</div><div class="line"></div><div class="line">R1 = A[0] + A[1] + A[2] + A[3];</div><div class="line">R2 = B[index][0] + B[index][1] + B[index][2] + B[index][3];</div></div><!-- fragment --><p>Vector subscripts are endian independent (GCC code generation generates different code for big and little endian). GAP8 is little endian.</p>
<p>Vector comparison is supported with standard comparison operators: <code>==, !=, &lt;, &lt;=, &gt;, &gt;=</code>. Comparison operands can be vector expressions of integer-type or real-type. Comparison between integer-type vectors and real-type vectors are not supported. The result of the comparison is a vector of the same width and number of elements as the comparison operands with a signed integral element type.</p>
<p>Vectors are compared element-wise producing 0 when comparison is false and -1 (constant of the appropriate type where all bits are set) otherwise. Consider the following example.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">char</span> v4s <a class="code" href="group__groupBuiltinsAPI.html#ga3dcd3f21285762bff56ed9452b41a964">__attribute__</a> ((vector_size (4)));</div><div class="line"></div><div class="line">v4s a = {1,2,3,4};</div><div class="line">v4s b = {3,2,1,4};</div><div class="line">v4s c;</div><div class="line"></div><div class="line">c = a &gt;  b;     <span class="comment">/* The result would be {0, 0,-1, 0}  */</span></div><div class="line">c = a == b;     <span class="comment">/* The result would be {0,-1, 0,-1}  */</span></div></div><!-- fragment --><p>The following example illustrates how to properly compare vectors, in particular how to infer a test that need to be satisfied on a all vector elements and a test that need to be satisfy on at least one vector element.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">short</span> v2s <a class="code" href="group__groupBuiltinsAPI.html#ga3dcd3f21285762bff56ed9452b41a964">__attribute__</a> ((vector_size (4)));</div><div class="line"></div><div class="line">v2s R;</div><div class="line"><span class="keywordtype">int</span> a;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> foo(v2s V1, v2s V2)</div><div class="line"></div><div class="line">{</div><div class="line">        R = (V1 &gt; V2);          <span class="comment">/* The result is a vector */</span></div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (V1 &gt; V2)            <span class="comment">/* Error: used vector type where scalar is required */</span></div><div class="line">                a = 1;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>)(V1 &gt; V2))     <span class="comment">/* Correct, equivalent to ((int)(V1&gt;V2) != 0) */</span></div><div class="line">                a = 2;          <span class="comment">/* Test will pass if at least one of the 2 comparisons */</span></div><div class="line">                                <span class="comment">/* is true */</span></div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>)(V1 &gt; V2)==-1) <span class="comment">/* Correct,  Test will pass if the 2 comparisons are true */</span></div><div class="line">                a = 3;          </div><div class="line">}</div></div><!-- fragment --><p>In C++, the ternary operator <code>?:</code> is available. <code>a?b:c</code>, where <code>b</code> and <code>c</code> are vectors of the same type and <code>a</code> is an integer vector with the same number of elements of the same size as <code>b</code> and <code>c</code>, computes all three arguments and creates a vector <code>{a[0]?b[0]:c[0], a[1]?b[1]:c[1], ...}</code>. Note that unlike in OpenCL, <code>a</code> is thus interpreted as <code>a != 0</code> and not <code>a &lt; 0</code>. As in the case of binary operations, this syntax is also accepted when one of <code>b</code> or <code>c</code> is a scalar that is then transformed into a vector. If both <code>b</code> and <code>c</code> are scalars and the type of <code>true?b:c</code> has the same size as the element type of <code>a</code>, then <code>b</code> and <code>c</code> are converted to a vector type whose elements have this type and with the same number of elements as <code>a</code>.</p>
<p>Vector shuffling is available using functions <code>__builtin_shuffle (vec, mask)</code> and <code>__builtin_shuffle (vec0, vec1, mask)</code>. Both functions construct a permutation of elements from one or two vectors and return a vector of the same type as the input vector(s). The MASK is an integral vector with the same width (W) and element count (N) as the output vector.</p>
<p>The elements of the input vectors are numbered in memory ordering of VEC0 beginning at 0 and VEC1 beginning at N. The elements of MASK are considered modulo N in the single-operand case and modulo 2*N in the two-operand case.</p>
<p>Consider the following example,</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">char</span> v4s <a class="code" href="group__groupBuiltinsAPI.html#ga3dcd3f21285762bff56ed9452b41a964">__attribute__</a> ((vector_size (4)));</div><div class="line"></div><div class="line">v4qi a = {1,2,3,4};</div><div class="line">v4qi b = {5,6,7,8};</div><div class="line">v4qi mask1 = {0,1,1,3};</div><div class="line">v4qi mask2 = {0,4,2,5};</div><div class="line">v4qi res;</div><div class="line"></div><div class="line">res = __builtin_shuffle (a, mask1);       <span class="comment">/* res is {1,2,2,4}  */</span></div><div class="line">res = __builtin_shuffle (a, b, mask2);    <span class="comment">/* res is {1,5,3,6}  */</span></div></div><!-- fragment --><p>Note that <code>__builtin_shuffle</code> is intentionally semantically compatible with the OpenCL <code>shuffle</code> and <code>shuffle2</code> functions.</p>
<p>You can declare variables and use them in function calls and returns, as well as in assignments and some casts. You can specify a vector type as a return type for a function. Vector types can also be used as function arguments. It is possible to cast from one vector type to another, provided they are of the same size (in fact, you can also cast vectors to and from other datatypes of the same size).</p>
<p>The previous example is rewritten using a user function to initialize the masks:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">char</span> v4s <a class="code" href="group__groupBuiltinsAPI.html#ga3dcd3f21285762bff56ed9452b41a964">__attribute__</a> ((vector_size (4)));</div><div class="line"></div><div class="line"><span class="keywordtype">void</span>   <a class="code" href="group__groupBuiltinsAPI.html#ga3dcd3f21285762bff56ed9452b41a964">__attribute__</a> ((noinline)) set_mask(v4s *M, v4s val)</div><div class="line"></div><div class="line">{</div><div class="line">        *M = val;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line"></div><div class="line">{</div><div class="line">     v4s a = {1,2,3,4};</div><div class="line">     v4s b = {5,6,7,8};</div><div class="line">     v4s mask1;</div><div class="line">     v4s mask2;</div><div class="line">     v4s res;</div><div class="line"></div><div class="line">     set_mask(&amp;mask1, (v4s) {0,1,1,3});       <span class="comment">/* Note that the immediate aggregate has</span></div><div class="line"><span class="comment">                                                     to be explictly casted to v4s */</span></div><div class="line">     set_mask(&amp;mask2, (v4s) {0,4,2,5});</div><div class="line"></div><div class="line">     res = __builtin_shuffle (a, mask1);       <span class="comment">/* res is {1,2,2,4}  */</span></div><div class="line">     printf(<span class="stringliteral">&quot;Res={%d,%d,%d,%d}\n&quot;</span>, res[0], res[1], res[2], res[3]);</div><div class="line"></div><div class="line">     res = __builtin_shuffle (a, b, mask2);    <span class="comment">/* res is {1,5,3,6}  */</span></div><div class="line">     printf(<span class="stringliteral">&quot;Res={%d,%d,%d,%d}\n&quot;</span>, res[0], res[1], res[2], res[3]);</div><div class="line">}</div></div><!-- fragment --><p>You cannot operate between vectors of different lengths or different signedness without a cast.</p>
<h3><a class="anchor" id="section41"></a>
Handling alignment (auto vectorization)</h3>
<p>Even though GAP8 has full support for unaligned accesses GCC will generate better code if you provide an alignment hint:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<span class="keywordtype">char</span> * __restrict__ a, <span class="keywordtype">char</span> * __restrict__ b)</div><div class="line"></div><div class="line">{</div><div class="line">        <span class="keywordtype">int</span> i;</div><div class="line"></div><div class="line">        <span class="keywordtype">char</span> *x = __builtin_assume_aligned(a, 4);</div><div class="line">        <span class="keywordtype">char</span> *y = __builtin_assume_aligned(b, 4);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (i = 0; i &lt; SIZE; i++) {</div><div class="line">                x[i] = x[i] + y[i + 1];</div><div class="line">        }</div><div class="line">}</div></div><!-- fragment --><p>If you don't, this loop will be vectorized but a complex peeling scheme will be applied ... Performance is reasonable but code size is very bad.</p>
<p>Note also the <code>__restrict__</code> qualifier, it is essential otherwise you have to assume that a and b can point to the same location making the vector transformation illegal.</p>
<h3><a class="anchor" id="section42"></a>
Code example using vector notation</h3>
<p>Searching a given char (Pat) in a string (A):</p>
<p>Here is another example using plain vectors and bit manipulation function. It returns the index of the first matching instance of Pat in A (compared to a sequential search the execution time is divided by 3). This code will also compile as is on any processor supported by GCC.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span>  <a class="code" href="group__groupBuiltinsAPI.html#ga3dcd3f21285762bff56ed9452b41a964">__attribute__</a> ((noinline)) Search_Pattern_Scalar(v4s *A, <span class="keywordtype">int</span> Size, <span class="keywordtype">char</span> Pat)</div><div class="line"></div><div class="line">{</div><div class="line">        v4s R;</div><div class="line">        <span class="keywordtype">int</span> i;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (Size &lt;= 0) <span class="keywordflow">return</span> -1;</div><div class="line">        <span class="keywordflow">for</span> (i=0; i&lt;Size; i++) {</div><div class="line">                <span class="keywordflow">if</span> (((<span class="keywordtype">int</span>) (R=A[i]==(v4qi){Pat,Pat,Pat,Pat})) != 0)</div><div class="line">                        <span class="keywordflow">return</span> (4*i + (__builtin_ffs((<span class="keywordtype">int</span>) (A[i]==Pat))&gt;&gt;3));</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> -1;</div><div class="line">}</div></div><!-- fragment --><p>Salient features are:</p>
<ul>
<li>if (((int) (R=A[i]==(v4s){Pat,Pat,Pat,Pat})) != 0) Test if Pat matches on at least one subscript of A[i] and store comparison result into R (a vector)</li>
<li>return (4*i + (__builtin_ffs((int) (A[i]==Pat))&gt;&gt;3)) Returns the byte position. Since R elements are either 0 or -1 we want to find the first 1 starting from LSB if endian is little</li>
<li>if (Size &lt;= 0) return -1 A trick to let GCC knows that Size in loop is &gt; 0, code is more compact</li>
</ul>
<h3>Auto vectorization code examples</h3>
<p>GCC activates auto vectorization when -O3 is passed. You should be aware that at this level of optimization code-bloat might be an issue since loop unrolling, loop peeling and loop realignment lead to a lot of code replication. As a rule of thumb using vector notation as explained in section 3 combined with -O2 is often a better compromise for an embedded target. Beside full target portability is not impacted since these GCC vector extensions are supported on any existing GCC target.</p>
<p>Performing sum of product:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<span class="keywordtype">char</span> * __restrict__ c1, <span class="keywordtype">char</span> * __restrict__ c2, <span class="keywordtype">char</span> * __restrict__ c3)</div><div class="line"></div><div class="line">{</div><div class="line">        <span class="keywordtype">int</span> i;</div><div class="line"></div><div class="line">        <span class="keywordtype">char</span> * cc1 = __builtin_assume_aligned(c1, 4);</div><div class="line">        <span class="keywordtype">char</span> * cc2 = __builtin_assume_aligned(c2, 4);</div><div class="line">        <span class="keywordtype">char</span> * cc3 = __builtin_assume_aligned(c3, 4);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (i=0; i&lt;SIZE; i++) <span class="comment">// SIZE=128</span></div><div class="line">                cc1[i] = cc1[i] + (cc2[i] + cc3[i]);</div><div class="line">}</div></div><!-- fragment --><p>GCC for Gap8 with -O3 will produce the following fully vectorized loop</p>
<div class="fragment"><div class="line">foo:</div><div class="line">        lp.setupi       x1,32,(.L5)      # loop setup, lc+le set</div><div class="line">.L2:</div><div class="line">        lw      a5,0(a0)</div><div class="line">        p.lw    a4,4(a1!)                   # load post inc</div><div class="line">        p.lw    a6,4(a2!)                   # load post inc</div><div class="line">        pv.add.b        a5,a4,a5         # Vect Op Vect</div><div class="line">        pv.add.b        a5,a5,a6         # Vect Op Vect</div><div class="line">.L5:</div><div class="line">        p.sw    a5,4(a0!)       # store post inc</div><div class="line">        ret</div></div><!-- fragment --><p>Performing min/max:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo1(<span class="keywordtype">char</span> * __restrict__ a, <span class="keywordtype">char</span> * __restrict__ b, <span class="keywordtype">char</span> * __restrict__ c)</div><div class="line">{</div><div class="line">        <span class="keywordtype">int</span> i, j;</div><div class="line"></div><div class="line">        <span class="keywordtype">char</span> *x = __builtin_assume_aligned(a, 4);</div><div class="line">        <span class="keywordtype">char</span> *y = __builtin_assume_aligned(b, 4);</div><div class="line">        <span class="keywordtype">char</span> *z = __builtin_assume_aligned(c, 4);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (i = 0; i &lt; SIZE; i++) { <span class="comment">// SIZE=128</span></div><div class="line">                z[i] = (y[i] &gt; x[i]) ? x[i] : y[i];</div><div class="line">        }</div><div class="line">}</div></div><!-- fragment --><p>GCC for Gap8 with -O3 will produce the following fully vectorized loop</p>
<div class="fragment"><div class="line">foo1:</div><div class="line">        lp.setupi       x1,32,(.L9)      # loop setup, lc+le set</div><div class="line">.L7:</div><div class="line">        p.lw    a3,4(a1!)       # load post inc</div><div class="line">        p.lw    a5,4(a0!)       # load post inc</div><div class="line">        pv.minu.b       a5,a5,a3         # VectU Op Vect</div><div class="line">.L9:</div><div class="line">        p.sw    a5,4(a2!)       # store post inc</div><div class="line">        ret</div></div><!-- fragment --><p>The last example illustrates the limits of auto vectorization. The following code performs a simple 2D matrix to 2D matrix sum. GCC partially manages to auto vectorize it: the inner loop is fully vectorized but the outer loop is a total mess with lot of code to try to realign the data through partial loop peeling. The exec time will be reasonably acceptable but code-bloat is enormous.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo3(<span class="keywordtype">char</span> * __restrict__ a, <span class="keywordtype">char</span> * __restrict__ b)</div><div class="line">{</div><div class="line">        <span class="keywordtype">int</span> i, j;</div><div class="line"></div><div class="line">        <span class="keywordtype">char</span> *x = __builtin_assume_aligned(a, 4);</div><div class="line">        <span class="keywordtype">char</span> *y = __builtin_assume_aligned(b, 4);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (j = 0; j &lt; SIZE; j++) {</div><div class="line">                <span class="keywordflow">for</span> (i = 0; i &lt; SIZE; i++) {</div><div class="line">                        x[i + j * SIZE] += y[i + j * SIZE];</div><div class="line">                }</div><div class="line">        }</div><div class="line">}</div></div><!-- fragment --><p>The following code does the same thing but using direct vector notation. SIZE/4 is to account for the fact that a vector contains 4 elements.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo4(v4qi * __restrict__ a, v4qi * __restrict__ b)</div><div class="line">{</div><div class="line">        <span class="keywordtype">int</span> i, j;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (j = 0; j &lt; SIZE; j++) {</div><div class="line">                <span class="keywordflow">for</span> (i = 0; i &lt; SIZE/4; i++) {</div><div class="line">                        a[i + j * SIZE/4] += b[i + j * SIZE/4];</div><div class="line">                }</div><div class="line">        }</div><div class="line">}</div></div><!-- fragment --><p>Performance is slightly better than auto vectorized version but code size is 10x smaller! Here is code generated for the entire function.</p>
<div class="fragment"><div class="line">foo4:</div><div class="line">        add     a0,a0,128</div><div class="line">        lp.setupi       x0,128,(.L46)    # loop setup, lc+le set</div><div class="line">.L39:</div><div class="line">        add     a3,a0,-128</div><div class="line">        mv      a2,a1</div><div class="line">        lp.setupi       x1,32,(.L45)     # loop setup, lc+le set</div><div class="line">.L40:</div><div class="line">        lw      a5,0(a3)</div><div class="line">        p.lw    a6,4(a2!)               # load post inc</div><div class="line">        pv.add.b        a5,a5,a6     # Vect Op Vect</div><div class="line">.L45:</div><div class="line">        p.sw    a5,4(a3!)       # store post inc</div><div class="line">        add     a1,a1,128</div><div class="line">.L46:</div><div class="line">        add     a0,a0,128</div><div class="line">        ret</div></div><!-- fragment --> <h2><a class="anchor" id="section43"></a>
Example of optimization with vectors and parallelization</h2>
<h3><a class="anchor" id="section44"></a>
Introduction</h3>
<p>In this section we will illustrate step by step how to optimize a 5 x 5, 2D convolution operating on byte inputs and using byte filter coefficients.</p>
<p>All cycle measurements in these examples were obtained from actual measurements on simulation of GAP8.</p>
<p>We start from a straightforward single core, fixed point implementation in both a basic and then partially unrolled version. Then we use vectorization to improve performance and then further refine the vectorized version. The first step speeds up the code by a factor of 2.84 and the second step by a factor of 2.6. The combination of the two techniques runs with 7.3 times the speed of the straight scalar implementation on one core.</p>
<p>We then show how this single core code is modified to run on the 8 cores of GAP8's cluster, increasing speed by an almost ideal factor of 8. The combination of single core centric optimizations with parallelization leads to an increase in performance of 56.8 times versus the basic single core implementation. It runs in as little as 2.5 processor cycles per full 5 x 5 convolution.</p>
<p>A 5 x 5, 2D convolution is simply a dot product (the sum of the multiplication of each element with the corresponding element) between all the values in the 5 x 5 coefficient matrix and the content of the 5 x 5 square below the coefficient matrix in the input plane.</p>
<p>We obtain all the convolution outputs by sliding the fixed value 5 x 5 coefficient matrix in the 2 directions of the input plane by a step of 1. If the input plane has dimension [WxH] the dimension of the output plane will be [(W-4)x(H-4)].</p>
<p>We assume input data and filter coefficients are fixed point numbers in the [-1.0 .. 1.0] range, in Q<sup>7</sup> format[^1]. When two Q<sup>7</sup> numbers are multiplied the result is a Q<sup>14</sup> number, to normalize it back to Q<sup>7</sup> we simply have to shift its content by 7 bits to the right.</p>
<p>A single 5 x 5 convolution output is the result of a sum of 25 products where each product has arguments in the [-1.0 .. 1.0] range, therefore a convolution output is in the [-25.0 .. 25.0] range. In order to avoid overflow we need to right shift the result by 7 + 5, 7 coming from the Q<sup>7</sup> format of the inputs and 5 from ceil(log<sub>2</sub>(25)).</p>
<p>We choose to move down columns first, so we slide the window vertically down the whole height of the input plane before moving to the next vertical strip. This is illustrated in the diagram below:</p>
<div class="image">
<img src="convolution.png" alt="convolution.png"/>
<div class="caption">
Diagram of convolution</div></div>
 <h3><a class="anchor" id="section45"></a>
Basic scalar implementation</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__groupBuiltinsAPI.html#ga3dcd3f21285762bff56ed9452b41a964">__attribute__</a> ((noinline)) Straight2D_5x5_Convolution( </div><div class="line">  <span class="keywordtype">signed</span> <span class="keywordtype">char</span> *__restrict__ In, </div><div class="line">  <span class="keywordtype">signed</span> <span class="keywordtype">char</span> *__restrict__ Out, </div><div class="line">  <span class="keywordtype">signed</span> <span class="keywordtype">char</span> *__restrict__ Coeff, </div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> W, </div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> H) </div><div class="line"></div><div class="line">{ </div><div class="line">  <span class="keywordtype">int</span> i, j, k0, k1; </div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (i=0; i&lt;(W-4); i++) { </div><div class="line">    <span class="keywordflow">for</span> (j=0; j&lt;(H-4); j++) { </div><div class="line">      <span class="keywordtype">int</span> Result = 0; </div><div class="line">      <span class="keywordflow">for</span> (k1=0; k1&lt;5; k1++) { </div><div class="line">        <span class="keywordflow">for</span> (k0=0; k0&lt;5; k0++) {</div><div class="line">          Result = Result + In[(j+k1)*W+i+k0]*Coeff[5*k1+k0]; </div><div class="line">        } </div><div class="line">      } </div><div class="line">      Out[j*(W-4)+i] = Result&gt;&gt;(7+5); <span class="comment">// Normalize and avoid overflow</span></div><div class="line">    }</div><div class="line">  } </div><div class="line">} </div></div><!-- fragment --><p>For this first implementation the <b>number of cycles per convolution output is 142</b>.</p>
<p>Below we list the Extended ISA RISC-V assembly code generated by the compiler for the central part of the kernel where most of the complexity is:</p>
<div class="fragment"><div class="line">1c0012c8: 00df407b lp.setup x0,t5,1c0012e2</div><div class="line">1c0012cc: 8896 mv a7,t0</div><div class="line">1c0012ce: 887e mv a6,t6</div><div class="line">1c0012d0: 005350fb lp.setupi x1,5,1c0012dc</div><div class="line">1c0012d4: 00180e8b p.lb t4,1(a6!)</div><div class="line"># t3 load</div><div class="line">1c0012d8: 00188e0b p.lb t3,1(a7!)</div><div class="line"># t3 used in MAC</div><div class="line">1c0012dc: 43ce8333 p.mac t1,t4,t3</div><div class="line">1c0012e0: 9fb6 add t6,t6,a3</div><div class="line">1c0012e2: 0295 addi t0,t0,5</div></div><!-- fragment --><p>Firstly, notice that the compiler has optimized the loops using the GAP8 extended ISA loop setup instructions.</p>
<p>We see that the inner loop is iterated 5 times and at each iteration we do 2 reads and a MAC (multiply/accumulate). Unfortunately the t3 input of the MAC comes from the load in the instruction right before it so we have a 1 cycle stall since the data is not immediately ready. The total impact of this 1 cycle penalty is 25 cycles per convolution output. If we can get rid of this penalty we should be able to get down to 117 cycles per output.</p>
<p>The compiler is pipeline aware and schedules the code in order to minimize stall cycles. Unfortunately in this case the scheduling window is one iteration of the inner loop, there is simply no solution to remove this penalty. One possibility is to try unrolling the loop by compiling in -O2 mode to avoid the code bloating effect coming from systematic in-lining performed with -O3.</p>
<p>Another alternative is to perform partial unrolling of the loop manually. This is what we are going to do in the inner loop:</p>
<h3><a class="anchor" id="section46"></a>
Partially unrolled scalar implementation</h3>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;(W-4); i++) { </div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;(H-4); j++) { </div><div class="line">    <span class="keywordtype">int</span> Result = 0; </div><div class="line">    <span class="keywordflow">for</span> (k1=0; k1&lt;5; k1++) { <span class="comment">// Inner loop is unrolled</span></div><div class="line">      Result = Result + In[(j+k1)*W+i+0]*Coeff[5*k1+0]; </div><div class="line">      Result = Result + In[(j+k1)*W+i+1]*Coeff[5*k1+1]; </div><div class="line">      Result = Result + In[(j+k1)*W+i+2]*Coeff[5*k1+2]; </div><div class="line">      Result = Result + In[(j+k1)*W+i+3]*Coeff[5*k1+3]; </div><div class="line">      Result = Result + In[(j+k1)*W+i+4]*Coeff[5*k1+4]; </div><div class="line">    } </div><div class="line">    Out[j*(W-4)+i] = Result&gt;&gt;(7+5); </div><div class="line">  } </div><div class="line">} </div></div><!-- fragment --><p>Running this new code we are now getting <b>97 cycles per convolution output</b> instead of 142. This is more than expected mostly because the generated code now is also more compact with optimal usage of post modified memory accesses.</p>
<p>If we again dump the generated code we see that the inner loop is now optimally scheduled with no more load use penalty. With this unrolled form we are now very close to the minimum number of instructions needed for a 5 x 5 convolution, 5 * (10 loads + 5 macs) = 75. Here we have 80 (5 x 16) instructions executed:</p>
<div class="fragment"><div class="line">1c001372: 01f6c0fb lp.setup x1,a3,1c0013b0</div><div class="line">1c001376: 00070e03 lb t3,0(a4)</div><div class="line">1c00137a: 0058830b lb t1,5(a7!)</div><div class="line">1c00137e: 00170d83 lb s11,1(a4)</div><div class="line">1c001382: 0058038b lb t2,5(a6!)</div><div class="line">1c001386: 00270283 lb t0,2(a4)</div><div class="line">1c00138a: 00550f8b lb t6,5(a0!)</div><div class="line">1c00138e: 00370f03 lb t5,3(a4)</div><div class="line">1c001392: 00558e8b lb t4,5(a1!)</div><div class="line">1c001396: 426e07b3 p.mac a5,t3,t1</div><div class="line">1c00139a: 00470e03 lb t3,4(a4)</div><div class="line">1c00139e: 0056030b lb t1,5(a2!)</div><div class="line">1c0013a2: 9722 add a4,a4,s0</div><div class="line">1c0013a4: 427d87b3 p.mac a5,s11,t2</div><div class="line">1c0013a8: 43f287b3 p.mac a5,t0,t6</div><div class="line">1c0013ac: 43df07b3 p.mac a5,t5,t4</div><div class="line">1c0013b0: 426e07b3 p.mac a5,t3,t1</div></div><!-- fragment --><h3><a class="anchor" id="section47"></a>
First vectorial implementation</h3>
<p>GAP8 has built-in support for vectors of 4 byte elements or 2 short elements. Among the supported vectorial instructions there is a one cycle dot product. In our case our input data and coefficients are bytes so they are perfect candidates for vectors of 4 elements. A dot product in this configuration computes 4 products and sums them into a 32 bit output optionally accumulating the sum with an existing value in a register in a single cycle.</p>
<p>If V<sub>0</sub> and V<sub>1</sub> are 2 vectors of 4 bytes each then:</p>
<p>Acc = Acc + V<sub>0</sub>[0] * V<sub>1</sub>[0] + V<sub>0</sub>[1] * V<sub>1</sub>[1] + V<sub>0</sub>[2] * V<sub>1</sub>[2] + V<sub>0</sub>[3] * V<sub>1</sub>[3].</p>
<p>Each individual product produces a 32 bit result and this is what makes this instruction extremely interesting because the width of its output is much larger than the width of its inputs avoiding overflow.</p>
<p>The diagram below shows how vectors can be used to compute a given convolution. V<sub>0</sub>, V<sub>1</sub>, V<sub>2</sub>, V<sub>3</sub>, V<sub>4</sub> are vector accesses while B<sub>0</sub> to B<sub>4</sub> are regular byte accesses:</p>
<div class="image">
<img src="vector_layout_1.png" alt="vector_layout_1.png"/>
<div class="caption">
Vector layout</div></div>
<p> Here is the code that uses this vector layout:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__groupBuiltinsAPI.html#ga3dcd3f21285762bff56ed9452b41a964">__attribute__</a> ((noinline)) VectorStraight2D_5x5_Convolution( </div><div class="line">  <span class="keywordtype">signed</span> <span class="keywordtype">char</span> *__restrict__ In, </div><div class="line">  <span class="keywordtype">signed</span> <span class="keywordtype">char</span> *__restrict__ Out, </div><div class="line">  <span class="keywordtype">signed</span> <span class="keywordtype">char</span> *__restrict__ Coeff, </div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> W, </div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> H) </div><div class="line">{ </div><div class="line">  <span class="keywordtype">int</span> i, j, k0; </div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (i=0; i&lt;(W-4); i++) { </div><div class="line">    <span class="keywordflow">for</span> (j=0; j&lt;(H-4); j++) { </div><div class="line">      <span class="keywordtype">int</span> Result = 0; </div><div class="line">      <span class="keywordflow">for</span> (k0=0; k0&lt;5; k0++) { </div><div class="line">        v4s Vin = *((v4s *) (&amp;In[(j+k0)*W+i])); <span class="comment">// Input vector</span></div><div class="line">        v4s Vc  = *((v4s *) (&amp;Coeff[k0*5])); <span class="comment">// Coefficients accessed as vectors</span></div><div class="line">        <span class="comment">// We use a built-in to evaluate 4 of the 5 products in 1 cycle</span></div><div class="line">        Result = <a class="code" href="group__groupGap8Mac.html#gaebf323029e46f8059ebf3228986ebd86">gap8_sumdotp4</a>(Vin, Vc, Result);</div><div class="line">        <span class="comment">// The last product is as usual </span></div><div class="line">        Result += In[(j+k0)*W+i+4]*Coeff[k0*5+4]; </div><div class="line">      } </div><div class="line">      Out[j*(W-4)+i] = Result&gt;&gt;(7+5); </div><div class="line">    } </div><div class="line">  } </div><div class="line">} </div></div><!-- fragment --><p>The <a class="el" href="group__groupGap8Mac.html#gaebf323029e46f8059ebf3228986ebd86">gap8_sumdotp4()</a> macro expands to the appropriate gcc built-in. Refer to the API documentation for more information.</p>
<p>If we measure the number of cycles obtained with this new code the <b>number of cycles per convolution output is 50</b>.</p>
<h3><a class="anchor" id="section48"></a>
Aggressive vectorial optimization</h3>
<p>We could likely save a little bit unrolling the inner loop as in the earlier scalar example however if we look more carefully at this code we can see an even greater optimization possibility by looking at the data that changes between 2 consecutive convolution evaluations.</p>
<p>Obviously the filter stays constant for the entire input plane however 4/5th of the input plane data is also the same between convolution evaluations since we are just sliding the convolution window down by one value. If we can exploit this then we will not only save cycles but also reduce the memory accesses from shared level 1 memory by 80%.</p>
<p>The diagram bellow shows how the vectors are mapped for this strategy and how the vectors are updated when moving from one convolution to the next:</p>
<div class="image">
<img src="vector_layout_2.png" alt="vector_layout_2.png"/>
<div class="caption">
Vector layout</div></div>
<p> As you can see most of the vectors follow the natural order of the input. V<sub>5</sub> is an exception since it is vertical. Only the first element of V<sub>6</sub> is used. The right call-out box explains how we build next V<sub>6</sub> from current V<sub>5</sub> and V<sub>6</sub>. This process is called vectorial shuffling and is supported by a standard gcc built-in: __builtin_shuffle(V<sub>0</sub>, V<sub>1</sub>, ShuffleVector).</p>
<p>In the gcc built-in, the vector's elements are labeled from 0 to N-1 where N is the size of the vector. In our case N=4. ShuffleVector indicates which element to pick from V<sub>0</sub> or V<sub>1</sub> to produce the i<sup>th</sup> output. The elements of V<sub>0</sub> are numbered from 0 to 3 and V<sub>1</sub> from 4 to 7, so for example __builtin_shuffle(V<sub>0</sub>, V<sub>1</sub>, (v4s) {7, 0, 1, 5}) will return {V<sub>1</sub>[3], V<sub>0</sub>[0], V<sub>0</sub>[1], V<sub>1</sub>[1]}. For our case, the permutation vector we need is (v2s) {1, 2, 3, 4}, a simple shift of one value.</p>
<p>Putting everything together we obtain the following code. As you will see there is a bit more going on since we have to take care of priming the vectors at the beginning of each vertical strip in the input data and we also have to use type casts to convert the input data from bytes to vectors:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__groupBuiltinsAPI.html#ga3dcd3f21285762bff56ed9452b41a964">__attribute__</a> ((noinline)) VectorOpt2D_5x5_Convolution( </div><div class="line">  <span class="keywordtype">signed</span> <span class="keywordtype">char</span> *__restrict__ In, </div><div class="line">  <span class="keywordtype">signed</span> <span class="keywordtype">char</span> *__restrict__ Out, </div><div class="line">  <span class="keywordtype">signed</span> <span class="keywordtype">char</span> *__restrict__ Coeff, </div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> W, </div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> H) </div><div class="line"></div><div class="line">{ </div><div class="line">  <span class="comment">// If we promote all coefficients to vectors, notice that the layout has to </span></div><div class="line">  <span class="comment">// be the same as the one we are using for the data</span></div><div class="line">  v4s C0 = *((v4s *) &amp;Coeff[5*0 + 0]); </div><div class="line">  v4s C1 = *((v4s *) &amp;Coeff[5*1 + 0]); </div><div class="line">  v4s C2 = *((v4s *) &amp;Coeff[5*2 + 0]); </div><div class="line">  v4s C3 = *((v4s *) &amp;Coeff[5*3 + 0]); </div><div class="line">  v4s C4 = *((v4s *) &amp;Coeff[5*4 + 0]); </div><div class="line">  v4s C5 = (v4s) {Coeff[5*0 + 4], Coeff[5*1 + 4], Coeff[5*2 + 4], Coeff[5*3 + 4]}; </div><div class="line">  v4s C6 = (v4s) (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) (((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)Coeff)[5*4+4]); </div><div class="line">  <span class="keywordtype">int</span> i, j, k0; </div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (i=0; i&lt;(W-4); i++) { </div><div class="line">    v4s V0; </div><div class="line">    <span class="comment">// Here we have to prime the pipeline</span></div><div class="line">    v4s V1 = *((v4s *) &amp;In[(0)*W+i]); </div><div class="line">    v4s V2 = *((v4s *) &amp;In[(1)*W+i]); </div><div class="line">    v4s V3 = *((v4s *) &amp;In[(2)*W+i]); </div><div class="line">    v4s V4 = *((v4s *) &amp;In[(3)*W+i]); </div><div class="line">    v4s V5 = (v4s) {0, In[(0)*W+i+4],  In[(1)*W+i+4],  In[(2)*W+i+4]}; </div><div class="line">    v4s V6 = (v4s) (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)In)[(3)*W+i+4]); </div><div class="line">    <span class="keywordflow">for</span> (j=0; j&lt;(H-4); j++) { </div><div class="line">      <span class="keywordtype">int</span> Result; </div><div class="line">      v4s *Vin = (v4s *) &amp;In[j*W+i]; </div><div class="line"></div><div class="line">      <span class="comment">// Implements the shuffle from previous output to current</span></div><div class="line">      V0 = V1; V1 = V2; V2 = V3; V3 = V4;</div><div class="line">      V5 = __builtin_shuffle(V5, V6, (v4s) {1,2,3,4}); </div><div class="line">      <span class="comment">// Now these 2 reads is what is left from the original 50 ones</span></div><div class="line">      V4 = Vin[0]; V6 = Vin[1]; </div><div class="line"></div><div class="line">     <span class="comment">// Now we evaluate the 25 sums of products</span></div><div class="line">      Result = <a class="code" href="group__groupGap8Mac.html#ga2a4d3fb9e9b2537fe89f7868438e674b">gap8_dotp4</a>(V0, C0); </div><div class="line">      Result = <a class="code" href="group__groupGap8Mac.html#gaebf323029e46f8059ebf3228986ebd86">gap8_sumdotp4</a>(V1, C1, Result); </div><div class="line">      Result = <a class="code" href="group__groupGap8Mac.html#gaebf323029e46f8059ebf3228986ebd86">gap8_sumdotp4</a>(V2, C2, Result); </div><div class="line">      Result = <a class="code" href="group__groupGap8Mac.html#gaebf323029e46f8059ebf3228986ebd86">gap8_sumdotp4</a>(V3, C3, Result); </div><div class="line">      Result = <a class="code" href="group__groupGap8Mac.html#gaebf323029e46f8059ebf3228986ebd86">gap8_sumdotp4</a>(V4, C4, Result); </div><div class="line">      Result = <a class="code" href="group__groupGap8Mac.html#gaebf323029e46f8059ebf3228986ebd86">gap8_sumdotp4</a>(V5, C5, Result); </div><div class="line">      Result = <a class="code" href="group__groupGap8Mac.html#gaebf323029e46f8059ebf3228986ebd86">gap8_sumdotp4</a>(V6, C6, Result); </div><div class="line"></div><div class="line">      Out[j*(W-4)+i] = Result&gt;&gt;(7+5); </div><div class="line">    } </div><div class="line">  } </div><div class="line">} </div></div><!-- fragment --><p>Here is the generated assembly for this version looking only at what is done for the loop going through an entire vertical strip <code>(for (j=0; j&lt;(H-4); j++) {...})</code>:</p>
<div class="fragment"><div class="line">1c00145e:       01ea40fb                   lp.setup        x1,s4,1c00149a</div><div class="line">1c001462:       987797d7                   pv.dotsp.b      a5,a5,t2</div><div class="line">1c001466:       b88e17d7                   pv.sdotsp.b     a5,t3,s0</div><div class="line">1c00146a:       000f2703                   lw      a4,0(t5)</div><div class="line">1c00146e:       b89317d7                   pv.sdotsp.b     a5,t1,s1</div><div class="line">1c001472:       b92897d7                   pv.sdotsp.b     a5,a7,s2</div><div class="line">1c001476:       c9681657                   pv.shuffle2.b   a2,a6,s6</div><div class="line">1c00147a:       b93717d7                   pv.sdotsp.b     a5,a4,s3</div><div class="line">1c00147e:       004f2803                   lw      a6,4(t5)</div><div class="line">1c001482:       b9f617d7                   pv.sdotsp.b     a5,a2,t6</div><div class="line">1c001486:       b85817d7                   pv.sdotsp.b     a5,a6,t0</div><div class="line">1c00148a:       40c7de93                   srai    t4,a5,0xc</div><div class="line">1c00148e:       01daccab                   sb      t4,s9(s5!)</div><div class="line">1c001492:       87f2                       mv      a5,t3</div><div class="line">1c001494:       9f36                       add     t5,t5,a3</div><div class="line">1c001496:       8e1a                       mv      t3,t1</div><div class="line">1c001498:       8346                       mv      t1,a7</div><div class="line">1c00149a:       88ba                       mv      a7,a4</div></div><!-- fragment --><p>As you can see it is extremely compact.</p>
<p>If we measure the number of cycles obtained with this new code the <b>number of cycles per convolution output is 19</b>.</p>
<p>The table below summarizes the cycles per convolution for our 4 versions.</p>
<table class="doxtable">
<tr>
<th align="left">Algorithm </th><th align="right">cycles  </th></tr>
<tr>
<td align="left">Initial version </td><td align="right">142 </td></tr>
<tr>
<td align="left">With unrolling </td><td align="right">97 </td></tr>
<tr>
<td align="left">Using vectors </td><td align="right">50 </td></tr>
<tr>
<td align="left">Aggressively using vectors </td><td align="right">19 </td></tr>
</table>
<h3><a class="anchor" id="section49"></a>
Parallel versions</h3>
<p>So far we have been using a single core. Now we will see how to modify the code to use all the available cores in the GAP8 cluster.</p>
<p>To parallelize the code the most important thing to notice is that the evaluation of one vertical strip is completely independent from the evaluation of the other vertical strips in the input. Given this, it is straightforward to see that if we split the output plane on groups of vertical strips we will be able to provide work to all the cores that are available. The figure below illustrates this. In the diagram below for simplicity we assume we have 3 cores:</p>
<div class="image">
<img src="core_split.png" alt="core_split.png"/>
<div class="caption">
Parallelizing the strips</div></div>
<p> The code below shows our initial basic scalar implementation extended to a parallel version:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__groupBuiltinsAPI.html#ga3dcd3f21285762bff56ed9452b41a964">__attribute__</a> ((noinline)) Straight2D_5x5_Convolution_Par(ArgConv_T *Arg) </div><div class="line">{ </div><div class="line">  <span class="comment">// For parallel calls we use the rt_team_fork() dispatcher so in this case</span></div><div class="line">  <span class="comment">// arguments have to be grouped into a single structure and then we pass the</span></div><div class="line">  <span class="comment">// address of this structure to the function in the fork.</span></div><div class="line">  <span class="comment">// Here we simply extract arguments:</span></div><div class="line">  <span class="keywordtype">signed</span> <span class="keywordtype">char</span> *__restrict__ In = Arg-&gt;In; </div><div class="line">  <span class="keywordtype">signed</span> <span class="keywordtype">char</span> *__restrict__ Out = Arg-&gt;Out; </div><div class="line">  <span class="keywordtype">signed</span> <span class="keywordtype">char</span> *__restrict__ Coeff = Arg-&gt;Coeff; </div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> W = Arg-&gt;W; </div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> H = Arg-&gt;H; </div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> CoreId = <a class="code" href="group__groupGap8Mac.html#gad7bd4973ff499b8413bf81319569efe8">gap8_coreid</a>();  <span class="comment">// core number on which this code </span></div><div class="line">                                        <span class="comment">// runs, in 0..MaxCore-1</span></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Chunk = ChunkSize(W-4);  <span class="comment">// Returns (W-4)/NumbeOfCores</span></div><div class="line">  <span class="comment">// Now we have the chunk size we can compute first and last positions</span></div><div class="line">  <span class="comment">// for this core</span></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> First = CoreId*Chunk, Last = Min(First+Chunk, W-4); </div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> i, j, k0, k1; </div><div class="line"></div><div class="line">  <span class="comment">// for (i=0; i&lt;(W-4); i++) { </span></div><div class="line">  <span class="keywordflow">for</span> (i=First; i&lt;Last; i++) { </div><div class="line">    <span class="keywordflow">for</span> (j=0; j&lt;(H-4); j++) { </div><div class="line">      <span class="keywordtype">int</span> Result = 0; </div><div class="line">      <span class="keywordflow">for</span> (k1=0; k1&lt;5; k1++) { </div><div class="line">        <span class="keywordflow">for</span> (k0=0; k0&lt;5; k0++) {</div><div class="line">          Result = Result + In[(j+k1)*W+i+k0]*Coeff[5*k1+k0]; </div><div class="line">        } </div><div class="line">      } </div><div class="line">      Out[j*(W-4)+i] = Result&gt;&gt;(7+5); </div><div class="line">    } </div><div class="line">  } </div><div class="line">  gap8_waitbarrier(0);  <span class="comment">// Synchronizes with the other worker</span></div><div class="line">} </div></div><!-- fragment --><p>For all the other code variants the approach is identical.</p>
<p>The table bellow gives the number of cycles per convolution output for our 4 versions, running on 1, 2, 4 and 8 cores.</p>
<table class="doxtable">
<tr>
<th align="left"></th><th align="center">1 core </th><th align="center">2 cores </th><th align="center">4 cores </th><th align="center">8 cores  </th></tr>
<tr>
<td align="left">Initial version </td><td align="center">142 </td><td align="center">71 </td><td align="center">35 </td><td align="center">19 </td></tr>
<tr>
<td align="left">With unrolling </td><td align="center">97.4 </td><td align="center">48.9 </td><td align="center">25.2 </td><td align="center">14.2 </td></tr>
<tr>
<td align="left">Using vectors </td><td align="center">50 </td><td align="center">25.2 </td><td align="center">13 </td><td align="center">7.4 </td></tr>
<tr>
<td align="left">Aggressively using vectors </td><td align="center">19.2 </td><td align="center">9.5 </td><td align="center">4.8 </td><td align="center">2.5 </td></tr>
</table>
<p>You will notice that moving to a parallel implementation has nearly no impact on the performance on 1 core. Also the scaling factor is very close to the ideal as we increase cores, i.e. the cycles decrease proportionally to the number of cores used. In the most aggressive implementation we move from 19.2 down to 2.5 cycles per convolution as we move from 1 to 8 cores, a speed up of a factor 7.68.</p>
<p>If we omit the initial version and compare the result for 1 core with the unrolling version to 8 cores with the most aggressive version we move from 97.4 to 2.5 cycles, an improvement of nearly 39 times.</p>
<p>The way to understand why we are seeing this much improvement is to look at the resources we are using. First we used 4 dimensional vectors, we can expect a 4 times improvement in performance. Next we parallelized the code with 8 cores, another 8 times faster on top of our original 4 times, so 32 times faster in total, consistent with our 39 times observed improvement.</p>
<p>[^1]: See <a href="https://en.wikipedia.org/wiki/Q_\(number_format\)">Q fixed point number format - https://en.wikipedia.org/wiki/Q_(number_format)</a> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jan 24 2020 12:47:51 for Runtime by GreenWaves Technologies
	<!--
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 
	-->
	</li>
  </ul>
</div>
</body>
</html>
