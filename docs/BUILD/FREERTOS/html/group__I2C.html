<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>I2C</title>
<title>I2C</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="pulp.css" rel="stylesheet" type="text/css" />
<link href="gap.css" rel="stylesheet" type="text/css" />
<link href="images.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="printComponentTabs.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="titlerow">
  <td id="projectlogo"><img alt="Logo" src="gap-logo-55.png" /></td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">FreeRTOS port on GAP8/RISC-V</div>
    </td>
  <td id="extralogo"><img alt="GreenWaves" src="greenwaves-logo-55.png" /></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="CMSISnav" class="tabs1">
    <ul class="tablist">
      <script type="text/javascript">
		<!--
		writeComponentTabs.call(this);
		//-->
      </script>
	  </ul>
</div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__I2C.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">I2C<div class="ingroups"><a class="el" href="group__groupDrivers.html">Drivers</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpi__i2c__conf__t.html">pi_i2c_conf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C master configuration structure.  <a href="structpi__i2c__conf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga070fab4a06e9094610d5932468c234f1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga070fab4a06e9094610d5932468c234f1">pi_i2c_xfer_flags_e</a> <tr class="memdesc:ga070fab4a06e9094610d5932468c234f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Properties for I2C transfers.  <a href="group__I2C.html#ga070fab4a06e9094610d5932468c234f1">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga070fab4a06e9094610d5932468c234f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ec0aed6b95844c3db5d25c071eb13e9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga9ec0aed6b95844c3db5d25c071eb13e9">pi_i2c_ioctl_e</a> <tr class="memdesc:ga9ec0aed6b95844c3db5d25c071eb13e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commands for pi_i2c_control.  <a href="group__I2C.html#ga9ec0aed6b95844c3db5d25c071eb13e9">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga9ec0aed6b95844c3db5d25c071eb13e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafbc69a819c088ca6517bc9fa5127f053"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gafbc69a819c088ca6517bc9fa5127f053">pi_i2c_conf_init</a> (<a class="el" href="structpi__i2c__conf__t.html">pi_i2c_conf_t</a> *conf)</td></tr>
<tr class="memdesc:gafbc69a819c088ca6517bc9fa5127f053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an I2C configuration with default values.  <a href="#gafbc69a819c088ca6517bc9fa5127f053">More...</a><br /></td></tr>
<tr class="separator:gafbc69a819c088ca6517bc9fa5127f053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga994bb0c18af12a1ff37dd9496dd7a60f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga994bb0c18af12a1ff37dd9496dd7a60f">pi_i2c_open</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>)</td></tr>
<tr class="memdesc:ga994bb0c18af12a1ff37dd9496dd7a60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open an I2C device.  <a href="#ga994bb0c18af12a1ff37dd9496dd7a60f">More...</a><br /></td></tr>
<tr class="separator:ga994bb0c18af12a1ff37dd9496dd7a60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab16e5a148668fba02eac1691ae7cc21c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gab16e5a148668fba02eac1691ae7cc21c">pi_i2c_close</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>)</td></tr>
<tr class="memdesc:gab16e5a148668fba02eac1691ae7cc21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an opened I2C device.  <a href="#gab16e5a148668fba02eac1691ae7cc21c">More...</a><br /></td></tr>
<tr class="separator:gab16e5a148668fba02eac1691ae7cc21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72a5e1c6cc13a2addbd4ed20ff3dbab1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga72a5e1c6cc13a2addbd4ed20ff3dbab1">pi_i2c_ioctl</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, uint32_t cmd, void *arg)</td></tr>
<tr class="memdesc:ga72a5e1c6cc13a2addbd4ed20ff3dbab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically change the device configuration.  <a href="#ga72a5e1c6cc13a2addbd4ed20ff3dbab1">More...</a><br /></td></tr>
<tr class="separator:ga72a5e1c6cc13a2addbd4ed20ff3dbab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf032c4a19e81923108c528ab7b510aea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gaf032c4a19e81923108c528ab7b510aea">pi_i2c_read</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, uint8_t *rx_buff, int length, <a class="el" href="group__I2C.html#ga070fab4a06e9094610d5932468c234f1">pi_i2c_xfer_flags_e</a> flags)</td></tr>
<tr class="memdesc:gaf032c4a19e81923108c528ab7b510aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a burst read copy from the I2C (from I2C device to chip).  <a href="#gaf032c4a19e81923108c528ab7b510aea">More...</a><br /></td></tr>
<tr class="separator:gaf032c4a19e81923108c528ab7b510aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad02572af9b2151e132b2ef7227651a70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gad02572af9b2151e132b2ef7227651a70">pi_i2c_write</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, uint8_t *tx_data, int length, <a class="el" href="group__I2C.html#ga070fab4a06e9094610d5932468c234f1">pi_i2c_xfer_flags_e</a> flags)</td></tr>
<tr class="memdesc:gad02572af9b2151e132b2ef7227651a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a burst write copy to the I2C (from chip to I2C device).  <a href="#gad02572af9b2151e132b2ef7227651a70">More...</a><br /></td></tr>
<tr class="separator:gad02572af9b2151e132b2ef7227651a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf971585c8d4ecfce2b9b2454f2c120af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gaf971585c8d4ecfce2b9b2454f2c120af">pi_i2c_read_async</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, uint8_t *rx_buff, int length, <a class="el" href="group__I2C.html#ga070fab4a06e9094610d5932468c234f1">pi_i2c_xfer_flags_e</a> flags, pi_task_t *task)</td></tr>
<tr class="memdesc:gaf971585c8d4ecfce2b9b2454f2c120af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue an asynchronous burst read copy from the I2C (from I2C device to chip).  <a href="#gaf971585c8d4ecfce2b9b2454f2c120af">More...</a><br /></td></tr>
<tr class="separator:gaf971585c8d4ecfce2b9b2454f2c120af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8231d77bdd1e0ba37e085578c20f68d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gab8231d77bdd1e0ba37e085578c20f68d">pi_i2c_write_async</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, uint8_t *tx_data, int length, <a class="el" href="group__I2C.html#ga070fab4a06e9094610d5932468c234f1">pi_i2c_xfer_flags_e</a> flags, pi_task_t *task)</td></tr>
<tr class="memdesc:gab8231d77bdd1e0ba37e085578c20f68d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a burst write copy to the I2C (from chip to I2C device).  <a href="#gab8231d77bdd1e0ba37e085578c20f68d">More...</a><br /></td></tr>
<tr class="separator:gab8231d77bdd1e0ba37e085578c20f68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>The I2C driver provides support for transferring data between an external I2C device and the chip running this driver. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga9ec0aed6b95844c3db5d25c071eb13e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ec0aed6b95844c3db5d25c071eb13e9">&#9670;&nbsp;</a></span>pi_i2c_ioctl_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__I2C.html#ga9ec0aed6b95844c3db5d25c071eb13e9">pi_i2c_ioctl_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is used to tell which command to execute through pi_i2c_control. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9ec0aed6b95844c3db5d25c071eb13e9a8792e2c858f77e13af9842b47744c498"></a>PI_I2C_CTRL_SET_MAX_BAUDRATE&#160;</td><td class="fielddoc"><p>Change maximum baudrate. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga070fab4a06e9094610d5932468c234f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga070fab4a06e9094610d5932468c234f1">&#9670;&nbsp;</a></span>pi_i2c_xfer_flags_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__I2C.html#ga070fab4a06e9094610d5932468c234f1">pi_i2c_xfer_flags_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is used to specify additional behaviors when transfering data through I2C. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga070fab4a06e9094610d5932468c234f1aef0576b0c9d873bb8809336067ee5746"></a>PI_I2C_XFER_STOP&#160;</td><td class="fielddoc"><p>Generate a STOP bit at the end of the transfer. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga070fab4a06e9094610d5932468c234f1a46ff6ef209b09a72abe7f8f3f2f6747e"></a>PI_I2C_XFER_NO_STOP&#160;</td><td class="fielddoc"><p>Don't generate a STOP bit at the end of the transfer. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga070fab4a06e9094610d5932468c234f1a75c959c8861219ee57ab5786a37935af"></a>PI_I2C_XFER_START&#160;</td><td class="fielddoc"><p>Generate a START bit at the beginning of the transfer. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga070fab4a06e9094610d5932468c234f1acc7a05bc2f589f4dfd03ffe76855c78b"></a>PI_I2C_XFER_NO_START&#160;</td><td class="fielddoc"><p>Don't generate a START bit at the beginning of the transfer. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab16e5a148668fba02eac1691ae7cc21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab16e5a148668fba02eac1691ae7cc21c">&#9670;&nbsp;</a></span>pi_i2c_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_i2c_close </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to close an opened I2C device once it is not needed anymore, in order to free all allocated resources. Once this function is called, the device is not accessible anymore and must be opened again before being used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device structure of the device to close. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="i2c_8c.html#ae68f96d8605f3a4f1dbe7ec21372f7ea">_i2c_init</a>, <a class="el" href="group__soc__eu.html#gae2f2b681d5e3aacbfb0a156cf248bef4">hal_soc_eu_clear_fc_mask()</a>, <a class="el" href="maestro_8h.html#afd3147d9c9b4c531b7d78e6d29e1678a">if()</a>, <a class="el" href="structi2c__driver__fifo__s.html#aa4db44774ed660a3c6cb0b0f2d985e41">i2c_driver_fifo_s::pending</a>, <a class="el" href="implementation__specific__defines_8h.html#a34e9b2071f6b65328436b5bec63f9f43">pi_default_free</a>, <a class="el" href="group__FC__EventHandler.html#ga078939a689cc9013d38dfc8178ffcf75">pi_fc_event_handler_clear()</a>, <a class="el" href="GAP8_2udma_2udma__core_8h.html#a5d99792d51c83c5f4945cdba9d4085c6">udma_deinit_device()</a>, and <a class="el" href="GAP9_2properties_8h.html#a273396d30ac495aeb617ce836fed6837">UDMA_I2C_ID</a>.</p>

<p class="reference">Referenced by <a class="el" href="mt9v034_8c.html#a176c6b660705fe7fd3b9ad657854b81f">__mt9v034_open()</a>, <a class="el" href="thermeye_8c.html#a87c2516e570b2acdcfde8dd7b5668bc1">__pi_thermeye_close()</a>, and <a class="el" href="thermeye_8c.html#ad73b2b9ba76941bf3a30bd2f83d56b40">__pi_thermeye_open()</a>.</p>

</div>
</div>
<a id="gafbc69a819c088ca6517bc9fa5127f053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbc69a819c088ca6517bc9fa5127f053">&#9670;&nbsp;</a></span>pi_i2c_conf_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_i2c_conf_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpi__i2c__conf__t.html">pi_i2c_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to get default values for all parameters before setting some of them. The structure containing the configuration must be kept alive until the I2C device is opened.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>A pointer to the I2C configuration. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="structpi__i2c__conf__t.html#aa9acbac122b8c7cdf0b1054e5cbcb3a4">pi_i2c_conf_t::cs</a>, <a class="el" href="structpi__i2c__conf__t.html#af9e9123077a059645c7f9063cdaeb8dc">pi_i2c_conf_t::device</a>, <a class="el" href="structpi__i2c__conf__t.html#abfc435b761834bbb937c8b84cf2ce52e">pi_i2c_conf_t::itf</a>, and <a class="el" href="structpi__i2c__conf__t.html#a430fbafd79f8642ad95c254b49cd206e">pi_i2c_conf_t::max_baudrate</a>.</p>

<p class="reference">Referenced by <a class="el" href="himax_8c.html#a24acf7209d2dfa67ab017bb9b3afd657">__himax_open()</a>, <a class="el" href="mt9v034_8c.html#a176c6b660705fe7fd3b9ad657854b81f">__mt9v034_open()</a>, and <a class="el" href="thermeye_8c.html#ad73b2b9ba76941bf3a30bd2f83d56b40">__pi_thermeye_open()</a>.</p>

</div>
</div>
<a id="ga72a5e1c6cc13a2addbd4ed20ff3dbab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72a5e1c6cc13a2addbd4ed20ff3dbab1">&#9670;&nbsp;</a></span>pi_i2c_ioctl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_i2c_ioctl </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to change part of the device configuration after it has been opened.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
    <tr><td class="paramname">cmd</td><td>The command which specifies which parameters of the driver to modify and for some of them also their values. The command must be one of those defined in pi_i2c_ioctl_e. </td></tr>
    <tr><td class="paramname">arg</td><td>An additional value which is required for some parameters when they are set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga994bb0c18af12a1ff37dd9496dd7a60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga994bb0c18af12a1ff37dd9496dd7a60f">&#9670;&nbsp;</a></span>pi_i2c_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_i2c_open </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function must be called before the Hyperbus device can be used. It will do all the needed configuration to make it usable and initialize the handle used to refer to this opened device when calling other functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the device structure of the device to open. This structure is allocated by the called and must be kept alive until the device is closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

<p class="reference">References <a class="el" href="i2c__internal_8h.html#aac25c110c6135632e99049df4490b97d">__PI_I2C_CMD_BUFF_SIZE</a>, <a class="el" href="i2c__internal_8c.html#ac90d806b72714a71826dfa7e7303c8bf">__pi_i2c_get_clk_div()</a>, <a class="el" href="i2c_8c.html#ae68f96d8605f3a4f1dbe7ec21372f7ea">_i2c_init</a>, <a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#ac1de768ece04f74fded6dd88d1f48fc7">config</a>, <a class="el" href="structi2c__driver__fifo__s.html#af7c31c2ad270686237fe542bba8f006f">i2c_driver_fifo_s::cs</a>, <a class="el" href="nina__b112_8c.html#a5c8ef3c24dad2c469a42784a9a39403b">DEBUG_PRINTF</a>, <a class="el" href="structi2c__driver__fifo__s.html#af6a4024d2b8b335fc44b4c3ecf618d03">i2c_driver_fifo_s::div</a>, <a class="el" href="structi2c__driver__fifo__s.html#a5241ce846d1bc1627a43779983379568">i2c_driver_fifo_s::fifo_head</a>, <a class="el" href="structi2c__driver__fifo__s.html#a17e56425158af1010368e844f3eb8ee1">i2c_driver_fifo_s::fifo_tail</a>, <a class="el" href="group__soc__eu.html#gad1a987a6eda8871afca818c937445bbe">hal_soc_eu_set_fc_mask()</a>, <a class="el" href="structi2c__driver__fifo__s.html#a178ccf1cd2831caff38280913dca144f">i2c_driver_fifo_s::hw_buffer</a>, <a class="el" href="structi2c__driver__fifo__s.html#a58265cf02c47a8638af5b51a0096e350">i2c_driver_fifo_s::i2c_cmd_index</a>, <a class="el" href="structi2c__driver__fifo__s.html#af73f79e22789f660eb18841d9806402d">i2c_driver_fifo_s::i2c_cmd_seq</a>, <a class="el" href="GAP8_2periph_2i2c__periph_8h.html#ab268e894a5a9e6c0fd58c3e77f827462">I2C_CMD_STOP</a>, <a class="el" href="GAP8_2periph_2i2c__periph_8h.html#ab4c3721aba6b8d60cac8458f24f61305">I2C_CMD_WAIT</a>, <a class="el" href="i2c__internal_8c.html#a0bb9a533f52714cd5dbb8281c68bd458">i2c_handler()</a>, <a class="el" href="structi2c__driver__fifo__s.html#a1f651a866f78c456f1ac1d1111471e96">i2c_driver_fifo_s::i2c_stop_send</a>, <a class="el" href="structi2c__driver__fifo__s.html#a50210aa12a7186ee995bba69d6f120bb">i2c_driver_fifo_s::i2c_stop_seq</a>, <a class="el" href="maestro_8h.html#afd3147d9c9b4c531b7d78e6d29e1678a">if()</a>, <a class="el" href="structi2c__driver__fifo__s.html#a6746d1c26b8fdddf452987a2bbb69add">i2c_driver_fifo_s::max_baudrate</a>, <a class="el" href="structi2c__driver__fifo__s.html#aa4db44774ed660a3c6cb0b0f2d985e41">i2c_driver_fifo_s::pending</a>, <a class="el" href="implementation__specific__defines_8h.html#a34e9b2071f6b65328436b5bec63f9f43">pi_default_free</a>, <a class="el" href="implementation__specific__defines_8h.html#a304ae397bb9fd1521bd190fe23a638dc">pi_default_malloc</a>, <a class="el" href="group__FC__EventHandler.html#ga2c5a428d6c20fcadb6c0575f43d0663f">pi_fc_event_handler_set()</a>, <a class="el" href="GAP8_2udma_2udma__core_8h.html#ac04e8c1b74f45a39c258438bdf2b8b26a7be71f371ab2f1f75174f7fbe38b4205">RX_CHANNEL</a>, <a class="el" href="GAP8_2udma_2udma__core_8h.html#ac04e8c1b74f45a39c258438bdf2b8b26a63fe3e91b242c900c8f9d5c430636e88">TX_CHANNEL</a>, <a class="el" href="GAP9_2properties_8h.html#a273396d30ac495aeb617ce836fed6837">UDMA_I2C_ID</a>, and <a class="el" href="GAP8_2udma_2udma__core_8h.html#a4eed7ee5ee049a2e52bb25421fd1f299">udma_init_device()</a>.</p>

<p class="reference">Referenced by <a class="el" href="himax_8c.html#a24acf7209d2dfa67ab017bb9b3afd657">__himax_open()</a>, <a class="el" href="mt9v034_8c.html#a176c6b660705fe7fd3b9ad657854b81f">__mt9v034_open()</a>, and <a class="el" href="thermeye_8c.html#ad73b2b9ba76941bf3a30bd2f83d56b40">__pi_thermeye_open()</a>.</p>

</div>
</div>
<a id="gaf032c4a19e81923108c528ab7b510aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf032c4a19e81923108c528ab7b510aea">&#9670;&nbsp;</a></span>pi_i2c_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_i2c_read </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rx_buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__I2C.html#ga070fab4a06e9094610d5932468c234f1">pi_i2c_xfer_flags_e</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be used to read at least 1 byte of data from the I2C device. The copy will make a synchronous transfer between the I2C and one of the chip memory. The caller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
    <tr><td class="paramname">rx_buff</td><td>The address in the chip where the received data must be written. </td></tr>
    <tr><td class="paramname">length</td><td>The size in bytes of the copy. </td></tr>
    <tr><td class="paramname">flags</td><td>Specify additional transfer behaviors like start and stop bits management. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__I2C.html#gaf971585c8d4ecfce2b9b2454f2c120af">pi_i2c_read_async()</a>, <a class="el" href="group__Task.html#ga872ea1d492fe1307123c8d1ac783c792">pi_task_block()</a>, <a class="el" href="pmsis__task_8c.html#ac44ca37400e853f025e7993cca91689f">pi_task_block_no_mutex()</a>, <a class="el" href="group__Task.html#ga3b4463327b724512ace0257cb0951457">pi_task_wait_on()</a>, and <a class="el" href="pmsis__task_8c.html#a6791c1adb207c84fe25f340b0124448b">pi_task_wait_on_no_mutex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="himax_8c.html#a461dfdee5bc13968f6251e2a2e9e3a34">__himax_reg_read()</a>, <a class="el" href="mt9v034_8c.html#a92ae8cc56707bd596c2c4be0ea5a321c">__mt9v034_reg_read()</a>, and <a class="el" href="thermeye_8c.html#a7a71688ead00912ee55e2503d5c561aa">__pi_thermeye_reg_read()</a>.</p>

</div>
</div>
<a id="gaf971585c8d4ecfce2b9b2454f2c120af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf971585c8d4ecfce2b9b2454f2c120af">&#9670;&nbsp;</a></span>pi_i2c_read_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_i2c_read_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rx_buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__I2C.html#ga070fab4a06e9094610d5932468c234f1">pi_i2c_xfer_flags_e</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be used to read at least 1 byte of data from the I2C device. The copy will make an asynchronous transfer between the I2C and one of the chip memory. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
    <tr><td class="paramname">rx_buff</td><td>The address in the chip where the received data must be written. </td></tr>
    <tr><td class="paramname">length</td><td>The size in bytes of the copy. </td></tr>
    <tr><td class="paramname">flags</td><td>Specify additional transfer behaviors like start and stop bits management. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="group__I2C.html#gaf032c4a19e81923108c528ab7b510aea">pi_i2c_read()</a>.</p>

</div>
</div>
<a id="gad02572af9b2151e132b2ef7227651a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad02572af9b2151e132b2ef7227651a70">&#9670;&nbsp;</a></span>pi_i2c_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_i2c_write </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>tx_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__I2C.html#ga070fab4a06e9094610d5932468c234f1">pi_i2c_xfer_flags_e</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be used to write at least 1 byte of data to the I2C device. The copy will make a synchronous transfer between the I2C and one of the chip memory. The caller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
    <tr><td class="paramname">tx_data</td><td>The address in the chip where the data to be sent is read. </td></tr>
    <tr><td class="paramname">length</td><td>The size in bytes of the copy. </td></tr>
    <tr><td class="paramname">flags</td><td>Specify additional transfer behaviors like start and stop bits management. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__I2C.html#gab8231d77bdd1e0ba37e085578c20f68d">pi_i2c_write_async()</a>, <a class="el" href="group__Task.html#ga872ea1d492fe1307123c8d1ac783c792">pi_task_block()</a>, <a class="el" href="pmsis__task_8c.html#ac44ca37400e853f025e7993cca91689f">pi_task_block_no_mutex()</a>, <a class="el" href="group__Task.html#ga3b4463327b724512ace0257cb0951457">pi_task_wait_on()</a>, and <a class="el" href="pmsis__task_8c.html#a6791c1adb207c84fe25f340b0124448b">pi_task_wait_on_no_mutex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="himax_8c.html#a461dfdee5bc13968f6251e2a2e9e3a34">__himax_reg_read()</a>, <a class="el" href="himax_8c.html#a61d6d14cc1857402353cd907b850d5b8">__himax_reg_write()</a>, <a class="el" href="mt9v034_8c.html#a92ae8cc56707bd596c2c4be0ea5a321c">__mt9v034_reg_read()</a>, <a class="el" href="mt9v034_8c.html#a93e2aceffdd483b28e2e6ec5d022d7cf">__mt9v034_reg_write()</a>, <a class="el" href="thermeye_8c.html#a7a71688ead00912ee55e2503d5c561aa">__pi_thermeye_reg_read()</a>, and <a class="el" href="thermeye_8c.html#a9450a8de394167a4dd76096b7ddeed4e">__pi_thermeye_reg_write()</a>.</p>

</div>
</div>
<a id="gab8231d77bdd1e0ba37e085578c20f68d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8231d77bdd1e0ba37e085578c20f68d">&#9670;&nbsp;</a></span>pi_i2c_write_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_i2c_write_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>tx_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__I2C.html#ga070fab4a06e9094610d5932468c234f1">pi_i2c_xfer_flags_e</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be used to write at least 1 byte of data to the I2C device. The copy will make an asynchronous transfer between the I2C and one of the chip memory. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
    <tr><td class="paramname">tx_data</td><td>The address in the chip where the data to be sent is read. </td></tr>
    <tr><td class="paramname">length</td><td>The size in bytes of the copy </td></tr>
    <tr><td class="paramname">flags</td><td>Specify additional transfer behaviors like start and stop bits management. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="group__I2C.html#gad02572af9b2151e132b2ef7227651a70">pi_i2c_write()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jan 24 2020 12:47:54 for  by GreenWaves Technologies
	<!--
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 
	-->
	</li>
  </ul>
</div>
</body>
</html>
