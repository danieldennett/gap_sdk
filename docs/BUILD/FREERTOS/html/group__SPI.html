<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>SPI</title>
<title>SPI</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="pulp.css" rel="stylesheet" type="text/css" />
<link href="gap.css" rel="stylesheet" type="text/css" />
<link href="images.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="printComponentTabs.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="titlerow">
  <td id="projectlogo"><img alt="Logo" src="gap-logo-55.png" /></td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">FreeRTOS port on GAP8/RISC-V</div>
    </td>
  <td id="extralogo"><img alt="GreenWaves" src="greenwaves-logo-55.png" /></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="CMSISnav" class="tabs1">
    <ul class="tablist">
      <script type="text/javascript">
		<!--
		writeComponentTabs.call(this);
		//-->
      </script>
	  </ul>
</div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__SPI.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SPI<div class="ingroups"><a class="el" href="group__groupDrivers.html">Drivers</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpi__spi__conf.html">pi_spi_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpi__spi__conf__t.html">pi_spi_conf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI master configuration structure.  <a href="structpi__spi__conf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga48d4c1ebb13889b0d00e1c0a3cd9bdb8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga48d4c1ebb13889b0d00e1c0a3cd9bdb8">pi_spi_wordsize_e</a> <tr class="memdesc:ga48d4c1ebb13889b0d00e1c0a3cd9bdb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wordsize of the SPI bitstream elements.  <a href="group__SPI.html#ga48d4c1ebb13889b0d00e1c0a3cd9bdb8">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga48d4c1ebb13889b0d00e1c0a3cd9bdb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga861805aa719ca5f5282386b3c696d4d8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga861805aa719ca5f5282386b3c696d4d8">pi_spi_ioctl_e</a> <tr class="memdesc:ga861805aa719ca5f5282386b3c696d4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible parameters which can be set through the pi_spi_control API function.  <a href="group__SPI.html#ga861805aa719ca5f5282386b3c696d4d8">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga861805aa719ca5f5282386b3c696d4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8604491c7366194ca3cac6a733eae8a6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga8604491c7366194ca3cac6a733eae8a6">pi_spi_flags_e</a> <tr class="memdesc:ga8604491c7366194ca3cac6a733eae8a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies additional behaviors for transfers.  <a href="group__SPI.html#ga8604491c7366194ca3cac6a733eae8a6">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga8604491c7366194ca3cac6a733eae8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf5ea92804fb719034f37b2bfa65a2700"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#gaf5ea92804fb719034f37b2bfa65a2700">pi_spi_conf_init</a> (struct <a class="el" href="structpi__spi__conf.html">pi_spi_conf</a> *conf)</td></tr>
<tr class="memdesc:gaf5ea92804fb719034f37b2bfa65a2700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an SPI master configuration with default values.  <a href="#gaf5ea92804fb719034f37b2bfa65a2700">More...</a><br /></td></tr>
<tr class="separator:gaf5ea92804fb719034f37b2bfa65a2700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b6a32f6c4f4659e0762c42d0ffa52ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga0b6a32f6c4f4659e0762c42d0ffa52ba">pi_spi_open</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>)</td></tr>
<tr class="memdesc:ga0b6a32f6c4f4659e0762c42d0ffa52ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open an SPI device.  <a href="#ga0b6a32f6c4f4659e0762c42d0ffa52ba">More...</a><br /></td></tr>
<tr class="separator:ga0b6a32f6c4f4659e0762c42d0ffa52ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41fbf9d4b6a25b57b938c85b492eaaa5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga41fbf9d4b6a25b57b938c85b492eaaa5">pi_spi_close</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>)</td></tr>
<tr class="memdesc:ga41fbf9d4b6a25b57b938c85b492eaaa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an opened SPI device.  <a href="#ga41fbf9d4b6a25b57b938c85b492eaaa5">More...</a><br /></td></tr>
<tr class="separator:ga41fbf9d4b6a25b57b938c85b492eaaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85e6e437d8ad7f6813d0d149d24432bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga85e6e437d8ad7f6813d0d149d24432bf">pi_spi_ioctl</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, uint32_t cmd, void *arg)</td></tr>
<tr class="memdesc:ga85e6e437d8ad7f6813d0d149d24432bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically change the device configuration.  <a href="#ga85e6e437d8ad7f6813d0d149d24432bf">More...</a><br /></td></tr>
<tr class="separator:ga85e6e437d8ad7f6813d0d149d24432bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa6023c8ab9111f0a8af8fc2b31a123b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#gafa6023c8ab9111f0a8af8fc2b31a123b">pi_spi_send</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, void *data, size_t len, <a class="el" href="group__SPI.html#ga8604491c7366194ca3cac6a733eae8a6">pi_spi_flags_e</a> flag)</td></tr>
<tr class="memdesc:gafa6023c8ab9111f0a8af8fc2b31a123b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a write copy to the SPI (from Chip to SPI device).  <a href="#gafa6023c8ab9111f0a8af8fc2b31a123b">More...</a><br /></td></tr>
<tr class="separator:gafa6023c8ab9111f0a8af8fc2b31a123b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75b7f9d72e5d56aaf925c43b4e5620a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga75b7f9d72e5d56aaf925c43b4e5620a2">pi_spi_receive</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, void *data, size_t len, <a class="el" href="group__SPI.html#ga8604491c7366194ca3cac6a733eae8a6">pi_spi_flags_e</a> flag)</td></tr>
<tr class="memdesc:ga75b7f9d72e5d56aaf925c43b4e5620a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a read copy to the SPI (from Chip to SPI device).  <a href="#ga75b7f9d72e5d56aaf925c43b4e5620a2">More...</a><br /></td></tr>
<tr class="separator:ga75b7f9d72e5d56aaf925c43b4e5620a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga172abdccab73c08b97ddbb1eed1835bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga172abdccab73c08b97ddbb1eed1835bf">pi_spi_transfer</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, void *tx_data, void *rx_data, size_t len, <a class="el" href="group__SPI.html#ga8604491c7366194ca3cac6a733eae8a6">pi_spi_flags_e</a> flag)</td></tr>
<tr class="memdesc:ga172abdccab73c08b97ddbb1eed1835bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a read and write copy to the SPI (using full duplex mode).  <a href="#ga172abdccab73c08b97ddbb1eed1835bf">More...</a><br /></td></tr>
<tr class="separator:ga172abdccab73c08b97ddbb1eed1835bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac007e58e949194919284865bf62317e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#gac007e58e949194919284865bf62317e6">pi_spi_send_async</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, void *data, size_t len, <a class="el" href="group__SPI.html#ga8604491c7366194ca3cac6a733eae8a6">pi_spi_flags_e</a> flag, pi_task_t *task)</td></tr>
<tr class="memdesc:gac007e58e949194919284865bf62317e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue an asynchronous write copy to the SPI (from Chip to SPI device).  <a href="#gac007e58e949194919284865bf62317e6">More...</a><br /></td></tr>
<tr class="separator:gac007e58e949194919284865bf62317e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad58836151abb38d7cc9a1970d1c4b670"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#gad58836151abb38d7cc9a1970d1c4b670">pi_spi_receive_async</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, void *data, size_t len, <a class="el" href="group__SPI.html#ga8604491c7366194ca3cac6a733eae8a6">pi_spi_flags_e</a> flag, pi_task_t *task)</td></tr>
<tr class="memdesc:gad58836151abb38d7cc9a1970d1c4b670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue an asynchronous read copy to the SPI (from Chip to SPI device).  <a href="#gad58836151abb38d7cc9a1970d1c4b670">More...</a><br /></td></tr>
<tr class="separator:gad58836151abb38d7cc9a1970d1c4b670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74676ccf359cab3322c2bfb6fd31531a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga74676ccf359cab3322c2bfb6fd31531a">pi_spi_transfer_async</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, void *tx_data, void *rx_data, size_t len, <a class="el" href="group__SPI.html#ga8604491c7366194ca3cac6a733eae8a6">pi_spi_flags_e</a> flag, pi_task_t *task)</td></tr>
<tr class="memdesc:ga74676ccf359cab3322c2bfb6fd31531a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue an asynchronous read and write copy to the SPI (using full duplex mode).  <a href="#ga74676ccf359cab3322c2bfb6fd31531a">More...</a><br /></td></tr>
<tr class="separator:ga74676ccf359cab3322c2bfb6fd31531a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>The SPIM driver provides support for transferring data between an external SPIM device and the chip running this driver. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga8604491c7366194ca3cac6a733eae8a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8604491c7366194ca3cac6a733eae8a6">&#9670;&nbsp;</a></span>pi_spi_flags_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__SPI.html#ga8604491c7366194ca3cac6a733eae8a6">pi_spi_flags_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This flags can be given when transfering data. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga8604491c7366194ca3cac6a733eae8a6a6aa1de55239ef6f58e1fe390ca42b466"></a>PI_SPI_CS_AUTO&#160;</td><td class="fielddoc"><p>Handles the chip select automatically. It is set low just before the transfer is started and set back high when the transfer is finished. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8604491c7366194ca3cac6a733eae8a6a5b75e87fb8774702541823a810b97620"></a>PI_SPI_CS_KEEP&#160;</td><td class="fielddoc"><p>Handle the chip select manually. It is set low just before the transfer is started and is kept low until the next transfer. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8604491c7366194ca3cac6a733eae8a6a204651bf44124c642676742cbd6baa5c"></a>PI_SPI_CS_NONE&#160;</td><td class="fielddoc"><p>Don't do anything with the chip select. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8604491c7366194ca3cac6a733eae8a6a9181ce8c8dc525265b4d0ef7877e65c8"></a>PI_SPI_LINES_SINGLE&#160;</td><td class="fielddoc"><p>Use a single MISO line. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8604491c7366194ca3cac6a733eae8a6a0e9def67822c06e082e887d1cc53e84f"></a>PI_SPI_LINES_QUAD&#160;</td><td class="fielddoc"><p>Use quad MISO lines. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8604491c7366194ca3cac6a733eae8a6a7eb99dc9e3d3534e86fa309ec3d23e7e"></a>PI_SPI_LINES_OCTAL&#160;</td><td class="fielddoc"><p>Use octal MISO lines. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8604491c7366194ca3cac6a733eae8a6a9ab39d8bb37172cabc18050bc924c12b"></a>PI_SPI_APPEND_UCODE&#160;</td><td class="fielddoc"><p>Append micro-append to transfer. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga861805aa719ca5f5282386b3c696d4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga861805aa719ca5f5282386b3c696d4d8">&#9670;&nbsp;</a></span>pi_spi_ioctl_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__SPI.html#ga861805aa719ca5f5282386b3c696d4d8">pi_spi_ioctl_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is used to reconfigure dynamically some of the parameters of an opened device. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga861805aa719ca5f5282386b3c696d4d8ab16129744188bc7cbccf7d5265efef45"></a>PI_SPI_CTRL_CPOL0&#160;</td><td class="fielddoc"><p>Set the clock polarity to 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga861805aa719ca5f5282386b3c696d4d8a395fe20fb2cd21868cde3b26e8daaf78"></a>PI_SPI_CTRL_CPOL1&#160;</td><td class="fielddoc"><p>Set the clock polarity to 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga861805aa719ca5f5282386b3c696d4d8a63364ff367c34d85e821f3cb1ff98860"></a>PI_SPI_CTRL_CPHA0&#160;</td><td class="fielddoc"><p>Set the clock phase to 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga861805aa719ca5f5282386b3c696d4d8a614fd22e33507824e3cb92dd2cce8473"></a>PI_SPI_CTRL_CPHA1&#160;</td><td class="fielddoc"><p>Set the clock phase to 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga861805aa719ca5f5282386b3c696d4d8a2423f78eb1492bf5d3b9be5919bcde5e"></a>PI_SPI_CTRL_WORDSIZE_8&#160;</td><td class="fielddoc"><p>Set the wordsize to 8 bits. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga861805aa719ca5f5282386b3c696d4d8a124a51e17126f8566fdf0872795d9b36"></a>PI_SPI_CTRL_WORDSIZE_32&#160;</td><td class="fielddoc"><p>Set the wordsize to 32 bits. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga861805aa719ca5f5282386b3c696d4d8a042adfb2426503bae8906ebfa3cc138d"></a>PI_SPI_CTRL_BIG_ENDIAN&#160;</td><td class="fielddoc"><p>Handle the elements in memory in a big-endian way. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga861805aa719ca5f5282386b3c696d4d8a4b59563041c9090e0a194ec51c3c6689"></a>PI_SPI_CTRL_LITTLE_ENDIAN&#160;</td><td class="fielddoc"><p>Handle the elements in memory in a little-endian way. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga861805aa719ca5f5282386b3c696d4d8a62a7d35edbbb47ae35c005dd66be1c07"></a>PI_SPI_CTRL_SET_MAX_BAUDRATE&#160;</td><td class="fielddoc"><p>Change maximum baudrate. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga48d4c1ebb13889b0d00e1c0a3cd9bdb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48d4c1ebb13889b0d00e1c0a3cd9bdb8">&#9670;&nbsp;</a></span>pi_spi_wordsize_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__SPI.html#ga48d4c1ebb13889b0d00e1c0a3cd9bdb8">pi_spi_wordsize_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is used to know how the endianness must be applied. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga48d4c1ebb13889b0d00e1c0a3cd9bdb8a88588953b70e0c066e87e8f9676c5c0b"></a>PI_SPI_WORDSIZE_8&#160;</td><td class="fielddoc"><p>Each element is 8 bits. Thus the endianness has no effect. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga48d4c1ebb13889b0d00e1c0a3cd9bdb8a444b22fc26a40f0cb9b93ddebe588ea0"></a>PI_SPI_WORDSIZE_32&#160;</td><td class="fielddoc"><p>Each element is 32 bits. The way each element is stored in memory can then be specified with the endianness. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga41fbf9d4b6a25b57b938c85b492eaaa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41fbf9d4b6a25b57b938c85b492eaaa5">&#9670;&nbsp;</a></span>pi_spi_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_spi_close </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to close an opened SPI device once it is not needed anymore, in order to free all allocated resources. Once this function is called, the device is not accessible anymore and must be opened again before being used. The caller is blocked until the operation is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="spi__internal_8c.html#a95f6a51e9060dfd79bc34dced6a1c4ac">__pi_spi_close()</a>, and <a class="el" href="pmsis__task_8h.html#aaaf2cce2f1212272329e5190db605711">restore_irq()</a>.</p>

</div>
</div>
<a id="gaf5ea92804fb719034f37b2bfa65a2700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5ea92804fb719034f37b2bfa65a2700">&#9670;&nbsp;</a></span>pi_spi_conf_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_spi_conf_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpi__spi__conf.html">pi_spi_conf</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to get default values for all parameters before setting some of them. The structure containing the configuration must be kept alive until the SPI device is opened.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>A pointer to the SPI master configuration. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="structpi__spi__conf.html#ab4cbab7850c665c3ccdb9f50b7753e66">pi_spi_conf::big_endian</a>, <a class="el" href="structpi__spi__conf.html#a2d1693a2b90862979c323dafa7415d64">pi_spi_conf::cs</a>, <a class="el" href="structpi__spi__conf.html#a29d5fcd35aadb84d0923d583584bcb54">pi_spi_conf::itf</a>, <a class="el" href="structpi__spi__conf.html#a111c8c5c5ccac061b9db71a5efea70f3">pi_spi_conf::max_baudrate</a>, <a class="el" href="structpi__spi__conf.html#a0e41f2dcd53fffcb1d8d2c5b22f3b26a">pi_spi_conf::phase</a>, <a class="el" href="group__SPI.html#gga48d4c1ebb13889b0d00e1c0a3cd9bdb8a88588953b70e0c066e87e8f9676c5c0b">PI_SPI_WORDSIZE_8</a>, <a class="el" href="structpi__spi__conf.html#a475059ef7195317e24a38ffd3b9c78e4">pi_spi_conf::polarity</a>, and <a class="el" href="structpi__spi__conf.html#ad8a3934dd0f15ff6f7d920dd0853dad4">pi_spi_conf::wordsize</a>.</p>

<p class="reference">Referenced by <a class="el" href="ili9341_8c.html#a408ecba8217c2394625c058107c8b4c7">__ili_open()</a>, and <a class="el" href="nina__w10_8c.html#a101845438b67a5866517efa1b5839441">__nina_w10_open()</a>.</p>

</div>
</div>
<a id="ga85e6e437d8ad7f6813d0d149d24432bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85e6e437d8ad7f6813d0d149d24432bf">&#9670;&nbsp;</a></span>pi_spi_ioctl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_spi_ioctl </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to change part of the device configuration after it has been opened.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
    <tr><td class="paramname">cmd</td><td>The command which specifies which parameters of the driver to modify and for some of them also their values. The command must be one of those defined in pi_spi_ioctl_e. </td></tr>
    <tr><td class="paramname">arg</td><td>An additional value which is required for some parameters when they are set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0b6a32f6c4f4659e0762c42d0ffa52ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b6a32f6c4f4659e0762c42d0ffa52ba">&#9670;&nbsp;</a></span>pi_spi_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_spi_open </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function must be called before the SPI device can be used. It will do all the needed configuration to make it usable and initialize the handle used to refer to this opened device when calling other functions. The caller is blocked until the operation is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the device structure of the device to open. This structure is allocated by the caller and must be kept alive until the device is closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

<p class="reference">References <a class="el" href="spi__internal_8c.html#a1ed18e06e73b8f716c913cb634972a5a">__pi_spi_open()</a>, <a class="el" href="pmsis__task_8h.html#aaaf2cce2f1212272329e5190db605711">restore_irq()</a>, and <a class="el" href="GAP9_2periph_2i2c__periph_8h.html#a9d5ec73a70e8d3f1e4e13411f24f4135">status</a>.</p>

<p class="reference">Referenced by <a class="el" href="ili9341_8c.html#a408ecba8217c2394625c058107c8b4c7">__ili_open()</a>, and <a class="el" href="nina__w10_8c.html#a101845438b67a5866517efa1b5839441">__nina_w10_open()</a>.</p>

</div>
</div>
<a id="ga75b7f9d72e5d56aaf925c43b4e5620a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75b7f9d72e5d56aaf925c43b4e5620a2">&#9670;&nbsp;</a></span>pi_spi_receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_spi_receive </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SPI.html#ga8604491c7366194ca3cac6a733eae8a6">pi_spi_flags_e</a>&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be used to receive data from the SPI device. The copy will make a synchronous transfer between the SPI and one of the chip memory. This is by default using classic SPI transfer with MOSI and MISO lines, but other kind of transfers like quad SPI can be used by specifying additional flags. Due to hardware constraints, the address of the buffer must be aligned on 4 bytes and the size must be a multiple of 4. The caller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
    <tr><td class="paramname">data</td><td>The address in the chip where the received data must be written. </td></tr>
    <tr><td class="paramname">len</td><td>The size in bits of the copy. </td></tr>
    <tr><td class="paramname">flag</td><td>Additional behaviors for the transfer can be specified using this flag. Can be 0 to use the default flag, which is using PI_SPI_CS_AUTO and PI_SPI_LINES_SINGLE. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="spi_8c.html#a5c8ef3c24dad2c469a42784a9a39403b">DEBUG_PRINTF</a>, <a class="el" href="group__SPI.html#gad58836151abb38d7cc9a1970d1c4b670">pi_spi_receive_async()</a>, <a class="el" href="group__Task.html#ga872ea1d492fe1307123c8d1ac783c792">pi_task_block()</a>, and <a class="el" href="group__Task.html#ga3b4463327b724512ace0257cb0951457">pi_task_wait_on()</a>.</p>

</div>
</div>
<a id="gad58836151abb38d7cc9a1970d1c4b670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad58836151abb38d7cc9a1970d1c4b670">&#9670;&nbsp;</a></span>pi_spi_receive_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_spi_receive_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SPI.html#ga8604491c7366194ca3cac6a733eae8a6">pi_spi_flags_e</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be used to receive data from the SPI device. The copy will make an asynchronous transfer between the SPI and one of the chip memory. This is by default using classic SPI transfer with MOSI and MISO lines, but other kind of transfers like quad SPI can be used by specifying additional flags. Due to hardware constraints, the address of the buffer must be aligned on 4 bytes and the size must be a multiple of 4. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
    <tr><td class="paramname">data</td><td>The address in the chip where the received data must be written. </td></tr>
    <tr><td class="paramname">len</td><td>The size in bits of the copy. </td></tr>
    <tr><td class="paramname">flag</td><td>Additional behaviors for the transfer can be specified using this flag. Can be 0 to use the default flag, which is using PI_SPI_CS_AUTO and PI_SPI_LINES_SINGLE. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details.details.details. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="spi__internal_8c.html#a3059b6146af6d49b57ce406e435d42d9">__pi_spi_receive_async()</a>.</p>

<p class="reference">Referenced by <a class="el" href="nina__w10_8c.html#a2afb3fcbf972fa852457c14b16433afd">__nina_w10_get_response()</a>, and <a class="el" href="group__SPI.html#ga75b7f9d72e5d56aaf925c43b4e5620a2">pi_spi_receive()</a>.</p>

</div>
</div>
<a id="gafa6023c8ab9111f0a8af8fc2b31a123b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa6023c8ab9111f0a8af8fc2b31a123b">&#9670;&nbsp;</a></span>pi_spi_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_spi_send </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SPI.html#ga8604491c7366194ca3cac6a733eae8a6">pi_spi_flags_e</a>&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be used to send data to the SPI device. The copy will make a synchronous transfer between the SPI and one of the chip memory. This is by default using classic SPI transfer with MOSI and MISO lines, but other kind of transfers like quad SPI can be used by specifying additional flags. Due to hardware constraints, the address of the buffer must be aligned on 4 bytes and the size must be a multiple of 4. The caller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
    <tr><td class="paramname">data</td><td>The address in the chip where the data to be sent must be read. </td></tr>
    <tr><td class="paramname">len</td><td>The size in bits of the copy. </td></tr>
    <tr><td class="paramname">flag</td><td>Additional behaviors for the transfer can be specified using this flag. Can be 0 to use the default flag, which is using PI_SPI_CS_AUTO and PI_SPI_LINES_SINGLE. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="spi_8c.html#a5c8ef3c24dad2c469a42784a9a39403b">DEBUG_PRINTF</a>, <a class="el" href="group__SPI.html#gac007e58e949194919284865bf62317e6">pi_spi_send_async()</a>, <a class="el" href="group__Task.html#ga872ea1d492fe1307123c8d1ac783c792">pi_task_block()</a>, and <a class="el" href="group__Task.html#ga3b4463327b724512ace0257cb0951457">pi_task_wait_on()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ili9341_8c.html#a68330f78f9d78f15ca3228012393d1c7">__ili_write_8()</a>.</p>

</div>
</div>
<a id="gac007e58e949194919284865bf62317e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac007e58e949194919284865bf62317e6">&#9670;&nbsp;</a></span>pi_spi_send_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_spi_send_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SPI.html#ga8604491c7366194ca3cac6a733eae8a6">pi_spi_flags_e</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be used to send data to the SPI device. The copy will make an asynchronous transfer between the SPI and one of the chip memory. This is by default using classic SPI transfer with MOSI and MISO lines, but other kind of transfers like quad SPI can be used by specifying additional flags. Due to hardware constraints, the address of the buffer must be aligned on 4 bytes and the size must be a multiple of 4. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
    <tr><td class="paramname">data</td><td>The address in the chip where the data to be sent must be read. </td></tr>
    <tr><td class="paramname">len</td><td>The size in bits of the copy. </td></tr>
    <tr><td class="paramname">flag</td><td>Additional behaviors for the transfer can be specified using this flag. Can be 0 to use the default flag, which is using PI_SPI_CS_AUTO and PI_SPI_LINES_SINGLE. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details.details. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="spi__internal_8c.html#a15d751f285198e2f386efdd00247d3ca">__pi_spi_send_async()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ili9341_8c.html#a690027705cd7124c2b226885d08db616">__ili9341_write_buffer_iter()</a>, <a class="el" href="nina__w10_8c.html#a1f1a9c261ad98aaa846395363e459a15">__nina_w10_send_command()</a>, and <a class="el" href="group__SPI.html#gafa6023c8ab9111f0a8af8fc2b31a123b">pi_spi_send()</a>.</p>

</div>
</div>
<a id="ga172abdccab73c08b97ddbb1eed1835bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga172abdccab73c08b97ddbb1eed1835bf">&#9670;&nbsp;</a></span>pi_spi_transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_spi_transfer </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tx_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rx_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SPI.html#ga8604491c7366194ca3cac6a733eae8a6">pi_spi_flags_e</a>&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be used to send and receive data with the SPI device using full duplex mode. The copy will make a synchronous transfer between the SPI and one of the chip memory. This is using classic SPI transfer with MOSI and MISO lines. Due to hardware constraints, the address of the buffer must be aligned on 4 bytes and the size must be a multiple of 4. The caller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
    <tr><td class="paramname">tx_data</td><td>The address in the chip where the data to be sent must be read. </td></tr>
    <tr><td class="paramname">rx_data</td><td>The address in the chip where the received data must be written. </td></tr>
    <tr><td class="paramname">len</td><td>The size in bits of the copy. </td></tr>
    <tr><td class="paramname">flag</td><td>Additional behaviors for the transfer can be specified using this flag. Can be 0 to use the default flag, which is using PI_SPI_CS_AUTO and PI_SPI_LINES_SINGLE. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="spi_8c.html#a5c8ef3c24dad2c469a42784a9a39403b">DEBUG_PRINTF</a>, <a class="el" href="group__SPI.html#ga74676ccf359cab3322c2bfb6fd31531a">pi_spi_transfer_async()</a>, <a class="el" href="group__Task.html#ga872ea1d492fe1307123c8d1ac783c792">pi_task_block()</a>, and <a class="el" href="group__Task.html#ga3b4463327b724512ace0257cb0951457">pi_task_wait_on()</a>.</p>

</div>
</div>
<a id="ga74676ccf359cab3322c2bfb6fd31531a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74676ccf359cab3322c2bfb6fd31531a">&#9670;&nbsp;</a></span>pi_spi_transfer_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_spi_transfer_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tx_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rx_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SPI.html#ga8604491c7366194ca3cac6a733eae8a6">pi_spi_flags_e</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be used to send and receive data with the SPI device using full duplex flag. The copy will make an asynchronous transfer between the SPI and one of the chip memory. This is using classic SPI transfer with MOSI and MISO lines. Due to hardware constraints, the address of the buffer must be aligned on 4 bytes and the size must be a multiple of 4. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
    <tr><td class="paramname">tx_data</td><td>The address in the chip where the data to be sent must be read. </td></tr>
    <tr><td class="paramname">rx_data</td><td>The address in the chip where the received data must be written. </td></tr>
    <tr><td class="paramname">len</td><td>The size in bits of the copy. </td></tr>
    <tr><td class="paramname">flag</td><td>Additional behaviors for the transfer can be specified using this flag. Can be 0 to use the default flag, which is using PI_SPI_CS_AUTO and PI_SPI_LINES_SINGLE. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details.details.details. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="spi__internal_8c.html#aead5a69fa0e87314e2142d764bd74211">__pi_spi_xfer_async()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__SPI.html#ga172abdccab73c08b97ddbb1eed1835bf">pi_spi_transfer()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jan 24 2020 12:47:54 for  by GreenWaves Technologies
	<!--
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 
	-->
	</li>
  </ul>
</div>
</body>
</html>
