<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Flash</title>
<title>Flash</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="pulp.css" rel="stylesheet" type="text/css" />
<link href="gap.css" rel="stylesheet" type="text/css" />
<link href="images.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="printComponentTabs.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="titlerow">
  <td id="projectlogo"><img alt="Logo" src="gap-logo-55.png" /></td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">FreeRTOS port on GAP8/RISC-V</div>
    </td>
  <td id="extralogo"><img alt="GreenWaves" src="greenwaves-logo-55.png" /></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="CMSISnav" class="tabs1">
    <ul class="tablist">
      <script type="text/javascript">
		<!--
		writeComponentTabs.call(this);
		//-->
      </script>
	  </ul>
</div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__Flash.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Content</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Flash</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Content</h2></td></tr>
<tr class="memitem:group__Hyperflash"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hyperflash.html">Hyperflash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpi__flash__conf.html">pi_flash_conf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flash configuration structure.  <a href="structpi__flash__conf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpi__flash__info.html">pi_flash_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter for FLASH_IOCTL_INFO command.  <a href="structpi__flash__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga04ded386c570034278090682a259d17f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Flash.html#ga04ded386c570034278090682a259d17f">pi_flash_ioctl_e</a> <tr class="memdesc:ga04ded386c570034278090682a259d17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command ID for pi_flash_ioctl.  <a href="group__Flash.html#ga04ded386c570034278090682a259d17f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga04ded386c570034278090682a259d17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga358f51250413be26066a2cfff3c7bd1f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Flash.html#ga358f51250413be26066a2cfff3c7bd1f">pi_flash_open</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>)</td></tr>
<tr class="memdesc:ga358f51250413be26066a2cfff3c7bd1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a flash device.  <a href="#ga358f51250413be26066a2cfff3c7bd1f">More...</a><br /></td></tr>
<tr class="separator:ga358f51250413be26066a2cfff3c7bd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5e245943c0d93ff4d3465a81b6d6d9e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Flash.html#gaa5e245943c0d93ff4d3465a81b6d6d9e">pi_flash_close</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>)</td></tr>
<tr class="memdesc:gaa5e245943c0d93ff4d3465a81b6d6d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an opened flash device.  <a href="#gaa5e245943c0d93ff4d3465a81b6d6d9e">More...</a><br /></td></tr>
<tr class="separator:gaa5e245943c0d93ff4d3465a81b6d6d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2473a95364ace1fa4babfa0b2807b753"><td class="memItemLeft" align="right" valign="top">static int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Flash.html#ga2473a95364ace1fa4babfa0b2807b753">pi_flash_ioctl</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, uint32_t cmd, void *arg)</td></tr>
<tr class="memdesc:ga2473a95364ace1fa4babfa0b2807b753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control device.  <a href="#ga2473a95364ace1fa4babfa0b2807b753">More...</a><br /></td></tr>
<tr class="separator:ga2473a95364ace1fa4babfa0b2807b753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a2b9fbb598048f89be57cb9ce74f690"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Flash.html#ga5a2b9fbb598048f89be57cb9ce74f690">pi_flash_reg_set</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, uint32_t reg_addr, uint8_t *value)</td></tr>
<tr class="memdesc:ga5a2b9fbb598048f89be57cb9ce74f690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set flash register.  <a href="#ga5a2b9fbb598048f89be57cb9ce74f690">More...</a><br /></td></tr>
<tr class="separator:ga5a2b9fbb598048f89be57cb9ce74f690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b6932cbceeb974ed025747e8af78237"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Flash.html#ga0b6932cbceeb974ed025747e8af78237">pi_flash_reg_get</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, uint32_t reg_addr, uint8_t *value)</td></tr>
<tr class="memdesc:ga0b6932cbceeb974ed025747e8af78237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get flash register.  <a href="#ga0b6932cbceeb974ed025747e8af78237">More...</a><br /></td></tr>
<tr class="separator:ga0b6932cbceeb974ed025747e8af78237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89938c2184ce3e9c2aa02a5b1a9517cc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Flash.html#ga89938c2184ce3e9c2aa02a5b1a9517cc">pi_flash_reg_set_async</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, uint32_t reg_addr, uint8_t *value, pi_task_t *task)</td></tr>
<tr class="memdesc:ga89938c2184ce3e9c2aa02a5b1a9517cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set flash register asynchronously.  <a href="#ga89938c2184ce3e9c2aa02a5b1a9517cc">More...</a><br /></td></tr>
<tr class="separator:ga89938c2184ce3e9c2aa02a5b1a9517cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b55ad4742567275fe98ec896e03dc73"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Flash.html#ga5b55ad4742567275fe98ec896e03dc73">pi_flash_reg_get_async</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, uint32_t reg_addr, uint8_t *value, pi_task_t *task)</td></tr>
<tr class="memdesc:ga5b55ad4742567275fe98ec896e03dc73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get flash register asynchronously.  <a href="#ga5b55ad4742567275fe98ec896e03dc73">More...</a><br /></td></tr>
<tr class="separator:ga5b55ad4742567275fe98ec896e03dc73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b75543c61bbfa36c1665c8e584bd30a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Flash.html#ga5b75543c61bbfa36c1665c8e584bd30a">pi_flash_read</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, uint32_t pi_flash_addr, void *data, uint32_t size)</td></tr>
<tr class="memdesc:ga5b75543c61bbfa36c1665c8e584bd30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a read copy to the flash (from flash to processor).  <a href="#ga5b75543c61bbfa36c1665c8e584bd30a">More...</a><br /></td></tr>
<tr class="separator:ga5b75543c61bbfa36c1665c8e584bd30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07fc48eca783c250239bcc79ebb370b0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Flash.html#ga07fc48eca783c250239bcc79ebb370b0">pi_flash_program</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, uint32_t pi_flash_addr, const void *data, uint32_t size)</td></tr>
<tr class="memdesc:ga07fc48eca783c250239bcc79ebb370b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a write copy to the flash (from processor to flash).  <a href="#ga07fc48eca783c250239bcc79ebb370b0">More...</a><br /></td></tr>
<tr class="separator:ga07fc48eca783c250239bcc79ebb370b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga679d61c9ce5d529fe5c661316370e1fb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Flash.html#ga679d61c9ce5d529fe5c661316370e1fb">pi_flash_erase_chip</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>)</td></tr>
<tr class="memdesc:ga679d61c9ce5d529fe5c661316370e1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the whole flash.  <a href="#ga679d61c9ce5d529fe5c661316370e1fb">More...</a><br /></td></tr>
<tr class="separator:ga679d61c9ce5d529fe5c661316370e1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7092edd4979dd161b9ff7c1f38f817ce"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Flash.html#ga7092edd4979dd161b9ff7c1f38f817ce">pi_flash_erase_sector</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, uint32_t pi_flash_addr)</td></tr>
<tr class="memdesc:ga7092edd4979dd161b9ff7c1f38f817ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a sector.  <a href="#ga7092edd4979dd161b9ff7c1f38f817ce">More...</a><br /></td></tr>
<tr class="separator:ga7092edd4979dd161b9ff7c1f38f817ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga260e3c5cb3fe2da96767aab020b48495"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Flash.html#ga260e3c5cb3fe2da96767aab020b48495">pi_flash_erase</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, uint32_t pi_flash_addr, int size)</td></tr>
<tr class="memdesc:ga260e3c5cb3fe2da96767aab020b48495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an area in the flash.  <a href="#ga260e3c5cb3fe2da96767aab020b48495">More...</a><br /></td></tr>
<tr class="separator:ga260e3c5cb3fe2da96767aab020b48495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7adc6e516daa8d426bfd383dc9ecc1d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Flash.html#gab7adc6e516daa8d426bfd383dc9ecc1d">pi_flash_read_async</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, uint32_t pi_flash_addr, void *data, uint32_t size, pi_task_t *task)</td></tr>
<tr class="memdesc:gab7adc6e516daa8d426bfd383dc9ecc1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue an asynchronous read copy to the flash (from flash to processor).  <a href="#gab7adc6e516daa8d426bfd383dc9ecc1d">More...</a><br /></td></tr>
<tr class="separator:gab7adc6e516daa8d426bfd383dc9ecc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb2d100e16117ee76c3a0773b5182c6e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Flash.html#gabb2d100e16117ee76c3a0773b5182c6e">pi_flash_program_async</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, uint32_t pi_flash_addr, const void *data, uint32_t size, pi_task_t *task)</td></tr>
<tr class="memdesc:gabb2d100e16117ee76c3a0773b5182c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue an asynchronous write copy to the flash (from processor to flash).  <a href="#gabb2d100e16117ee76c3a0773b5182c6e">More...</a><br /></td></tr>
<tr class="separator:gabb2d100e16117ee76c3a0773b5182c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d7a66a5d3284c5811e157b23606346f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Flash.html#ga9d7a66a5d3284c5811e157b23606346f">pi_flash_erase_chip_async</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, pi_task_t *task)</td></tr>
<tr class="memdesc:ga9d7a66a5d3284c5811e157b23606346f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the whole flash asynchronously.  <a href="#ga9d7a66a5d3284c5811e157b23606346f">More...</a><br /></td></tr>
<tr class="separator:ga9d7a66a5d3284c5811e157b23606346f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34cc29c30281c1a8d101bb90428ae7fc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Flash.html#ga34cc29c30281c1a8d101bb90428ae7fc">pi_flash_erase_sector_async</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, uint32_t pi_flash_addr, pi_task_t *task)</td></tr>
<tr class="memdesc:ga34cc29c30281c1a8d101bb90428ae7fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a sector asynchronously.  <a href="#ga34cc29c30281c1a8d101bb90428ae7fc">More...</a><br /></td></tr>
<tr class="separator:ga34cc29c30281c1a8d101bb90428ae7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19d5de194f4b7f04728037fbcc300b32"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Flash.html#ga19d5de194f4b7f04728037fbcc300b32">pi_flash_erase_async</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, uint32_t pi_flash_addr, int size, pi_task_t *task)</td></tr>
<tr class="memdesc:ga19d5de194f4b7f04728037fbcc300b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an area in the flash asynchronously.  <a href="#ga19d5de194f4b7f04728037fbcc300b32">More...</a><br /></td></tr>
<tr class="separator:ga19d5de194f4b7f04728037fbcc300b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>The flash driver provides support for transferring data between an external flash chip (e.g. Hyperflash or SPI flash) and the processor running this driver. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga04ded386c570034278090682a259d17f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04ded386c570034278090682a259d17f">&#9670;&nbsp;</a></span>pi_flash_ioctl_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Flash.html#ga04ded386c570034278090682a259d17f">pi_flash_ioctl_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga04ded386c570034278090682a259d17fa82b5ecf45000ce7adc005dafc6e67506"></a>PI_FLASH_IOCTL_INFO&#160;</td><td class="fielddoc"><p>Command for getting flash information. The argument must be a pointer to a variable of type struct <a class="el" href="structpi__flash__info.html" title="Parameter for FLASH_IOCTL_INFO command. ">pi_flash_info</a> so that the call is returning information there. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa5e245943c0d93ff4d3465a81b6d6d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5e245943c0d93ff4d3465a81b6d6d9e">&#9670;&nbsp;</a></span>pi_flash_close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_flash_close </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function can be called to close an opened flash device once it is not needed anymore, in order to free all allocated resources. Once this function is called, the device is not accessible anymore and must be opened again before being used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device structure of the device to close. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga260e3c5cb3fe2da96767aab020b48495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga260e3c5cb3fe2da96767aab020b48495">&#9670;&nbsp;</a></span>pi_flash_erase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_flash_erase </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_flash_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will erase the specified area. The duration of this operation may be long and may be retrieved from the datasheet. If the flash only supports sector erasing, all the sectors partially or entirely covered by this aread will be erased. The caller is blocked until the operation is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the flash chip on which to do the operation. </td></tr>
    <tr><td class="paramname">pi_flash_addr</td><td>The address of the area to be erased. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the area to be erased. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga19d5de194f4b7f04728037fbcc300b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19d5de194f4b7f04728037fbcc300b32">&#9670;&nbsp;</a></span>pi_flash_erase_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_flash_erase_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_flash_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will erase the specified area. The duration of this operation may be long and may be retrieved from the datasheet. If the flash only supports sector erasing, all the sectors partially or entirely covered by this aread will be erased. A task must be specified in order to specify how the caller should be notified when the transfer is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the flash chip on which to do the operation. </td></tr>
    <tr><td class="paramname">pi_flash_addr</td><td>The address of the area to be erased. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the area to be erased. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga679d61c9ce5d529fe5c661316370e1fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga679d61c9ce5d529fe5c661316370e1fb">&#9670;&nbsp;</a></span>pi_flash_erase_chip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_flash_erase_chip </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will erase the entire flash. The duration of this operation may be long and may be retrieved from the datasheet. The caller is blocked until the operation is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the flash chip on which to do the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d7a66a5d3284c5811e157b23606346f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d7a66a5d3284c5811e157b23606346f">&#9670;&nbsp;</a></span>pi_flash_erase_chip_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_flash_erase_chip_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will erase the entire flash. The duration of this operation may be long and may be retrieved from the datasheet. A task must be specified in order to specify how the caller should be notified when the transfer is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the flash chip on which to do the operation. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7092edd4979dd161b9ff7c1f38f817ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7092edd4979dd161b9ff7c1f38f817ce">&#9670;&nbsp;</a></span>pi_flash_erase_sector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_flash_erase_sector </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_flash_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will erase one sector. The duration of this operation may be long and may be retrieved from the datasheet. The caller is blocked until the operation is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the flash chip on which to do the operation. </td></tr>
    <tr><td class="paramname">pi_flash_addr</td><td>The address of the sector to be erased. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga34cc29c30281c1a8d101bb90428ae7fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34cc29c30281c1a8d101bb90428ae7fc">&#9670;&nbsp;</a></span>pi_flash_erase_sector_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_flash_erase_sector_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_flash_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will erase one sector. The duration of this operation may be long and may be retrieved from the datasheet. A task must be specified in order to specify how the caller should be notified when the transfer is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the flash chip on which to do the operation. </td></tr>
    <tr><td class="paramname">pi_flash_addr</td><td>The address of the sector to be erased. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2473a95364ace1fa4babfa0b2807b753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2473a95364ace1fa4babfa0b2807b753">&#9670;&nbsp;</a></span>pi_flash_ioctl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t pi_flash_ioctl </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This can be called to configure and control the device after it has been opened.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device structure of the device to control. </td></tr>
    <tr><td class="paramname">cmd</td><td>The command to execute on the device. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument to the command. The size and meaning of this parameter depends on the command which is passed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga358f51250413be26066a2cfff3c7bd1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga358f51250413be26066a2cfff3c7bd1f">&#9670;&nbsp;</a></span>pi_flash_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_flash_open </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function must be called before the flash device can be used. It will do all the needed configuration to make it usable and initialize the handle used to refer to this opened device when calling other functions. The configuration associated to the device must specify the exact model of flash which must be opened.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the device structure of the device to open. This structure is allocated by the called and must be kept alive until the device is closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

<p class="reference">References <a class="el" href="structpi__flash__conf.html#a71145a2f3d702433379b3aadc408fe05">pi_flash_conf::api</a>.</p>

</div>
</div>
<a id="ga07fc48eca783c250239bcc79ebb370b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07fc48eca783c250239bcc79ebb370b0">&#9670;&nbsp;</a></span>pi_flash_program()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_flash_program </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_flash_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy will make a write transfer from one of the processor memory areas to the flash. The locations in the flash being written should have first been erased. The caller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the flash chip on which to do the copy. </td></tr>
    <tr><td class="paramname">pi_flash_addr</td><td>The address of the copy in the flash. </td></tr>
    <tr><td class="paramname">data</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabb2d100e16117ee76c3a0773b5182c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb2d100e16117ee76c3a0773b5182c6e">&#9670;&nbsp;</a></span>pi_flash_program_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_flash_program_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_flash_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy will make a write transfer from one of the processor memory areas to the flash. The locations in the flash being written should have first been erased. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the flash chip on which to do the copy. </td></tr>
    <tr><td class="paramname">pi_flash_addr</td><td>The address of the copy in the flash. </td></tr>
    <tr><td class="paramname">data</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5b75543c61bbfa36c1665c8e584bd30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b75543c61bbfa36c1665c8e584bd30a">&#9670;&nbsp;</a></span>pi_flash_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_flash_read </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_flash_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy will make a transfer between the flash and one of the processor memory areas. The caller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the flash chip on which to do the copy. </td></tr>
    <tr><td class="paramname">pi_flash_addr</td><td>The address of the copy in the flash. </td></tr>
    <tr><td class="paramname">data</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="group__Partition.html#ga1b46e427a83a4b9a3a8868a6626dd7cf">pi_partition_open()</a>.</p>

</div>
</div>
<a id="gab7adc6e516daa8d426bfd383dc9ecc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7adc6e516daa8d426bfd383dc9ecc1d">&#9670;&nbsp;</a></span>pi_flash_read_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_flash_read_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_flash_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy will make a transfer between the flash and one of the processor memory areas. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the flash chip on which to do the copy. </td></tr>
    <tr><td class="paramname">pi_flash_addr</td><td>The address of the copy in the flash. </td></tr>
    <tr><td class="paramname">data</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="read__fs_8c.html#a7ade43ad7ec3e750c5e9359b5e5eccb6">__pi_fs_mount_step()</a>, <a class="el" href="read__fs_8c.html#a747aa80eef7c19daef946b6f5709f80f">__pi_fs_read_block()</a>, and <a class="el" href="read__fs_8c.html#a53c3bf90f47f0b0f3fb553516ee85428">__pi_read_fs_direct_read_async()</a>.</p>

</div>
</div>
<a id="ga0b6932cbceeb974ed025747e8af78237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b6932cbceeb974ed025747e8af78237">&#9670;&nbsp;</a></span>pi_flash_reg_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_flash_reg_get </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reg_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This can be called to get a flash register. The list of registers is specific to each flash, see the documentation of the flash for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device structure of the flash. </td></tr>
    <tr><td class="paramname">reg_addr</td><td>The register address. </td></tr>
    <tr><td class="paramname">value</td><td>A pointer to the value where the read value will be stored. The size of this variable depends on the register being accessed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5b55ad4742567275fe98ec896e03dc73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b55ad4742567275fe98ec896e03dc73">&#9670;&nbsp;</a></span>pi_flash_reg_get_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_flash_reg_get_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reg_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This can be called to get a flash register. The list of registers is specific to each flash, see the documentation of the flash for more information. A task must be specified in order to specify how the caller should be notified when the operation is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device structure of the flash. </td></tr>
    <tr><td class="paramname">reg_addr</td><td>The register address. </td></tr>
    <tr><td class="paramname">value</td><td>A pointer to the value where the read value will be stored. The size of this variable depends on the register being accessed. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5a2b9fbb598048f89be57cb9ce74f690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a2b9fbb598048f89be57cb9ce74f690">&#9670;&nbsp;</a></span>pi_flash_reg_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_flash_reg_set </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reg_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This can be called to set a flash register. This must be used carefully as this can disturb the behavior of the other calls. The list of registers is specific to each flash, see the documentation of the flash for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device structure of the flash. </td></tr>
    <tr><td class="paramname">reg_addr</td><td>The register address. </td></tr>
    <tr><td class="paramname">value</td><td>A pointer to the value to be set. The size of this variable depends on the register being accessed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga89938c2184ce3e9c2aa02a5b1a9517cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89938c2184ce3e9c2aa02a5b1a9517cc">&#9670;&nbsp;</a></span>pi_flash_reg_set_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_flash_reg_set_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reg_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This can be called to set a flash register. This must be used carefully as this can disturb the behavior of the other calls. The list of registers is specific to each flash, see the documentation of the flash for more information. A task must be specified in order to specify how the caller should be notified when the operation is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device structure of the flash. </td></tr>
    <tr><td class="paramname">reg_addr</td><td>The register address. </td></tr>
    <tr><td class="paramname">value</td><td>A pointer to the value to be set. The size of this variable depends on the register being accessed. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jan 24 2020 12:47:54 for  by GreenWaves Technologies
	<!--
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 
	-->
	</li>
  </ul>
</div>
</body>
</html>
