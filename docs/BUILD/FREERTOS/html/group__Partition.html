<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Partition</title>
<title>Partition</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="pulp.css" rel="stylesheet" type="text/css" />
<link href="gap.css" rel="stylesheet" type="text/css" />
<link href="images.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="printComponentTabs.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="titlerow">
  <td id="projectlogo"><img alt="Logo" src="gap-logo-55.png" /></td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">FreeRTOS port on GAP8/RISC-V</div>
    </td>
  <td id="extralogo"><img alt="GreenWaves" src="greenwaves-logo-55.png" /></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="CMSISnav" class="tabs1">
    <ul class="tablist">
      <script type="text/javascript">
		<!--
		writeComponentTabs.call(this);
		//-->
      </script>
	  </ul>
</div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__Partition.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Partition</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpi__partition__conf.html">pi_partition_conf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition configuration structure.  <a href="structpi__partition__conf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1b46e427a83a4b9a3a8868a6626dd7cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#ga1b46e427a83a4b9a3a8868a6626dd7cf">pi_partition_open</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>)</td></tr>
<tr class="memdesc:ga1b46e427a83a4b9a3a8868a6626dd7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a partition device.  <a href="#ga1b46e427a83a4b9a3a8868a6626dd7cf">More...</a><br /></td></tr>
<tr class="separator:ga1b46e427a83a4b9a3a8868a6626dd7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29633af8d342d79a1a4f154f8bd2e56e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#ga29633af8d342d79a1a4f154f8bd2e56e">pi_partition_close</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>)</td></tr>
<tr class="memdesc:ga29633af8d342d79a1a4f154f8bd2e56e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an opened partition device.  <a href="#ga29633af8d342d79a1a4f154f8bd2e56e">More...</a><br /></td></tr>
<tr class="separator:ga29633af8d342d79a1a4f154f8bd2e56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b4098a944ca55174776756da24f0331"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#ga0b4098a944ca55174776756da24f0331">pi_partition_read_async</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, const uint32_t partition_addr, void *data, const size_t size, pi_task_t *task)</td></tr>
<tr class="memdesc:ga0b4098a944ca55174776756da24f0331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue an asynchronous read copy to the flash partition (from flash partition to processor).  <a href="#ga0b4098a944ca55174776756da24f0331">More...</a><br /></td></tr>
<tr class="separator:ga0b4098a944ca55174776756da24f0331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87d1cf8c8642288646172d1b1d72a6f4"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#ga87d1cf8c8642288646172d1b1d72a6f4">pi_partition_read</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, const uint32_t partition_addr, void *data, const size_t size)</td></tr>
<tr class="memdesc:ga87d1cf8c8642288646172d1b1d72a6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a read copy to the flash partition (from flash to processor).  <a href="#ga87d1cf8c8642288646172d1b1d72a6f4">More...</a><br /></td></tr>
<tr class="separator:ga87d1cf8c8642288646172d1b1d72a6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6d72b9a5da78008eafc0f35db19f907"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#gaf6d72b9a5da78008eafc0f35db19f907">pi_partition_write_async</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, const uint32_t partition_addr, const void *data, const size_t size, pi_task_t *task)</td></tr>
<tr class="memdesc:gaf6d72b9a5da78008eafc0f35db19f907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue an asynchronous read copy to the flash partition (from processor to flash partition).  <a href="#gaf6d72b9a5da78008eafc0f35db19f907">More...</a><br /></td></tr>
<tr class="separator:gaf6d72b9a5da78008eafc0f35db19f907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa251eb7a85614fbc0c3110554e4457b1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#gaa251eb7a85614fbc0c3110554e4457b1">pi_partition_write</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, const uint32_t partition_addr, const void *data, const size_t size)</td></tr>
<tr class="memdesc:gaa251eb7a85614fbc0c3110554e4457b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a write copy to the flash partition (from processor to flash).  <a href="#gaa251eb7a85614fbc0c3110554e4457b1">More...</a><br /></td></tr>
<tr class="separator:gaa251eb7a85614fbc0c3110554e4457b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec39f95d0879cf50b98e276eed83c44d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#gaec39f95d0879cf50b98e276eed83c44d">pi_partition_erase_async</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, uint32_t partition_addr, int size, pi_task_t *task)</td></tr>
<tr class="memdesc:gaec39f95d0879cf50b98e276eed83c44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an area in the flash partition asynchronously.  <a href="#gaec39f95d0879cf50b98e276eed83c44d">More...</a><br /></td></tr>
<tr class="separator:gaec39f95d0879cf50b98e276eed83c44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga584b30b7a477d8f4fcfe255d32175b6d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#ga584b30b7a477d8f4fcfe255d32175b6d">pi_partition_erase</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, uint32_t partition_addr, int size)</td></tr>
<tr class="memdesc:ga584b30b7a477d8f4fcfe255d32175b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an area in the flash partition.  <a href="#ga584b30b7a477d8f4fcfe255d32175b6d">More...</a><br /></td></tr>
<tr class="separator:ga584b30b7a477d8f4fcfe255d32175b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a403e8476035424f30798140e63b16d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#ga5a403e8476035424f30798140e63b16d">pi_partition_format_async</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>, pi_task_t *task)</td></tr>
<tr class="memdesc:ga5a403e8476035424f30798140e63b16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the whole flash partition asynchronously.  <a href="#ga5a403e8476035424f30798140e63b16d">More...</a><br /></td></tr>
<tr class="separator:ga5a403e8476035424f30798140e63b16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2c9d863c2cded58a5ea456932a13a3d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#gac2c9d863c2cded58a5ea456932a13a3d">pi_partition_format</a> (struct pi_device *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>)</td></tr>
<tr class="memdesc:gac2c9d863c2cded58a5ea456932a13a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the whole flash partition.  <a href="#gac2c9d863c2cded58a5ea456932a13a3d">More...</a><br /></td></tr>
<tr class="separator:gac2c9d863c2cded58a5ea456932a13a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94bd339e41868496b65351252fce3809"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#ga94bd339e41868496b65351252fce3809">pi_partition_get_size</a> (pi_device_t *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>)</td></tr>
<tr class="memdesc:ga94bd339e41868496b65351252fce3809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size in byte of the partition.  <a href="#ga94bd339e41868496b65351252fce3809">More...</a><br /></td></tr>
<tr class="separator:ga94bd339e41868496b65351252fce3809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba7a1be53d964222fd904fdbf656b556"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#gaba7a1be53d964222fd904fdbf656b556">pi_partition_get_flash_offset</a> (pi_device_t *<a class="el" href="api_2include_2pmsis_2drivers_2pwm_8h.html#a06e8ef9e222d1cf97fab7ecda62fc765">device</a>)</td></tr>
<tr class="memdesc:gaba7a1be53d964222fd904fdbf656b556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get flash partition start offset.  <a href="#gaba7a1be53d964222fd904fdbf656b556">More...</a><br /></td></tr>
<tr class="separator:gaba7a1be53d964222fd904fdbf656b556"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>The partition driver provides support for handling partition contained into a device storage. Currently, PMSIS and GAP SDK provide both partitions, binary firmware and filesystem.</p>
<ul>
<li>0 -&gt; Binary firmware;</li>
<li>1 -&gt; Filesystem or Free space.</li>
</ul>
<p>The beginning of the filesystem partition is aligned on a flash sector. Thus, an erase partition operation at address zero does not affect the data of the previous partition. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga29633af8d342d79a1a4f154f8bd2e56e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29633af8d342d79a1a4f154f8bd2e56e">&#9670;&nbsp;</a></span>pi_partition_close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int pi_partition_close </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function can be called to close an opened partition device once it is not needed anymore, in order to free all allocated resources. Once this function is called, the device is not accessible anymore and must be opened again before being used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device structure of the device to close. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

</div>
</div>
<a id="ga584b30b7a477d8f4fcfe255d32175b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga584b30b7a477d8f4fcfe255d32175b6d">&#9670;&nbsp;</a></span>pi_partition_erase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int pi_partition_erase </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>partition_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will erase the specified area. The duration of this operation may be long and may be retrieved from the datasheet. If the flash only supports sector erasing, all the sectors partially or entirely covered by this aread will be erased. The caller is blocked until the operation is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the flash partition on which to do the operation. </td></tr>
    <tr><td class="paramname">partition_addr</td><td>The address of the partition area to be erased. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the area to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

</div>
</div>
<a id="gaec39f95d0879cf50b98e276eed83c44d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec39f95d0879cf50b98e276eed83c44d">&#9670;&nbsp;</a></span>pi_partition_erase_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int pi_partition_erase_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>partition_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will erase the specified area. The duration of this operation may be long and may be retrieved from the datasheet. If the flash only supports sector erasing, all the sectors partially or entirely covered by this aread will be erased. A task must be specified in order to specify how the caller should be notified when the transfer is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the flash partition on which to do the operation. </td></tr>
    <tr><td class="paramname">partition_addr</td><td>The address of the partition area to be erased. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the area to be erased. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

</div>
</div>
<a id="gac2c9d863c2cded58a5ea456932a13a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2c9d863c2cded58a5ea456932a13a3d">&#9670;&nbsp;</a></span>pi_partition_format()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int pi_partition_format </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will erase the entire partition. The duration of this operation may be long and may be retrieved from the datasheet. The caller is blocked until the operation is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the flash partition on which to do the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

</div>
</div>
<a id="ga5a403e8476035424f30798140e63b16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a403e8476035424f30798140e63b16d">&#9670;&nbsp;</a></span>pi_partition_format_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int pi_partition_format_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will erase the entire partition. The duration of this operation may be long and may be retrieved from the datasheet. A task must be specified in order to specify how the caller should be notified when the transfer is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the flash partition on which to do the operation. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

</div>
</div>
<a id="gaba7a1be53d964222fd904fdbf656b556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba7a1be53d964222fd904fdbf656b556">&#9670;&nbsp;</a></span>pi_partition_get_flash_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pi_partition_get_flash_offset </td>
          <td>(</td>
          <td class="paramtype">pi_device_t *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The partition where the offset will be fetched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The flash offset in byte where the partition starts. </dd></dl>

<p class="reference">References <a class="el" href="maestro_8h.html#afd3147d9c9b4c531b7d78e6d29e1678a">if()</a>.</p>

</div>
</div>
<a id="ga94bd339e41868496b65351252fce3809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94bd339e41868496b65351252fce3809">&#9670;&nbsp;</a></span>pi_partition_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pi_partition_get_size </td>
          <td>(</td>
          <td class="paramtype">pi_device_t *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The partition where the size will be fetched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size in byte of the partition </dd></dl>

<p class="reference">References <a class="el" href="maestro_8h.html#afd3147d9c9b4c531b7d78e6d29e1678a">if()</a>.</p>

</div>
</div>
<a id="ga1b46e427a83a4b9a3a8868a6626dd7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b46e427a83a4b9a3a8868a6626dd7cf">&#9670;&nbsp;</a></span>pi_partition_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_partition_open </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function must be called before the partition can be used. It will do all the needed configuration to make it usable and initialize the handle used to refer to this opened device when calling other functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the device structure of the device to open. This structure is allocated by the called and must be kept alive until the device is closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

<p class="reference">References <a class="el" href="structpi__partition__conf.html#a8bcd4494102fd5070719bf7de0c3e356">pi_partition_conf::flash</a>, <a class="el" href="structpartition__table.html#a4ea7809ce05f885b7abbc2576b3cfd4f">partition_table::fs_offset</a>, <a class="el" href="structpi__partition__conf.html#a629086171b6e9b056d1d476debdf505d">pi_partition_conf::id</a>, <a class="el" href="maestro_8h.html#afd3147d9c9b4c531b7d78e6d29e1678a">if()</a>, <a class="el" href="partition_8c.html#a8dfbbfc6ec339653fca08158341d2ea1">partition_api</a>, <a class="el" href="group__Flash.html#ga5b75543c61bbfa36c1665c8e584bd30a">pi_flash_read()</a>, <a class="el" href="group__MemAlloc.html#gaea653642912f12cdbc7acd4664d82a31">pi_l2_free()</a>, and <a class="el" href="group__MemAlloc.html#ga427ad407c0aa87773f2fc010720d1a78">pi_l2_malloc()</a>.</p>

</div>
</div>
<a id="ga87d1cf8c8642288646172d1b1d72a6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87d1cf8c8642288646172d1b1d72a6f4">&#9670;&nbsp;</a></span>pi_partition_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int pi_partition_read </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>partition_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy will make a transfer between the flash partition and one of the processor memory areas. The caller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the partition on which to do the copy. </td></tr>
    <tr><td class="paramname">partition_addr</td><td>The address of the copy in the partition. </td></tr>
    <tr><td class="paramname">data</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

</div>
</div>
<a id="ga0b4098a944ca55174776756da24f0331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b4098a944ca55174776756da24f0331">&#9670;&nbsp;</a></span>pi_partition_read_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int pi_partition_read_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>partition_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy will make a transfer between the flash partition and one of the processor memory areas. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the partition on which to do the copy. </td></tr>
    <tr><td class="paramname">partition_addr</td><td>The address of the copy in the partition. </td></tr>
    <tr><td class="paramname">data</td><td>The buffer address of the copy. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

</div>
</div>
<a id="gaa251eb7a85614fbc0c3110554e4457b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa251eb7a85614fbc0c3110554e4457b1">&#9670;&nbsp;</a></span>pi_partition_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int pi_partition_write </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>partition_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy will make a write transfer from one of the processor memory areas to the partition. The locations in the flash being written should have first been erased. The caller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the flash partition on which to do the copy. </td></tr>
    <tr><td class="paramname">partition_addr</td><td>The address of the copy in the partition. </td></tr>
    <tr><td class="paramname">data</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

</div>
</div>
<a id="gaf6d72b9a5da78008eafc0f35db19f907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6d72b9a5da78008eafc0f35db19f907">&#9670;&nbsp;</a></span>pi_partition_write_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int pi_partition_write_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>partition_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy will make a transfer between the flash partition and one of the processor memory areas.</p>
<p>A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the partition on which to do the copy. </td></tr>
    <tr><td class="paramname">partition_addr</td><td>The address of the copy in the partition. </td></tr>
    <tr><td class="paramname">data</td><td>The buffer address of the copy. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Feb 12 2020 11:11:33 for  by GreenWaves Technologies
	<!--
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 
	-->
	</li>
  </ul>
</div>
</body>
</html>
