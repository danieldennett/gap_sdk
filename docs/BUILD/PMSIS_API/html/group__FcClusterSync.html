<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FC/Cluster synchronization</title>
<title>FC/Cluster synchronization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="pulp.css" rel="stylesheet" type="text/css" />
<link href="gap.css" rel="stylesheet" type="text/css" />
<link href="images.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="printComponentTabs.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="titlerow">
  <td id="projectlogo"><img alt="Logo" src="gap-logo-55.png" /></td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">PMSIS API</div>
    </td>
  <td id="extralogo"><img alt="GreenWaves" src="greenwaves-logo-55.png" /></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="CMSISnav" class="tabs1">
    <ul class="tablist">
      <script type="text/javascript">
		<!--
		writeComponentTabs.call(this);
		//-->
      </script>
	  </ul>
</div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__FcClusterSync.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">FC/Cluster synchronization<div class="ingroups"><a class="el" href="group__groupDrivers.html">Drivers</a> &raquo; <a class="el" href="group__clusterDriver.html">Cluster driver</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpi__cluster__conf.html">pi_cluster_conf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cluster configuration structure.  <a href="structpi__cluster__conf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1b4f02dfcb3851a6f27243ddf57986f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FcClusterSync.html#ga1b4f02dfcb3851a6f27243ddf57986f7">pi_cluster_conf_init</a> (struct <a class="el" href="structpi__cluster__conf.html">pi_cluster_conf</a> *conf)</td></tr>
<tr class="memdesc:ga1b4f02dfcb3851a6f27243ddf57986f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a cluster configuration with default values.  <a href="#ga1b4f02dfcb3851a6f27243ddf57986f7">More...</a><br /></td></tr>
<tr class="separator:ga1b4f02dfcb3851a6f27243ddf57986f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7593bf77b3e8cac046fbb6c6da6ae38"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FcClusterSync.html#gac7593bf77b3e8cac046fbb6c6da6ae38">pi_cluster_open</a> (struct pi_device *device)</td></tr>
<tr class="memdesc:gac7593bf77b3e8cac046fbb6c6da6ae38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open and power-up the cluster.  <a href="#gac7593bf77b3e8cac046fbb6c6da6ae38">More...</a><br /></td></tr>
<tr class="separator:gac7593bf77b3e8cac046fbb6c6da6ae38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf6b14394438fd589466c25eb8478f36"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FcClusterSync.html#gadf6b14394438fd589466c25eb8478f36">pi_cluster_close</a> (struct pi_device *device)</td></tr>
<tr class="memdesc:gadf6b14394438fd589466c25eb8478f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an opened cluster device.  <a href="#gadf6b14394438fd589466c25eb8478f36">More...</a><br /></td></tr>
<tr class="separator:gadf6b14394438fd589466c25eb8478f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5195ea7e3f7639a8558da24688d1a17d"><td class="memItemLeft" align="right" valign="top">static struct pi_cluster_task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FcClusterSync.html#ga5195ea7e3f7639a8558da24688d1a17d">pi_cluster_task</a> (struct pi_cluster_task *task, void(*entry)(void *), void *arg)</td></tr>
<tr class="memdesc:ga5195ea7e3f7639a8558da24688d1a17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare a cluster task for execution.  <a href="#ga5195ea7e3f7639a8558da24688d1a17d">More...</a><br /></td></tr>
<tr class="separator:ga5195ea7e3f7639a8558da24688d1a17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5f3c269b6b6917b78cb71863122577c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FcClusterSync.html#gae5f3c269b6b6917b78cb71863122577c">pi_cluster_send_task</a> (struct pi_device *device, struct <a class="el" href="group__FcClusterSync.html#ga5195ea7e3f7639a8558da24688d1a17d">pi_cluster_task</a> *task)</td></tr>
<tr class="memdesc:gae5f3c269b6b6917b78cb71863122577c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a task for execution on the cluster.  <a href="#gae5f3c269b6b6917b78cb71863122577c">More...</a><br /></td></tr>
<tr class="separator:gae5f3c269b6b6917b78cb71863122577c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae931e906e5d06738dc4b4f4f01889033"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FcClusterSync.html#gae931e906e5d06738dc4b4f4f01889033">pi_cluster_send_task_async</a> (struct pi_device *device, struct <a class="el" href="group__FcClusterSync.html#ga5195ea7e3f7639a8558da24688d1a17d">pi_cluster_task</a> *task, pi_task_t *end_task)</td></tr>
<tr class="memdesc:gae931e906e5d06738dc4b4f4f01889033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue asynchronously a task for execution on the cluster.  <a href="#gae931e906e5d06738dc4b4f4f01889033">More...</a><br /></td></tr>
<tr class="separator:gae931e906e5d06738dc4b4f4f01889033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga124a82953197185e33bb289489454767"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FcClusterSync.html#ga124a82953197185e33bb289489454767">pi_cl_send_task_to_fc</a> (pi_task_t *task)</td></tr>
<tr class="memdesc:ga124a82953197185e33bb289489454767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a task to fabric-controller side.  <a href="#ga124a82953197185e33bb289489454767">More...</a><br /></td></tr>
<tr class="separator:ga124a82953197185e33bb289489454767"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>This set of functions provide support for controlling clusters from fabric-controller side. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga124a82953197185e33bb289489454767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga124a82953197185e33bb289489454767">&#9670;&nbsp;</a></span>pi_cl_send_task_to_fc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_cl_send_task_to_fc </td>
          <td>(</td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enqueues the specified task into the fabric-controller task scheduler for execution. The task must have been initialized from fabric-controller side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>Pointer to the fabric-controller task to be enqueued. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadf6b14394438fd589466c25eb8478f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf6b14394438fd589466c25eb8478f36">&#9670;&nbsp;</a></span>pi_cluster_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_cluster_close </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to close an opened cluster device once it is not needed anymore, in order to free all allocated resources. Once this function is called, the device is not accessible anymore and must be opened again before being used. This will power-down the cluster. The caller is blocked until the operation is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1b4f02dfcb3851a6f27243ddf57986f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b4f02dfcb3851a6f27243ddf57986f7">&#9670;&nbsp;</a></span>pi_cluster_conf_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_cluster_conf_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpi__cluster__conf.html">pi_cluster_conf</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to get default values for all parameters before setting some of them. The structure containing the configuration must be kept alive until the SPI device is opened.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>A pointer to the SPI master configuration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac7593bf77b3e8cac046fbb6c6da6ae38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7593bf77b3e8cac046fbb6c6da6ae38">&#9670;&nbsp;</a></span>pi_cluster_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_cluster_open </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function must be called before the cluster device can be used. It will do all the needed configuration to make it usable and initialize the handle used to refer to this opened device when calling other functions. By default the cluster is powered down and cannot be used. Calling this function will power it up. At the end of the call, the cluster is ready to execute a task. The caller is blocked until the operation is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the device structure of the device to open. This structure is allocated by the called and must be kept alive until the device is closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

</div>
</div>
<a id="gae5f3c269b6b6917b78cb71863122577c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5f3c269b6b6917b78cb71863122577c">&#9670;&nbsp;</a></span>pi_cluster_send_task()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int pi_cluster_send_task </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__FcClusterSync.html#ga5195ea7e3f7639a8558da24688d1a17d">pi_cluster_task</a> *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will enqueue the task at the end of the queue of tasks, ready to be executed by the specified cluster. Once the task gets scheduled, the cluster-controller core is waken-up and starts executing the task entry point. This function is intended to be used for coarse-grain job delegation to the cluster side, and thus the stack used to execute this function can be specified. When the function starts executing on the cluster, the other cores of the cluster are also available for parallel computation. Thus the stacks for the other cores (called slave cores) can also be specified, as well as the number of cores which can be used by the function on the cluster (including the cluster controller). The caller is blocked until the task has finished execution.</p>
<p>Note that this enqueues a function execution. To allow cluster executions to be pipelined, several tasks can be enqueued at the same time. If more than two tasks are enqueued, as soon as the first is finished, the cluster-controller core immediately continues with the next one, while the fabric controller receives the termination notification and can enqueue a new execution, in order to keep the cluster busy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
    <tr><td class="paramname">task</td><td>Cluster task structure containing task and its parameters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae931e906e5d06738dc4b4f4f01889033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae931e906e5d06738dc4b4f4f01889033">&#9670;&nbsp;</a></span>pi_cluster_send_task_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int pi_cluster_send_task_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__FcClusterSync.html#ga5195ea7e3f7639a8558da24688d1a17d">pi_cluster_task</a> *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>end_task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will enqueue the task at the end of the queue of tasks, ready to be executed by the specified cluster. Once the task gets scheduled, the cluster-controller core is waken-up and starts executing the task entry point. This function is intended to be used for coarse-grain job delegation to the cluster side, and thus the stack used to execute this function can be specified. When the function starts executing on the cluster, the other cores of the cluster are also available for parallel computation. Thus the stacks for the other cores (called slave cores) can also be specified, as well as the number of cores which can be used by the function on the cluster (including the cluster controller). The task is just enqueued and the caller continues execution. A task must be specified in order to specify how the caller should be notified when the task has finished execution.</p>
<p>Note that this enqueues a function execution. To allow cluster executions to be pipelined, several tasks can be enqueued at the same time. If more than two tasks are enqueued, as soon as the first is finished, the cluster-controller core immediately continues with the next one, while the fabric controller receives the termination notification and can enqueue a new execution, in order to keep the cluster busy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
    <tr><td class="paramname">task</td><td>Cluster task structure containing task and its parameters. </td></tr>
    <tr><td class="paramname">end_task</td><td>The task used to notify the end of execution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5195ea7e3f7639a8558da24688d1a17d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5195ea7e3f7639a8558da24688d1a17d">&#9670;&nbsp;</a></span>pi_cluster_task()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct pi_cluster_task* pi_cluster_task </td>
          <td>(</td>
          <td class="paramtype">struct pi_cluster_task *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This initializes a cluster task before it can be sent to the cluster side for execution. If the same task is re-used for several executions, it must be reinitialized everytime by calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>A pointer to the structure describing the task. This structure is allocated by the caller and must be kept alive until the task has finished execution. </td></tr>
    <tr><td class="paramname">entry</td><td>The task entry point that the cluster controller will execute. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument to the entry point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Feb 12 2020 11:11:35 for  by GreenWaves Technologies
	<!--
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 
	-->
	</li>
  </ul>
</div>
</body>
</html>
