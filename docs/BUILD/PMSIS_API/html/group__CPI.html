<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>CPI</title>
<title>CPI</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="pulp.css" rel="stylesheet" type="text/css" />
<link href="gap.css" rel="stylesheet" type="text/css" />
<link href="images.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="printComponentTabs.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="titlerow">
  <td id="projectlogo"><img alt="Logo" src="gap-logo-55.png" /></td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">PMSIS API</div>
    </td>
  <td id="extralogo"><img alt="GreenWaves" src="greenwaves-logo-55.png" /></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="CMSISnav" class="tabs1">
    <ul class="tablist">
      <script type="text/javascript">
		<!--
		writeComponentTabs.call(this);
		//-->
      </script>
	  </ul>
</div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__CPI.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CPI<div class="ingroups"><a class="el" href="group__groupDrivers.html">Drivers</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpi__cpi__conf.html">pi_cpi_conf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPI device configuration structure.  <a href="structpi__cpi__conf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gab0c7dac08458ff8d7acf5264610b1a9a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPI.html#gab0c7dac08458ff8d7acf5264610b1a9a">pi_cpi_format_e</a> <tr class="memdesc:gab0c7dac08458ff8d7acf5264610b1a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image format identifier.  <a href="group__CPI.html#gab0c7dac08458ff8d7acf5264610b1a9a">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gab0c7dac08458ff8d7acf5264610b1a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac23563c39a8824c67e572f47432d030e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPI.html#gac23563c39a8824c67e572f47432d030e">pi_cpi_conf_init</a> (struct <a class="el" href="structpi__cpi__conf.html">pi_cpi_conf</a> *conf)</td></tr>
<tr class="memdesc:gac23563c39a8824c67e572f47432d030e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a CPI configuration with default values.  <a href="#gac23563c39a8824c67e572f47432d030e">More...</a><br /></td></tr>
<tr class="separator:gac23563c39a8824c67e572f47432d030e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09d72198f02fdf036d0e647d979dc83a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPI.html#ga09d72198f02fdf036d0e647d979dc83a">pi_cpi_open</a> (struct pi_device *device)</td></tr>
<tr class="memdesc:ga09d72198f02fdf036d0e647d979dc83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a CPI device.  <a href="#ga09d72198f02fdf036d0e647d979dc83a">More...</a><br /></td></tr>
<tr class="separator:ga09d72198f02fdf036d0e647d979dc83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d699d5fb2a79f57021cc8b989015fe6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPI.html#ga4d699d5fb2a79f57021cc8b989015fe6">pi_cpi_close</a> (struct pi_device *device)</td></tr>
<tr class="memdesc:ga4d699d5fb2a79f57021cc8b989015fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an opened CPI device.  <a href="#ga4d699d5fb2a79f57021cc8b989015fe6">More...</a><br /></td></tr>
<tr class="separator:ga4d699d5fb2a79f57021cc8b989015fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34f8cfea393bb07b81789843eea856c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPI.html#ga34f8cfea393bb07b81789843eea856c7">pi_cpi_capture</a> (struct pi_device *device, void *buffer, int32_t bufferlen)</td></tr>
<tr class="memdesc:ga34f8cfea393bb07b81789843eea856c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capture a sequence of samples.  <a href="#ga34f8cfea393bb07b81789843eea856c7">More...</a><br /></td></tr>
<tr class="separator:ga34f8cfea393bb07b81789843eea856c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d7684edbcc32600609d49bc3e7ddb65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPI.html#ga6d7684edbcc32600609d49bc3e7ddb65">pi_cpi_capture_async</a> (struct pi_device *device, void *buffer, int32_t bufferlen, pi_task_t *task)</td></tr>
<tr class="memdesc:ga6d7684edbcc32600609d49bc3e7ddb65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capture a sequence of samples asynchronously.  <a href="#ga6d7684edbcc32600609d49bc3e7ddb65">More...</a><br /></td></tr>
<tr class="separator:ga6d7684edbcc32600609d49bc3e7ddb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa454f2fb96bba56ac17882ae45a6318e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPI.html#gaa454f2fb96bba56ac17882ae45a6318e">pi_cpi_control_start</a> (struct pi_device *device)</td></tr>
<tr class="memdesc:gaa454f2fb96bba56ac17882ae45a6318e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start capturing samples.  <a href="#gaa454f2fb96bba56ac17882ae45a6318e">More...</a><br /></td></tr>
<tr class="separator:gaa454f2fb96bba56ac17882ae45a6318e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5184e56904f3d40ebbe20fdd5d8943c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPI.html#gad5184e56904f3d40ebbe20fdd5d8943c">pi_cpi_control_stop</a> (struct pi_device *device)</td></tr>
<tr class="memdesc:gad5184e56904f3d40ebbe20fdd5d8943c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop capturing samples.  <a href="#gad5184e56904f3d40ebbe20fdd5d8943c">More...</a><br /></td></tr>
<tr class="separator:gad5184e56904f3d40ebbe20fdd5d8943c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf069ebc6120686f16fec8a8a28c9e459"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPI.html#gaf069ebc6120686f16fec8a8a28c9e459">pi_cpi_set_format</a> (struct pi_device *device, <a class="el" href="group__CPI.html#gab0c7dac08458ff8d7acf5264610b1a9a">pi_cpi_format_e</a> format)</td></tr>
<tr class="memdesc:gaf069ebc6120686f16fec8a8a28c9e459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set frame format.  <a href="#gaf069ebc6120686f16fec8a8a28c9e459">More...</a><br /></td></tr>
<tr class="separator:gaf069ebc6120686f16fec8a8a28c9e459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga005189b01035617a0f7732aa9e209c95"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPI.html#ga005189b01035617a0f7732aa9e209c95">pi_cpi_set_frame_drop</a> (struct pi_device *device, uint32_t nb_frame_dropped)</td></tr>
<tr class="memdesc:ga005189b01035617a0f7732aa9e209c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure frame drop.  <a href="#ga005189b01035617a0f7732aa9e209c95">More...</a><br /></td></tr>
<tr class="separator:ga005189b01035617a0f7732aa9e209c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabce0d8a37873a37cba70dabdf28284b7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPI.html#gabce0d8a37873a37cba70dabdf28284b7">pi_cpi_set_filter</a> (struct pi_device *device, uint32_t r_coeff, uint32_t g_coeff, uint32_t b_coeff, uint32_t shift)</td></tr>
<tr class="memdesc:gabce0d8a37873a37cba70dabdf28284b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure frame filtering.  <a href="#gabce0d8a37873a37cba70dabdf28284b7">More...</a><br /></td></tr>
<tr class="separator:gabce0d8a37873a37cba70dabdf28284b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed7114756fa7eb69b361f4a6cbb99f6e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPI.html#gaed7114756fa7eb69b361f4a6cbb99f6e">pi_cpi_set_slice</a> (struct pi_device *device, uint32_t x, uint32_t y, uint32_t w, uint32_t h)</td></tr>
<tr class="memdesc:gaed7114756fa7eb69b361f4a6cbb99f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure frame slicing.  <a href="#gaed7114756fa7eb69b361f4a6cbb99f6e">More...</a><br /></td></tr>
<tr class="separator:gaed7114756fa7eb69b361f4a6cbb99f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>This API provides support for capturing images from an image sensor through the Camera Parallel Interface (CPI) and processing them. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gab0c7dac08458ff8d7acf5264610b1a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0c7dac08458ff8d7acf5264610b1a9a">&#9670;&nbsp;</a></span>pi_cpi_format_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__CPI.html#gab0c7dac08458ff8d7acf5264610b1a9a">pi_cpi_format_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This can be used to describe the format of the image going through the interface. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab0c7dac08458ff8d7acf5264610b1a9aa95ba38df611a794bb795afc19bd124c7"></a>PI_CPI_FORMAT_RGB565&#160;</td><td class="fielddoc"><p>RGB565 format. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab0c7dac08458ff8d7acf5264610b1a9aaf46631dd50906fb73186a1f2b86c3424"></a>PI_CPI_FORMAT_RGB555&#160;</td><td class="fielddoc"><p>RGB555 format. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab0c7dac08458ff8d7acf5264610b1a9aa9e30e18253c635477ff51fa2f623a4f6"></a>PI_CPI_FORMAT_RGB444&#160;</td><td class="fielddoc"><p>RGB444 format. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab0c7dac08458ff8d7acf5264610b1a9aa10cca5456eb61a3921ca82b05df85fed"></a>PI_CPI_FORMAT_YUV422&#160;</td><td class="fielddoc"><p>YUV422 format. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab0c7dac08458ff8d7acf5264610b1a9aae57858b7d7048cdb7a7938cc408958be"></a>PI_CPI_FORMAT_BYPASS_LITEND&#160;</td><td class="fielddoc"><p>Only least significant byte is kept. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab0c7dac08458ff8d7acf5264610b1a9aa7d3d17354e8b68dc3bf46d9b4dd9115e"></a>PI_CPI_FORMAT_BYPASS_BIGEND&#160;</td><td class="fielddoc"><p>Only most significant byte is kept. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga34f8cfea393bb07b81789843eea856c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34f8cfea393bb07b81789843eea856c7">&#9670;&nbsp;</a></span>pi_cpi_capture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_cpi_capture </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>bufferlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queue a buffer that will receive samples from the CPI interface. This function is synchronous and will block the caller until the specified amount of bytes is received. The buffer will receive samples only if the interface is started. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
    <tr><td class="paramname">buffer</td><td>The memory buffer where the captured samples will be transferred. </td></tr>
    <tr><td class="paramname">bufferlen</td><td>The size in bytes of the memory buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6d7684edbcc32600609d49bc3e7ddb65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d7684edbcc32600609d49bc3e7ddb65">&#9670;&nbsp;</a></span>pi_cpi_capture_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_cpi_capture_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>bufferlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queue a buffer that will receive samples from the CPI interface. This function is asynchronous and will not block the caller. It is possible to call it several times in order to queue several buffers. At a minimum 2 buffers should be queued to ensure that no data sampled is lost. This is also the most efficient way to retrieve data from the CPI device. You should always make sure that at least 2 buffers are always queued, by queuing a new one as soon as the current one is full. The buffer will receive samples only if the interface is started. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
    <tr><td class="paramname">buffer</td><td>The memory buffer where the captured samples will be transferred. </td></tr>
    <tr><td class="paramname">bufferlen</td><td>The size in bytes of the memory buffer. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4d699d5fb2a79f57021cc8b989015fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d699d5fb2a79f57021cc8b989015fe6">&#9670;&nbsp;</a></span>pi_cpi_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_cpi_close </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to close an opened CPI device once it is not needed anymore in order to free all allocated resources. Once this function is called, the device is not accessible anymore and must be opened again before being used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac23563c39a8824c67e572f47432d030e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac23563c39a8824c67e572f47432d030e">&#9670;&nbsp;</a></span>pi_cpi_conf_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_cpi_conf_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpi__cpi__conf.html">pi_cpi_conf</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The structure containing the configuration must be kept alive until the camera device is opened.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>A pointer to the CPI configuration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa454f2fb96bba56ac17882ae45a6318e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa454f2fb96bba56ac17882ae45a6318e">&#9670;&nbsp;</a></span>pi_cpi_control_start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_cpi_control_start </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The samples arriving at the CPI interface are dropped until the interface is started by calling this function. Once started, the sampling will start at the next beginning of frame.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad5184e56904f3d40ebbe20fdd5d8943c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5184e56904f3d40ebbe20fdd5d8943c">&#9670;&nbsp;</a></span>pi_cpi_control_stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_cpi_control_stop </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The samples arriving at the CPI interface are dropped after this call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga09d72198f02fdf036d0e647d979dc83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09d72198f02fdf036d0e647d979dc83a">&#9670;&nbsp;</a></span>pi_cpi_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_cpi_open </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function must be called before the CPI device can be used. It configures the specified device that can then be used to refer to the opened device when calling other functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. This structure muts be allocated by the caller and kept alive until the device is closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if it succeeded or -1 if it failed. </dd></dl>

</div>
</div>
<a id="gabce0d8a37873a37cba70dabdf28284b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabce0d8a37873a37cba70dabdf28284b7">&#9670;&nbsp;</a></span>pi_cpi_set_filter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_cpi_set_filter </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>r_coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>g_coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>b_coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Configure how to filter the input pixels to produce the 8bits output pixels. Each channel is multiplied by a coefficient. They are then summed together and shifted right to obtain an 8 bit pixel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
    <tr><td class="paramname">r_coeff</td><td>Red channel is multipled by this coefficient. </td></tr>
    <tr><td class="paramname">g_coeff</td><td>Green channel is multipled by this coefficient. </td></tr>
    <tr><td class="paramname">b_coeff</td><td>Blue channel is multipled by this coefficient. </td></tr>
    <tr><td class="paramname">shift</td><td>The sum of all channels multiplied by their coefficient is shifted right by this value to fit an 8 bit pixel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf069ebc6120686f16fec8a8a28c9e459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf069ebc6120686f16fec8a8a28c9e459">&#9670;&nbsp;</a></span>pi_cpi_set_format()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_cpi_set_format </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CPI.html#gab0c7dac08458ff8d7acf5264610b1a9a">pi_cpi_format_e</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This can be used either when filtering is not active to specify which part of the samples to keep, or when filtering is active, to specify what is the input format, to be able to properly convert the image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
    <tr><td class="paramname">format</td><td>The format of the input frame. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga005189b01035617a0f7732aa9e209c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga005189b01035617a0f7732aa9e209c95">&#9670;&nbsp;</a></span>pi_cpi_set_frame_drop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_cpi_set_frame_drop </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nb_frame_dropped</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each sampled frame, the specified number of frames will be dropped before the next frame is sampled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
    <tr><td class="paramname">nb_frame_dropped</td><td>Number of frames to drop. Can be set to 0 to deactivate this feature. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaed7114756fa7eb69b361f4a6cbb99f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed7114756fa7eb69b361f4a6cbb99f6e">&#9670;&nbsp;</a></span>pi_cpi_set_slice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_cpi_set_slice </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Configure how to extract a window slice out of the input frame.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
    <tr><td class="paramname">x</td><td>x position of the window to extract. </td></tr>
    <tr><td class="paramname">y</td><td>y position of the window to extract. </td></tr>
    <tr><td class="paramname">w</td><td>Width of the window to extract. </td></tr>
    <tr><td class="paramname">h</td><td>Height of the window to extract. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jan 24 2020 12:47:55 for  by GreenWaves Technologies
	<!--
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 
	-->
	</li>
  </ul>
</div>
</body>
</html>
