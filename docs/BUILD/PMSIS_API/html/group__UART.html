<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>UART</title>
<title>UART</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="pulp.css" rel="stylesheet" type="text/css" />
<link href="gap.css" rel="stylesheet" type="text/css" />
<link href="images.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="printComponentTabs.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="titlerow">
  <td id="projectlogo"><img alt="Logo" src="gap-logo-55.png" /></td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">PMSIS API</div>
    </td>
  <td id="extralogo"><img alt="GreenWaves" src="greenwaves-logo-55.png" /></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="CMSISnav" class="tabs1">
    <ul class="tablist">
      <script type="text/javascript">
		<!--
		writeComponentTabs.call(this);
		//-->
      </script>
	  </ul>
</div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__UART.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">UART<div class="ingroups"><a class="el" href="group__groupDrivers.html">Drivers</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpi__uart__conf.html">pi_uart_conf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART device configuration structure.  <a href="structpi__uart__conf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5f18274f56cb237e94d317a67e0882b0"><td class="memItemLeft" align="right" valign="top">typedef struct pi_cl_uart_req_s&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a></td></tr>
<tr class="memdesc:ga5f18274f56cb237e94d317a67e0882b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART cluster request structure.  <a href="#ga5f18274f56cb237e94d317a67e0882b0">More...</a><br /></td></tr>
<tr class="separator:ga5f18274f56cb237e94d317a67e0882b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8c26b46bd5eb4ee4177e6027a69a55bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga8c26b46bd5eb4ee4177e6027a69a55bc">pi_uart_conf_init</a> (struct <a class="el" href="structpi__uart__conf.html">pi_uart_conf</a> *conf)</td></tr>
<tr class="memdesc:ga8c26b46bd5eb4ee4177e6027a69a55bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a UART configuration with default values.  <a href="#ga8c26b46bd5eb4ee4177e6027a69a55bc">More...</a><br /></td></tr>
<tr class="separator:ga8c26b46bd5eb4ee4177e6027a69a55bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21def19994b46489a8ffa4cf030e9794"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga21def19994b46489a8ffa4cf030e9794">pi_uart_open</a> (struct pi_device *device)</td></tr>
<tr class="memdesc:ga21def19994b46489a8ffa4cf030e9794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a UART device.  <a href="#ga21def19994b46489a8ffa4cf030e9794">More...</a><br /></td></tr>
<tr class="separator:ga21def19994b46489a8ffa4cf030e9794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bb339477c7ccb7b91d1ddfe949dbbd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga6bb339477c7ccb7b91d1ddfe949dbbd1">pi_uart_close</a> (struct pi_device *device)</td></tr>
<tr class="memdesc:ga6bb339477c7ccb7b91d1ddfe949dbbd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an opened UART device.  <a href="#ga6bb339477c7ccb7b91d1ddfe949dbbd1">More...</a><br /></td></tr>
<tr class="separator:ga6bb339477c7ccb7b91d1ddfe949dbbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga953a8ceefcc5a33871dd32c4d9a9ef35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga953a8ceefcc5a33871dd32c4d9a9ef35">pi_uart_write</a> (struct pi_device *device, void *buffer, uint32_t size)</td></tr>
<tr class="memdesc:ga953a8ceefcc5a33871dd32c4d9a9ef35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to an UART.  <a href="#ga953a8ceefcc5a33871dd32c4d9a9ef35">More...</a><br /></td></tr>
<tr class="separator:ga953a8ceefcc5a33871dd32c4d9a9ef35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa902ab4ee7d2023375e1319d4ad1a51e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#gaa902ab4ee7d2023375e1319d4ad1a51e">pi_uart_read</a> (struct pi_device *device, void *buffer, uint32_t size)</td></tr>
<tr class="memdesc:gaa902ab4ee7d2023375e1319d4ad1a51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from an UART.  <a href="#gaa902ab4ee7d2023375e1319d4ad1a51e">More...</a><br /></td></tr>
<tr class="separator:gaa902ab4ee7d2023375e1319d4ad1a51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47076425f15e54cc170f32259fddcca6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga47076425f15e54cc170f32259fddcca6">pi_uart_write_byte</a> (struct pi_device *device, uint8_t *byte)</td></tr>
<tr class="memdesc:ga47076425f15e54cc170f32259fddcca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a byte to an UART.  <a href="#ga47076425f15e54cc170f32259fddcca6">More...</a><br /></td></tr>
<tr class="separator:ga47076425f15e54cc170f32259fddcca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01778d12b41a16cf0c6e61161b854a3e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga01778d12b41a16cf0c6e61161b854a3e">pi_uart_read_byte</a> (struct pi_device *device, uint8_t *byte)</td></tr>
<tr class="memdesc:ga01778d12b41a16cf0c6e61161b854a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a byte from an UART.  <a href="#ga01778d12b41a16cf0c6e61161b854a3e">More...</a><br /></td></tr>
<tr class="separator:ga01778d12b41a16cf0c6e61161b854a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae27ad3c7ffe2bc97c251a833189d2121"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#gae27ad3c7ffe2bc97c251a833189d2121">pi_uart_write_async</a> (struct pi_device *device, void *buffer, uint32_t size, pi_task_t *callback)</td></tr>
<tr class="memdesc:gae27ad3c7ffe2bc97c251a833189d2121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to an UART asynchronously.  <a href="#gae27ad3c7ffe2bc97c251a833189d2121">More...</a><br /></td></tr>
<tr class="separator:gae27ad3c7ffe2bc97c251a833189d2121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada5035f9fd4b858f8326c8b30d254e56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#gada5035f9fd4b858f8326c8b30d254e56">pi_uart_read_async</a> (struct pi_device *device, void *buffer, uint32_t size, pi_task_t *callback)</td></tr>
<tr class="memdesc:gada5035f9fd4b858f8326c8b30d254e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from an UART asynchronously.  <a href="#gada5035f9fd4b858f8326c8b30d254e56">More...</a><br /></td></tr>
<tr class="separator:gada5035f9fd4b858f8326c8b30d254e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a32e4b740d4949371ed44c564f640c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga5a32e4b740d4949371ed44c564f640c7">pi_uart_write_byte_async</a> (struct pi_device *device, uint8_t *byte, pi_task_t *callback)</td></tr>
<tr class="memdesc:ga5a32e4b740d4949371ed44c564f640c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a byte to an UART asynchronously.  <a href="#ga5a32e4b740d4949371ed44c564f640c7">More...</a><br /></td></tr>
<tr class="separator:ga5a32e4b740d4949371ed44c564f640c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga156527715f9648a683a3065833cf96fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga156527715f9648a683a3065833cf96fd">pi_cl_uart_write</a> (pi_device_t *device, void *buffer, uint32_t size, <a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a> *req)</td></tr>
<tr class="memdesc:ga156527715f9648a683a3065833cf96fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to an UART from cluster side.  <a href="#ga156527715f9648a683a3065833cf96fd">More...</a><br /></td></tr>
<tr class="separator:ga156527715f9648a683a3065833cf96fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac447ba2c94ca588fe15c2ddd5225bfc1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#gac447ba2c94ca588fe15c2ddd5225bfc1">pi_cl_uart_write_byte</a> (pi_device_t *device, uint8_t *byte, <a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a> *req)</td></tr>
<tr class="memdesc:gac447ba2c94ca588fe15c2ddd5225bfc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a byte to an UART from cluster side.  <a href="#gac447ba2c94ca588fe15c2ddd5225bfc1">More...</a><br /></td></tr>
<tr class="separator:gac447ba2c94ca588fe15c2ddd5225bfc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga336e8f3573b9c9df85cd13cc9af42210"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga336e8f3573b9c9df85cd13cc9af42210">pi_cl_uart_write_wait</a> (<a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a> *req)</td></tr>
<tr class="memdesc:ga336e8f3573b9c9df85cd13cc9af42210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the specified UART cluster write request has finished.  <a href="#ga336e8f3573b9c9df85cd13cc9af42210">More...</a><br /></td></tr>
<tr class="separator:ga336e8f3573b9c9df85cd13cc9af42210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae36cc5b5e44cf253e506b2d473824ef0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#gae36cc5b5e44cf253e506b2d473824ef0">pi_cl_uart_read</a> (pi_device_t *device, void *addr, uint32_t size, <a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a> *req)</td></tr>
<tr class="memdesc:gae36cc5b5e44cf253e506b2d473824ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a byte from an UART from cluster side.  <a href="#gae36cc5b5e44cf253e506b2d473824ef0">More...</a><br /></td></tr>
<tr class="separator:gae36cc5b5e44cf253e506b2d473824ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5c94eab051c6dd60c1bf1bfd421bd21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#gaa5c94eab051c6dd60c1bf1bfd421bd21">pi_cl_uart_read_byte</a> (pi_device_t *device, uint8_t *byte, <a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a> *req)</td></tr>
<tr class="memdesc:gaa5c94eab051c6dd60c1bf1bfd421bd21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a byte from an UART.  <a href="#gaa5c94eab051c6dd60c1bf1bfd421bd21">More...</a><br /></td></tr>
<tr class="separator:gaa5c94eab051c6dd60c1bf1bfd421bd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4311ef784433dff113c2899e13a5f70"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#gab4311ef784433dff113c2899e13a5f70">pi_cl_uart_read_wait</a> (<a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a> *req)</td></tr>
<tr class="memdesc:gab4311ef784433dff113c2899e13a5f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the specified UART cluster read request has finished.  <a href="#gab4311ef784433dff113c2899e13a5f70">More...</a><br /></td></tr>
<tr class="separator:gab4311ef784433dff113c2899e13a5f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>This API provides support for transferring data between an external UART device and the processor running this driver. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga5f18274f56cb237e94d317a67e0882b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f18274f56cb237e94d317a67e0882b0">&#9670;&nbsp;</a></span>pi_cl_uart_req_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct pi_cl_uart_req_s <a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This structure is used by the runtime to manage a cluster remote copy with the UART. It must be instantiated once for each copy and must be kept alive until the copy is finished. It can be instantiated as a normal variable, for example as a global variable, a local one on the stack, or through a memory allocator. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae36cc5b5e44cf253e506b2d473824ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae36cc5b5e44cf253e506b2d473824ef0">&#9670;&nbsp;</a></span>pi_cl_uart_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_cl_uart_read </td>
          <td>(</td>
          <td class="paramtype">pi_device_t *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function implements the same feature as pi_uart_read_byte but can be called from cluster side in order to expose the feature on the cluster. A pointer to a request structure must be provided so that the runtime can properly do the remote call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the UART device on which to do the copy. </td></tr>
    <tr><td class="paramname">addr</td><td>The address of the data in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy. </td></tr>
    <tr><td class="paramname">req</td><td>The request structure used for termination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

</div>
</div>
<a id="gaa5c94eab051c6dd60c1bf1bfd421bd21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5c94eab051c6dd60c1bf1bfd421bd21">&#9670;&nbsp;</a></span>pi_cl_uart_read_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_cl_uart_read_byte </td>
          <td>(</td>
          <td class="paramtype">pi_device_t *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This reads a byte from the specified UART. The caller is blocked until the transfer is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the UART device on which to do the copy. </td></tr>
    <tr><td class="paramname">byte</td><td>A pointer to the byte where the data should be written. </td></tr>
    <tr><td class="paramname">req</td><td>The request structure used for termination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

</div>
</div>
<a id="gab4311ef784433dff113c2899e13a5f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4311ef784433dff113c2899e13a5f70">&#9670;&nbsp;</a></span>pi_cl_uart_read_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_cl_uart_read_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This blocks the calling core until the specified cluster remote copy is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>The request structure used for termination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga156527715f9648a683a3065833cf96fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga156527715f9648a683a3065833cf96fd">&#9670;&nbsp;</a></span>pi_cl_uart_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_cl_uart_write </td>
          <td>(</td>
          <td class="paramtype">pi_device_t *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function implements the same feature as pi_uart_write but can be called from cluster side in order to expose the feature on the cluster. A pointer to a request structure must be provided so that the runtime can properly do the remote call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the UART on which to do the copy. </td></tr>
    <tr><td class="paramname">buffer</td><td>The memory buffer from where the data to write to the UART must be read. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the memory buffer. </td></tr>
    <tr><td class="paramname">req</td><td>The request structure used for termination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

</div>
</div>
<a id="gac447ba2c94ca588fe15c2ddd5225bfc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac447ba2c94ca588fe15c2ddd5225bfc1">&#9670;&nbsp;</a></span>pi_cl_uart_write_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_cl_uart_write_byte </td>
          <td>(</td>
          <td class="paramtype">pi_device_t *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function implements the same feature as pi_uart_write_byte but can be called from cluster side in order to expose the feature on the cluster. A pointer to a request structure must be provided so that the runtime can properly do the remote call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the UART device on which to do the copy. </td></tr>
    <tr><td class="paramname">byte</td><td>A pointer to the byte which should be written. </td></tr>
    <tr><td class="paramname">req</td><td>The request structure used for termination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

</div>
</div>
<a id="ga336e8f3573b9c9df85cd13cc9af42210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga336e8f3573b9c9df85cd13cc9af42210">&#9670;&nbsp;</a></span>pi_cl_uart_write_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_cl_uart_write_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This blocks the calling core until the specified cluster remote copy is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>The request structure used for termination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6bb339477c7ccb7b91d1ddfe949dbbd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bb339477c7ccb7b91d1ddfe949dbbd1">&#9670;&nbsp;</a></span>pi_uart_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_uart_close </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to close an opened UART device once it is not needed anymore, in order to free all allocated resources. Once this function is called, the device is not accessible anymore and must be opened again before being used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device structure of the device to close. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8c26b46bd5eb4ee4177e6027a69a55bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c26b46bd5eb4ee4177e6027a69a55bc">&#9670;&nbsp;</a></span>pi_uart_conf_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_uart_conf_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpi__uart__conf.html">pi_uart_conf</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to get default values for all parameters before setting some of them. The structure containing the configuration must be kept alive until the uart device is opened.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>A pointer to the uart configuration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga21def19994b46489a8ffa4cf030e9794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21def19994b46489a8ffa4cf030e9794">&#9670;&nbsp;</a></span>pi_uart_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_uart_open </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function must be called before the UART device can be used. It will do all the needed configuration to make it usable and initialize the handle used to refer to this opened device when calling other functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the device structure of the device to open. This structure is allocated by the called and must be kept alive until the device is closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

</div>
</div>
<a id="gaa902ab4ee7d2023375e1319d4ad1a51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa902ab4ee7d2023375e1319d4ad1a51e">&#9670;&nbsp;</a></span>pi_uart_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_uart_read </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This reads data from the specified UART. The caller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the UART device on which to do the copy. </td></tr>
    <tr><td class="paramname">buffer</td><td>The address of the data in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

</div>
</div>
<a id="gada5035f9fd4b858f8326c8b30d254e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada5035f9fd4b858f8326c8b30d254e56">&#9670;&nbsp;</a></span>pi_uart_read_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_uart_read_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This reads data from the specified UART asynchronously. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the UART device on which to do the copy. </td></tr>
    <tr><td class="paramname">buffer</td><td>The address of the data in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy. </td></tr>
    <tr><td class="paramname">callback</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

</div>
</div>
<a id="ga01778d12b41a16cf0c6e61161b854a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01778d12b41a16cf0c6e61161b854a3e">&#9670;&nbsp;</a></span>pi_uart_read_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_uart_read_byte </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This reads a byte from the specified UART. The caller is blocked until the transfer is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the UART device on which to do the copy. </td></tr>
    <tr><td class="paramname">byte</td><td>A pointer to the byte where the data should be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

</div>
</div>
<a id="ga953a8ceefcc5a33871dd32c4d9a9ef35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga953a8ceefcc5a33871dd32c4d9a9ef35">&#9670;&nbsp;</a></span>pi_uart_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_uart_write </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This writes data to the specified UART. The caller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the UART device on which to do the copy. </td></tr>
    <tr><td class="paramname">buffer</td><td>The address of the data in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

</div>
</div>
<a id="gae27ad3c7ffe2bc97c251a833189d2121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae27ad3c7ffe2bc97c251a833189d2121">&#9670;&nbsp;</a></span>pi_uart_write_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_uart_write_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This writes data to the specified UART asynchronously. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the UART device on which to do the copy. </td></tr>
    <tr><td class="paramname">buffer</td><td>The address of the data in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy. </td></tr>
    <tr><td class="paramname">callback</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

</div>
</div>
<a id="ga47076425f15e54cc170f32259fddcca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47076425f15e54cc170f32259fddcca6">&#9670;&nbsp;</a></span>pi_uart_write_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_uart_write_byte </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This writes a byte to the specified UART. The caller is blocked until the transfer is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the UART device on which to do the copy. </td></tr>
    <tr><td class="paramname">byte</td><td>A pointer to the byte which should be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

</div>
</div>
<a id="ga5a32e4b740d4949371ed44c564f640c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a32e4b740d4949371ed44c564f640c7">&#9670;&nbsp;</a></span>pi_uart_write_byte_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_uart_write_byte_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This writes a byte to the specified UART asynchronously. A task must be specified in order to specify how the caller should be notified when the transfer is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the UART device on which to do the copy. </td></tr>
    <tr><td class="paramname">byte</td><td>A pointer to the byte which should be written. </td></tr>
    <tr><td class="paramname">callback</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jan 24 2020 12:47:55 for  by GreenWaves Technologies
	<!--
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 
	-->
	</li>
  </ul>
</div>
</body>
</html>
