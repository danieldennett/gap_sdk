<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Arm® Mbed™ OS Porting Manual for GAP8</title>
<title>Arm® Mbed™ OS Porting Manual for GAP8</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="pulp.css" rel="stylesheet" type="text/css" />
<link href="gap.css" rel="stylesheet" type="text/css" />
<link href="images.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="printComponentTabs.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="titlerow">
  <td id="projectlogo"><img alt="Logo" src="gap-logo-55.png" /></td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">Port of Arm® Mbed™ OS / CMSIS to GAP8/RISC-V</div>
    </td>
  <td id="extralogo"><img alt="GreenWaves" src="greenwaves-logo-55.png" /></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="CMSISnav" class="tabs1">
    <ul class="tablist">
      <script type="text/javascript">
		<!--
		writeComponentTabs.call(this);
		//-->
      </script>
	  </ul>
</div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Arm® Mbed™ OS Porting Manual for GAP8 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="section0"></a>
Introduction</h1>
<p>Arm® Mbed™ OS is an open source embedded operating system designed specifically for the "things" in the Internet of Things developed by Arm for the Cortex-M series of micro-controllers. It includes all the features you need to develop a connected product including security, connectivity, an RTOS and drivers for sensors and I/O devices.</p>
<p>GreenWaves has ported Mbed OS to the RISC-V based GAP8 IoT Application Processor.</p>
<h1><a class="anchor" id="section1"></a>
Porting Arm® Mbed™ OS to GAP8</h1>
<p>Arm® Mbed™ OS is based on Cortex Micro-controller Software Interface Standard (CMSIS) which provides a ground-up software framework for embedded applications that run on Cortex-M based micro-controllers. CMSIS was started in 2008 and the initiative is in close cooperation with various silicon and software vendors. CMSIS enables consistent and simple software interfaces to the processor and the peripherals, simplifying software reuse and reducing the learning curve for micro-controller developers.</p>
<p>GreenWaves Technologies has ported Arm® Mbed™ OS to help developers familiar with CMSIS shorten the time spent developing and deploying applications onto GAP8. Included in the port are the CMSIS-HAL, CMSIS-Driver and CMSIS-RTOS API sets. The GAP8 port is released under the same open source license as Arm® Mbed™ OS. The included GAP8 CMSIS implementation can also be used as a basis for ports of other RTOS's to GAP8.</p>
<h1><a class="anchor" id="section2"></a>
Introduction</h1>
<p>Here is the global software struct of the Arm® Mbed™ OS, from now we provide developpers all resources except communication interfaces (under developing and testing). </p><div class="image">
<img src="images/mbed_os_stack.png" alt="Mbed OS stack"/>
</div>
<p>The mbed library provides abstractions for the microcontroller (MCU) hardware (in particular drivers for the MCU peripherals) and it is divided in the following <a href="https://os.mbed.com/handbook/mbed-library-internals">software layers and APIs</a>: </p><div class="image">
<img src="images/mbed_layers.png" alt="Mbed layer"/>
</div>
<p> To port the mbed library to a GAP8, we provide the two software layers marked as "MCU dependent" and one basic software layer for RISC-V 32-bit based "MCU Registers" in the above diagram. So if users are also interested in othe RTOS like freeRTOS, you can reuse the three lowest layers to your own project. In addiction, you can even reuse the "MCU Registers" for other RISC-V 32-bit based MCU like (SIFIVE E310).</p>
<h2><a class="anchor" id="section3"></a>
Porting details</h2>
<h3><a href="https://docs.mbed.com/docs/mbed-os-handbook/en/5.1/concepts/memory_model/">Memory model</a></h3>
<p>As we can see in the gap8 architectrue below, it has three main memories:</p><ul>
<li>Shared L1 TCDM (right side in the CLUSTER domain) with one cycles access time, start address is 0x10000000, 64KB;</li>
<li>Shared L2 RAM (left side above in the SoC domain) with several cycles access time, start address is 0x1C000000, 512KB;</li>
<li>FC L1 TCDM (left side below in the SoC domain) with one cycles access time, start address is 0x1B000000, 16KB. <div class="image">
<img src="images/gap8_archi.png" alt="GAP8 architecture"/>
</div>
</li>
</ul>
<p>To use the heap of these memory space: </p><table class="doxtable">
<tr>
<th>Memory Type </th><th>Allocator </th><th>De-Allocator  </th></tr>
<tr>
<td>L1 TCDM </td><td>void* L1_Malloc(size_t size) </td><td>void L1_Free(void &lt;em&gt;ptr) </td></tr>
<tr>
<td>FC TCDM </td><td>void FC_Malloc(size_t size) </td><td>void FC_Free(void &lt;em&gt;ptr) </td></tr>
<tr>
<td>L2 RAM </td><td>void malloc (size_t size) </td><td>void free (void* ptr); </td></tr>
</table>
<p>So how to use these memory resources in Arm® Mbed™ OS to create an efficient software system is our objective, here we give a suggestion for each thread stack configuration for OS.</p>
<table class="doxtable">
<tr>
<th>STACK </th><th>Memory Type  </th></tr>
<tr>
<td>L1_each_core_stack </td><td>L1 TCDM </td></tr>
<tr>
<td>OS_stack </td><td>FC TCDM </td></tr>
<tr>
<td>Main_thread_stack </td><td>FC TCDM </td></tr>
<tr>
<td>Idle_thread_stack </td><td>FC TCDM </td></tr>
<tr>
<td>Timer_thread_stack </td><td>FC TCDM </td></tr>
<tr>
<td>APP_thread_stack </td><td>L2 RAM </td></tr>
</table>
<p>So as we can see, the main thread stack is in FC TCDM, so all local variables in main thread are in FC TCDM with starting address of 0x1B00xxxx. So these variables can not seen by UDMA if you want to transfer data. Here is the examples : </p><div class="fragment"><div class="line">#include &quot;mbed.h&quot;</div><div class="line">// Read BMP280 ID</div><div class="line">I2C i2c(I2C0_SDA, I2C0_SCL);</div><div class="line"></div><div class="line">#define BMP_ADDR  0xEC;</div><div class="line"></div><div class="line">int main() {</div><div class="line"></div><div class="line">    i2c.frequency(200000);</div><div class="line"></div><div class="line">    char reg_addr;</div><div class="line">    char id;</div><div class="line"></div><div class="line">    reg_addr = 0xD0;</div><div class="line"></div><div class="line">    i2c.write(BMP_ADDR, &amp;reg_addr, 1, 1);</div><div class="line">    i2c.read(BMP_ADDR, &amp;id, 1);</div><div class="line"></div><div class="line">    printf(&quot;Read ID = %x\n&quot;, id);</div><div class="line">    return 0;</div><div class="line">}</div></div><!-- fragment --><p> This example can not pass because of <code>reg_addr</code> and <code>id</code> are local variables in main thread, so UDMA can not transfer buffer with starting address out of the range of L2 memory. So users need to put the local variables in L2 memory. By default, global variables are in L2. Here is the right way : </p><div class="fragment"><div class="line">#include &quot;mbed.h&quot;</div><div class="line">// Read BMP280 ID</div><div class="line">I2C i2c(I2C0_SDA, I2C0_SCL);</div><div class="line"></div><div class="line">#define BMP_ADDR  0xEC;</div><div class="line"></div><div class="line">GAP_L2_DATA char reg_addr;</div><div class="line">GAP_L2_DATA char id;</div><div class="line"></div><div class="line">int main() {</div><div class="line"></div><div class="line">    i2c.frequency(200000);</div><div class="line">    reg_addr = 0xD0;</div><div class="line"></div><div class="line">    i2c.write(BMP_ADDR, &amp;reg_addr, 1, 1);</div><div class="line">    i2c.read(BMP_ADDR, &amp;id, 1);</div><div class="line"></div><div class="line">    printf(&quot;Read ID = %x\n&quot;, id);</div><div class="line">    return 0;</div><div class="line">}</div></div><!-- fragment --><p> In conclusion, if users want to use L2 memory for main thread stack, you can checkout to <code>mbed-os-l2-stack</code> branch, then, you will not have this problem, but the speed and power consumption of your program will deteriorate.</p>
<h1><a class="anchor" id="section4"></a>
PINOUT</h1>
<div class="image">
<img src="images/GAPUINO_PINOUT.png" alt="GPUINO PINOUT"/>
</div>
<h1><a class="anchor" id="section5"></a>
Drivers</h1>
<h2><a class="anchor" id="section6"></a>
Drivers support situation for GAP8 (1st release)</h2>
<table class="doxtable">
<tr>
<th>Driver type </th><th>CMSIS_Driver </th><th>Mbed API (C) </th><th>Mbed API (C++) </th><th>Example  </th></tr>
<tr>
<td>LVDS </td><td>NO </td><td>- </td><td>- </td><td>NO </td></tr>
<tr>
<td>ORCA </td><td>NO </td><td>- </td><td>- </td><td>NO </td></tr>
<tr>
<td>SPIM </td><td>YES </td><td>YES </td><td>YES </td><td>YES </td></tr>
<tr>
<td>HYPERBUS </td><td>YES </td><td>YES </td><td>YES </td><td>YES </td></tr>
<tr>
<td>UART </td><td>YES </td><td>YES </td><td>YES </td><td>YES </td></tr>
<tr>
<td>I2C </td><td>YES </td><td>YES </td><td>YES </td><td>YES </td></tr>
<tr>
<td>TCDM </td><td>NO </td><td>- </td><td>- </td><td>NO </td></tr>
<tr>
<td>I2S </td><td>YES </td><td>- </td><td>- </td><td>YES </td></tr>
<tr>
<td>CPI </td><td>YES </td><td>- </td><td>- </td><td>YES </td></tr>
<tr>
<td>RTC </td><td>YES </td><td>YES </td><td>YES </td><td>YES </td></tr>
<tr>
<td>SPIS </td><td>YES </td><td>- </td><td>- </td><td>YES </td></tr>
</table>
<h2><a class="anchor" id="section7"></a>
Driver APIs' Differences</h2>
<p>In GAP8, all the external peripherals are controlled by a unit we call the micro-DMA (UDMA). This means that all transmissions are asynchronous and explicit. For example, the classic loop waiting for incoming characters from a UART cannot be used in an application running on GAP8. This causes some changes in the standard Mbed OS APIs which need to be noted.</p>
<p>1 SPI C, C++ API</p>
<p>In normal SPI transfer, users may want to control the chip select signal before and after the transfer, here is the common use in mbed:</p>
<div class="fragment"><div class="line">// Select the device by seting chip select low</div><div class="line">cs = 0;</div><div class="line"></div><div class="line">// Send 0x8f, the command to read the WHOAMI register</div><div class="line">spi.write(0x8F);</div><div class="line"></div><div class="line">// Deselect the device</div><div class="line">cs = 1;</div></div><!-- fragment --><p> However, in GAP8 transfer is controlled by UDMA through command sequences, users can choose using GPIO in C++ API to control chip select pin (except SPI0_CSN0), and we also provide users with special control function for chip select: </p><div class="fragment"><div class="line">/** Control spi master chip select status</div><div class="line"> *</div><div class="line"> *  Here we use udma to transfer data, so chip select is controled by udma</div><div class="line"> *</div><div class="line"> *  @param status Chip select high or low</div><div class="line"> *</div><div class="line"> *  @returns</div><div class="line"> *    uDMA Status</div><div class="line"> */</div><div class="line">virtual int udma_cs(int status);</div></div><!-- fragment --><p>Here is the usage example :</p>
<div class="fragment"><div class="line">// Select the device by seting chip select low</div><div class="line">spi.udma_cs(0);</div><div class="line"></div><div class="line">// Send 0x8f, the command to read the WHOAMI register</div><div class="line">spi.write(0x8F);</div><div class="line"></div><div class="line">// Deselect the device</div><div class="line">spi.udma_cs(1);</div></div><!-- fragment --><p>GAP8's SPI master 0 supports Quad-SPI mode, so we have added some extension APIs to support QSPI by using command sequence. In command sequence mode, users do not need to control chip select signal, it will control by UDMA automatically.</p>
<p>For some devices where you need polling status, GAP8 SPI and QSPI interfaces also provide an auto polling mechanism.</p>
<div class="fragment"><div class="line">/** Specify I/O width of SPI transaction (Quad SPI or not)</div><div class="line"> *</div><div class="line"> * @param[in] obj   The SPI peripheral to use for sending</div><div class="line"> * @param[in] qpi   Choose Quad SPI or normal SPI</div><div class="line"> */</div><div class="line">int spi_master_qspi(spi_t *obj, spi_qpi_t qpi);</div></div><!-- fragment --> <div class="fragment"><div class="line">/** SPI auto polling</div><div class="line"> *</div><div class="line"> * @param[in] obj   The SPI peripheral to use for sending</div><div class="line"> * @param[in] conf  The configuration of auto polling</div><div class="line"> */</div><div class="line">int spi_master_auto_polling(spi_t *obj, spi_polling_config_t *conf);</div></div><!-- fragment --> <div class="fragment"><div class="line">/** SPI blocking sequence transaction</div><div class="line"> *</div><div class="line"> * This function will create udma control sequence according to sequence configuration data</div><div class="line"> * And then do blocking transaction read or write</div><div class="line"> *</div><div class="line"> * @param[in] obj   The SPI peripheral to use for sending</div><div class="line"> * @param[in] seq   The command sequence configuration data</div><div class="line"> */</div><div class="line">int spi_master_transfer_command_sequence(spi_t *obj, spi_command_sequence_t* seq);</div></div><!-- fragment --> <h2><a class="anchor" id="section8"></a>
SPI Usage</h2>
<h3><a class="anchor" id="section9"></a>
Example 1</h3>
<div class="image">
<img src="images/single_write_non_qpi.png" alt="single write non qpi"/>
</div>
 <div class="fragment"><div class="line">spi.udma_cs(0);</div><div class="line">spi.write(0x06);</div><div class="line">spi.udma_cs(1);</div></div><!-- fragment --><p> or </p><div class="fragment"><div class="line">spi_command_sequence_t sequence;</div><div class="line"></div><div class="line">// Initialize sequence structure to 0</div><div class="line">memset(&amp;sequence, 0, sizeof(spi_command_sequence_t));</div><div class="line">sequence.cmd       = 0x06;</div><div class="line">sequence.cmd_bits  = 8;</div><div class="line">sequence.cmd_mode  = uSPI_Single;</div><div class="line">spi.transfer_command_sequence(&amp;sequence);</div></div><!-- fragment --><h3><a class="anchor" id="section10"></a>
Example 2</h3>
<div class="image">
<img src="images/single_write_read_non_qpi.png" alt="single write read non qpi"/>
</div>
 <div class="fragment"><div class="line">char result;</div><div class="line"></div><div class="line">spi.udma_cs(0);</div><div class="line">spi.write(0x06);</div><div class="line">result = spi.write(0x00);</div><div class="line">spi.udma_cs(1);</div></div><!-- fragment --><p> or </p><div class="fragment"><div class="line">spi_command_sequence_t sequence;</div><div class="line">char result;</div><div class="line"></div><div class="line">// Initialize sequence structure to 0</div><div class="line">memset(&amp;sequence, 0, sizeof(spi_command_sequence_t));</div><div class="line">sequence.cmd       = 0x06;</div><div class="line">sequence.cmd_bits  = 8;</div><div class="line">sequence.cmd_mode  = uSPI_Single;</div><div class="line">sequence.rx_bits   = 8;</div><div class="line">sequence.rx_buffer = (uint8_t *)&amp;result;</div><div class="line">sequence.data_mode = uSPI_Single;</div><div class="line"></div><div class="line">spi.transfer_command_sequence(&amp;sequence);</div></div><!-- fragment --><h3><a class="anchor" id="section11"></a>
Example 3</h3>
<div class="image">
<img src="images/single_write_multi_read_non_qpi.png" alt="single write multiple read non qpi"/>
</div>
 <div class="fragment"><div class="line">char result[2];</div><div class="line"></div><div class="line">spi.udma_cs(0);</div><div class="line">spi.write(0x06);</div><div class="line">result[0] = spi.write(0x00);</div><div class="line">result[1] = spi.write(0x00);</div><div class="line">spi.udma_cs(1);</div></div><!-- fragment --><p> or </p><div class="fragment"><div class="line">spi_command_sequence_t sequence;</div><div class="line">char result[2];</div><div class="line"></div><div class="line">// Initialize sequence structure to 0</div><div class="line">memset(&amp;sequence, 0, sizeof(spi_command_sequence_t));</div><div class="line">sequence.cmd       = 0x06;</div><div class="line">sequence.cmd_bits  = 8;</div><div class="line">sequence.cmd_mode  = uSPI_Single;</div><div class="line">sequence.rx_bits   = 8 * 2;</div><div class="line">sequence.rx_buffer = (uint8_t *)&amp;result;</div><div class="line">sequence.data_mode = uSPI_Single;</div><div class="line"></div><div class="line">spi.transfer_command_sequence(&amp;sequence);</div></div><!-- fragment --><h3><a class="anchor" id="section12"></a>
Example 4</h3>
<div class="image">
<img src="images/single_write_qpi.png" alt="single write qpi"/>
</div>
<div class="fragment"><div class="line">/** Control spi master QSPI</div><div class="line"> *</div><div class="line"> *  Here we use udma to transfer data, so we can set to use qspi or not.</div><div class="line"> *</div><div class="line"> *  @param status Use or not use QSPI</div><div class="line"> *</div><div class="line"> */</div><div class="line">virtual void udma_qspi(int status);</div></div><!-- fragment --><div class="fragment"><div class="line">spi.udma_qpsi(1);</div><div class="line"></div><div class="line">spi.udma_cs(0);</div><div class="line">spi.write(0x06);</div><div class="line">spi.udma_cs(1);</div></div><!-- fragment --><p> or </p><div class="fragment"><div class="line">spi_command_sequence_t sequence;</div><div class="line"></div><div class="line">// Initialize sequence structure to 0</div><div class="line">memset(&amp;sequence, 0, sizeof(spi_command_sequence_t));</div><div class="line">sequence.cmd       = 0x06;</div><div class="line">sequence.cmd_bits  = 8;</div><div class="line">sequence.cmd_mode  = uSPI_Quad;</div><div class="line"></div><div class="line">spi.transfer_command_sequence(&amp;sequence);</div></div><!-- fragment --><h3><a class="anchor" id="section13"></a>
Example 5</h3>
<div class="image">
<img src="images/single_write_32_qpi.png" alt="single write 32 qpi"/>
</div>
 <div class="fragment"><div class="line">char result[4];</div><div class="line"></div><div class="line">spi.udma_qpsi(1);</div><div class="line"></div><div class="line">spi.udma_cs(0);</div><div class="line">spi.write(result[0]);</div><div class="line">spi.write(result[1]);</div><div class="line">spi.write(result[2]);</div><div class="line">spi.write(result[3]);</div><div class="line">spi.udma_cs(1);</div></div><!-- fragment --><p> or </p><div class="fragment"><div class="line">spi_command_sequence_t sequence;</div><div class="line">char result[4];</div><div class="line"></div><div class="line">// Initialize sequence structure to 0</div><div class="line">memset(&amp;sequence, 0, sizeof(spi_command_sequence_t));</div><div class="line">sequence.tx_bits    = 32;</div><div class="line">sequence.tx_data    = (result[0] &lt;&lt; 24) | (result[1] &lt;&lt; 16) | (result[2] &lt;&lt; 8) | (result[3]);</div><div class="line">sequence.data_mode = uSPI_Quad;</div><div class="line"></div><div class="line">spi.transfer_command_sequence(&amp;sequence);</div></div><!-- fragment --><h3><a class="anchor" id="section14"></a>
Example 6</h3>
<div class="image">
<img src="images/single_write_read_qpi.png" alt="single write read qpi"/>
</div>
 <div class="fragment"><div class="line">char result;</div><div class="line"></div><div class="line">spi.udma_qpsi(1);</div><div class="line"></div><div class="line">spi.udma_cs(0);</div><div class="line">spi.write(0x06);</div><div class="line">result = spi.write(0x00);</div><div class="line">spi.udma_cs(1);</div></div><!-- fragment --><p> or </p><div class="fragment"><div class="line">spi_command_sequence_t sequence;</div><div class="line">char result;</div><div class="line"></div><div class="line">// Initialize sequence structure to 0</div><div class="line">memset(&amp;sequence, 0, sizeof(spi_command_sequence_t));</div><div class="line">sequence.cmd       = 0x06;</div><div class="line">sequence.cmd_bits  = 8;</div><div class="line">sequence.cmd_mode  = uSPI_Quad;</div><div class="line">sequence.rx_bits   = 8;</div><div class="line">sequence.rx_buffer = (uint8_t *)&amp;result;</div><div class="line">sequence.data_mode = uSPI_Quad;</div><div class="line"></div><div class="line">spi.transfer_command_sequence(&amp;sequence);</div></div><!-- fragment --><h3><a class="anchor" id="section15"></a>
Example 7</h3>
<div class="image">
<img src="images/single_write_complex_read_qpi.png" alt="single write complex read qpi"/>
</div>
 <div class="fragment"><div class="line">char addr[4];</div><div class="line">char result[4];</div><div class="line"></div><div class="line">spi.udma_qpsi(1);</div><div class="line"></div><div class="line">spi.udma_cs(0);</div><div class="line">spi.write(addr[3]);</div><div class="line">spi.write(addr[2]);</div><div class="line">spi.write(addr[1]);</div><div class="line">spi.write(addr[0]);</div><div class="line"></div><div class="line">// Mode</div><div class="line">spi.write(0x00);</div><div class="line"></div><div class="line">// Dummy 6 cycles</div><div class="line">spi.write(0x00);</div><div class="line">spi.write(0x00);</div><div class="line">spi.write(0x00);</div><div class="line"></div><div class="line">result[0] = spi.write(0x00);</div><div class="line">result[1] = spi.write(0x00);</div><div class="line">result[2] = spi.write(0x00);</div><div class="line">result[3] = spi.write(0x00);</div><div class="line">spi.udma_cs(1);</div></div><!-- fragment --><p> or </p><div class="fragment"><div class="line">spi_command_sequence_t sequence;</div><div class="line">int addr;</div><div class="line">char result[4];</div><div class="line"></div><div class="line">// Initialize sequence structure to 0</div><div class="line">memset(&amp;sequence, 0, sizeof(spi_command_sequence_t));</div><div class="line">sequence.addr_bits = 32;</div><div class="line">sequence.addr      = addr;</div><div class="line">sequence.addr_mode = uSPI_Quad;</div><div class="line"></div><div class="line">// Mode</div><div class="line">sequence.alter_data      = 0x00;</div><div class="line">sequence.alter_data_bits = 8;</div><div class="line">sequence.alter_data_mode = uSPI_Quad;</div><div class="line"></div><div class="line">// Dummy 6 cycles</div><div class="line">sequence.dummy     = 6;</div><div class="line"></div><div class="line">sequence.rx_bits   = BUFFER_SIZE*8;</div><div class="line">sequence.rx_buffer = (uint8_t *)result;</div><div class="line">sequence.data_mode = uSPI_Quad;</div><div class="line"></div><div class="line">spi.transfer_command_sequence(&amp;sequence);</div></div><!-- fragment --><p>2 HYPERBUS C, C++ API</p>
<p>Cypress HyperBus Memory is a portfolio of high-speed, low-pin-count memory products that uses our HyperBus interface technology. The HyperBus interface draws upon the legacy features of both parallel and serial interface memories, while enhancing system performance, ease of design, and system cost reduction. The 12-pin, HyperBus interface operates at Double Data Rate (DDR) and can scale up to 333 MB/s throughput making it an ideal solution for automotive, industrial and IoT applications that require “instant-on” capability.</p>
<p>GAP8 uses HyperBus to support external flash and RAM memory. We have added new C and C++ APIs to allow use of HyperBus in Arm® Mbed™ OS in the /hal and /driver directories.</p>
<p>3 For all other APIs and more informations about Arm® Mbed™ OS - Please refer to the Mbed documentation at <a href="https://www.mbed.com">https://www.mbed.com</a></p>
<h1><a class="anchor" id="section16"></a>
Running an Arm® Mbed™ OS application on GAP8</h1>
<h2><a class="anchor" id="section17"></a>
TEST Support</h2>
<p>In directory ./gap_sdk/examples/mbed-examples, you can find various tests : </p><table class="doxtable">
<tr>
<th>Test type </th><th>Description  </th></tr>
<tr>
<td>test_os </td><td>Arm® Mbed™ OS C APIs tests </td></tr>
<tr>
<td>test_driver </td><td>Arm® Mbed™ OS C Driver tests </td></tr>
<tr>
<td>test_os_c++ </td><td>Arm® Mbed™ OS C++ Rtos tests </td></tr>
<tr>
<td>test_driver_c++ </td><td>Arm® Mbed™ OS C++ Driver tests </td></tr>
<tr>
<td>test_event </td><td>Arm® Mbed™ OS Event Queue C++ tests </td></tr>
<tr>
<td>test_features </td><td>Arm® Mbed™ OS Features C or C++ tests </td></tr>
<tr>
<td>test_application </td><td>Arm® Mbed™ OS GAP8 Apllications tests </td></tr>
<tr>
<td>test_autotiler </td><td>Arm® Mbed™ OS GAP8 Autotiler (CNN tools) tests </td></tr>
</table>
<h2><a class="anchor" id="section18"></a>
Two Methods to compile and run your tests</h2>
<h3><a class="anchor" id="section19"></a>
Use Makefile</h3>
<p>Change directory to an example and run as for mbed-os examples.</p>
<div class="fragment"><div class="line">cd ./gap_sdk/examples/mbed-examples/test_features/test_Cluster_HelloWorld</div><div class="line">make clean all run</div></div><!-- fragment --><p>After compilation and application load to your GAPUINO board by JTAG, Here is the result:</p>
<div class="fragment"><div class="line">Fabric controller code execution for mbed_os Cluster Power On test</div><div class="line">Hello World from cluster core 0!</div><div class="line">Hello World from cluster core 6!</div><div class="line">Hello World from cluster core 1!</div><div class="line">Hello World from cluster core 4!</div><div class="line">Hello World from cluster core 2!</div><div class="line">Hello World from cluster core 7!</div><div class="line">Hello World from cluster core 5!</div><div class="line">Hello World from cluster core 3!</div><div class="line">Test success</div><div class="line">Detected end of application, exiting with status: 0</div></div><!-- fragment --> <h3><a class="anchor" id="section20"></a>
Use uart for printf</h3>
<p>Console through uart will be triggered by flag PRINTF_UART, which should be add in the user makefile:</p>
<div class="fragment"><div class="line">MBED_FLAGS += -DPRINTF_UART=1</div></div><!-- fragment --><h3>Use <a href="https://github.com/ARMmbed/mbed-cli">Mbed CLI</a></h3>
<p>1 Download Arm® Mbed™ OS official examples.</p>
<div class="fragment"><div class="line">git clone https://github.com/ARMmbed/mbed-os-example-blinky</div></div><!-- fragment --><p> 2 Here to use our porting project, please change the mbed-os.lib</p>
<div class="fragment"><div class="line">echo https://github.com/GreenWaves-Technologies/mbed-os &gt; mbed-os.lib</div></div><!-- fragment --><p> 3 Please following <a href="https://github.com/ARMmbed/mbed-cli">Mbed CLI</a> instruction</p>
<div class="fragment"><div class="line">mbed deploy</div></div><!-- fragment --><p> 4 Compile your code, before compilation, please remember to export your compiler path, for example:</p>
<div class="fragment"><div class="line">export PATH=/usr/lib/gap_riscv_toolchain/bin:$PATH</div></div><!-- fragment --><p> Then, </p><div class="fragment"><div class="line">mbed compile -t GCC_RISCV -m GAP8</div></div><!-- fragment --><p> 5 Run with your binary in GAPUINO </p><div class="fragment"><div class="line">run_mbed ./BUILD/GAP8/GCC_RISCV/mbed-os-example-blinky.elf</div></div><!-- fragment --><p> 6 For more informations, please see <a href="https://github.com/GreenWaves-Technologies/mbed-gapuino-sensorboard">mbed-gapuino-sensorboard</a> </p>
<h1><a class="anchor" id="section21"></a>
Trademark</h1>
<p>Arm® and Arm® Mbed™ OS are registered trademarks or trademarks of Arm Limited (or its subsidiaries) in the USand/or elsewhere. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jan 24 2020 12:47:51 for  by GreenWaves Technologies
	<!--
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 
	-->
	</li>
  </ul>
</div>
</body>
</html>
