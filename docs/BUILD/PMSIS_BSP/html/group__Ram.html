<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Ram</title>
<title>Ram</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="pulp.css" rel="stylesheet" type="text/css" />
<link href="gap.css" rel="stylesheet" type="text/css" />
<link href="images.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="printComponentTabs.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="titlerow">
  <td id="projectlogo"><img alt="Logo" src="gap-logo-55.png" /></td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">PMSIS BSP</div>
    </td>
  <td id="extralogo"><img alt="GreenWaves" src="greenwaves-logo-55.png" /></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="CMSISnav" class="tabs1">
    <ul class="tablist">
      <script type="text/javascript">
		<!--
		writeComponentTabs.call(this);
		//-->
      </script>
	  </ul>
</div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__Ram.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Content</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Ram</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Content</h2></td></tr>
<tr class="memitem:group__Hyperram"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hyperram.html">Hyperram</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpi__ram__conf.html">pi_ram_conf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAM configuration structure.  <a href="structpi__ram__conf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga2feb6fca7f7d85de0c6d75294f240934"><td class="memItemLeft" align="right" valign="top">typedef struct pi_cl_ram_req_s&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#ga2feb6fca7f7d85de0c6d75294f240934">pi_cl_ram_req_t</a></td></tr>
<tr class="memdesc:ga2feb6fca7f7d85de0c6d75294f240934"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAM cluster copy request structure.  <a href="#ga2feb6fca7f7d85de0c6d75294f240934">More...</a><br /></td></tr>
<tr class="separator:ga2feb6fca7f7d85de0c6d75294f240934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0588f3e0ddc3c00f3097d6ba194c0bd6"><td class="memItemLeft" align="right" valign="top">typedef struct pi_cl_ram_alloc_req_s&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#ga0588f3e0ddc3c00f3097d6ba194c0bd6">pi_cl_ram_alloc_req_t</a></td></tr>
<tr class="memdesc:ga0588f3e0ddc3c00f3097d6ba194c0bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAM cluster alloc request structure.  <a href="#ga0588f3e0ddc3c00f3097d6ba194c0bd6">More...</a><br /></td></tr>
<tr class="separator:ga0588f3e0ddc3c00f3097d6ba194c0bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf80e1a28610f8af451f5863e881a7d11"><td class="memItemLeft" align="right" valign="top">typedef struct pi_cl_ram_free_req_s&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#gaf80e1a28610f8af451f5863e881a7d11">pi_cl_ram_free_req_t</a></td></tr>
<tr class="memdesc:gaf80e1a28610f8af451f5863e881a7d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAM cluster free request structure.  <a href="#gaf80e1a28610f8af451f5863e881a7d11">More...</a><br /></td></tr>
<tr class="separator:gaf80e1a28610f8af451f5863e881a7d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga462bf6e0cb48890d4320bfff054bd579"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#ga462bf6e0cb48890d4320bfff054bd579">pi_ram_open</a> (struct pi_device *device)</td></tr>
<tr class="memdesc:ga462bf6e0cb48890d4320bfff054bd579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a RAM device.  <a href="#ga462bf6e0cb48890d4320bfff054bd579">More...</a><br /></td></tr>
<tr class="separator:ga462bf6e0cb48890d4320bfff054bd579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f1329ee9917ce7db6a17bb66785a02c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#ga7f1329ee9917ce7db6a17bb66785a02c">pi_ram_close</a> (struct pi_device *device)</td></tr>
<tr class="memdesc:ga7f1329ee9917ce7db6a17bb66785a02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an opened RAM device.  <a href="#ga7f1329ee9917ce7db6a17bb66785a02c">More...</a><br /></td></tr>
<tr class="separator:ga7f1329ee9917ce7db6a17bb66785a02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca76860950e783eaf4694f4c16f4057d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#gaca76860950e783eaf4694f4c16f4057d">pi_ram_alloc</a> (struct pi_device *device, uint32_t *addr, uint32_t size)</td></tr>
<tr class="memdesc:gaca76860950e783eaf4694f4c16f4057d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate RAM memory.  <a href="#gaca76860950e783eaf4694f4c16f4057d">More...</a><br /></td></tr>
<tr class="separator:gaca76860950e783eaf4694f4c16f4057d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc8e39b8161b332c11febf3c5377db04"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#gacc8e39b8161b332c11febf3c5377db04">pi_ram_free</a> (struct pi_device *device, uint32_t addr, uint32_t size)</td></tr>
<tr class="memdesc:gacc8e39b8161b332c11febf3c5377db04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free RAM memory.  <a href="#gacc8e39b8161b332c11febf3c5377db04">More...</a><br /></td></tr>
<tr class="separator:gacc8e39b8161b332c11febf3c5377db04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad143addaf51a3aa28d9694bf196c1e5b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#gad143addaf51a3aa28d9694bf196c1e5b">pi_ram_read</a> (struct pi_device *device, uint32_t pi_ram_addr, void *data, uint32_t size)</td></tr>
<tr class="memdesc:gad143addaf51a3aa28d9694bf196c1e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a read copy to the RAM (from RAM to processor).  <a href="#gad143addaf51a3aa28d9694bf196c1e5b">More...</a><br /></td></tr>
<tr class="separator:gad143addaf51a3aa28d9694bf196c1e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga135109c9732ef134123e4198c228b130"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#ga135109c9732ef134123e4198c228b130">pi_ram_write</a> (struct pi_device *device, uint32_t pi_ram_addr, void *data, uint32_t size)</td></tr>
<tr class="memdesc:ga135109c9732ef134123e4198c228b130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a write copy to the RAM (from processor to RAM).  <a href="#ga135109c9732ef134123e4198c228b130">More...</a><br /></td></tr>
<tr class="separator:ga135109c9732ef134123e4198c228b130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8a3767795a8b0cfd09e11713b910052"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#gad8a3767795a8b0cfd09e11713b910052">pi_ram_copy</a> (struct pi_device *device, uint32_t pi_ram_addr, void *data, uint32_t size, int ext2loc)</td></tr>
<tr class="memdesc:gad8a3767795a8b0cfd09e11713b910052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a copy with the RAM.  <a href="#gad8a3767795a8b0cfd09e11713b910052">More...</a><br /></td></tr>
<tr class="separator:gad8a3767795a8b0cfd09e11713b910052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c04ef9fd89cc4aaf5ae3e6b7e7b6fa6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#ga8c04ef9fd89cc4aaf5ae3e6b7e7b6fa6">pi_ram_read_2d</a> (struct pi_device *device, uint32_t pi_ram_addr, void *data, uint32_t size, uint32_t stride, uint32_t length)</td></tr>
<tr class="memdesc:ga8c04ef9fd89cc4aaf5ae3e6b7e7b6fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a 2D read copy (rectangle area) to the RAM (from RAM to processor).  <a href="#ga8c04ef9fd89cc4aaf5ae3e6b7e7b6fa6">More...</a><br /></td></tr>
<tr class="separator:ga8c04ef9fd89cc4aaf5ae3e6b7e7b6fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52b6401706d02824b1bb8c57ec51750b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#ga52b6401706d02824b1bb8c57ec51750b">pi_ram_write_2d</a> (struct pi_device *device, uint32_t pi_ram_addr, void *data, uint32_t size, uint32_t stride, uint32_t length)</td></tr>
<tr class="memdesc:ga52b6401706d02824b1bb8c57ec51750b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a 2D write copy (rectangle area) to the RAM (from processor to RAM).  <a href="#ga52b6401706d02824b1bb8c57ec51750b">More...</a><br /></td></tr>
<tr class="separator:ga52b6401706d02824b1bb8c57ec51750b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f7f5b8c7dd7f8c5306ee6c86dac48ff"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#ga4f7f5b8c7dd7f8c5306ee6c86dac48ff">pi_ram_copy_2d</a> (struct pi_device *device, uint32_t pi_ram_addr, void *data, uint32_t size, uint32_t stride, uint32_t length, int ext2loc)</td></tr>
<tr class="memdesc:ga4f7f5b8c7dd7f8c5306ee6c86dac48ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a 2D copy (rectangle area) with the RAM.  <a href="#ga4f7f5b8c7dd7f8c5306ee6c86dac48ff">More...</a><br /></td></tr>
<tr class="separator:ga4f7f5b8c7dd7f8c5306ee6c86dac48ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga047e0f2b13c09c2bf864fd5afff48035"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#ga047e0f2b13c09c2bf864fd5afff48035">pi_ram_read_async</a> (struct pi_device *device, uint32_t pi_ram_addr, void *data, uint32_t size, pi_task_t *task)</td></tr>
<tr class="memdesc:ga047e0f2b13c09c2bf864fd5afff48035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue an asynchronous read copy to the RAM (from RAM to processor).  <a href="#ga047e0f2b13c09c2bf864fd5afff48035">More...</a><br /></td></tr>
<tr class="separator:ga047e0f2b13c09c2bf864fd5afff48035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga599e29b80f5e5571c194dce13a886085"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#ga599e29b80f5e5571c194dce13a886085">pi_ram_write_async</a> (struct pi_device *device, uint32_t pi_ram_addr, void *data, uint32_t size, pi_task_t *task)</td></tr>
<tr class="memdesc:ga599e29b80f5e5571c194dce13a886085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue an asynchronous write copy to the RAM (from processor to RAM).  <a href="#ga599e29b80f5e5571c194dce13a886085">More...</a><br /></td></tr>
<tr class="separator:ga599e29b80f5e5571c194dce13a886085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga575a67f59297e6f36fa1ad54892d3436"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#ga575a67f59297e6f36fa1ad54892d3436">pi_ram_copy_async</a> (struct pi_device *device, uint32_t pi_ram_addr, void *data, uint32_t size, int ext2loc, pi_task_t *task)</td></tr>
<tr class="memdesc:ga575a67f59297e6f36fa1ad54892d3436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue an asynchronous copy with the RAM.  <a href="#ga575a67f59297e6f36fa1ad54892d3436">More...</a><br /></td></tr>
<tr class="separator:ga575a67f59297e6f36fa1ad54892d3436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19f598119d93ac6a3a3c9463dddf2f3f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#ga19f598119d93ac6a3a3c9463dddf2f3f">pi_ram_read_2d_async</a> (struct pi_device *device, uint32_t pi_ram_addr, void *data, uint32_t size, uint32_t stride, uint32_t length, pi_task_t *task)</td></tr>
<tr class="memdesc:ga19f598119d93ac6a3a3c9463dddf2f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue an asynchronous 2D read copy (rectangle area) to the RAM (from RAM to processor).  <a href="#ga19f598119d93ac6a3a3c9463dddf2f3f">More...</a><br /></td></tr>
<tr class="separator:ga19f598119d93ac6a3a3c9463dddf2f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab61cba7fb761902029494fd524a240d6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#gab61cba7fb761902029494fd524a240d6">pi_ram_write_2d_async</a> (struct pi_device *device, uint32_t pi_ram_addr, void *data, uint32_t size, uint32_t stride, uint32_t length, pi_task_t *task)</td></tr>
<tr class="memdesc:gab61cba7fb761902029494fd524a240d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue an asynchronous 2D write copy (rectangle area) to the RAM (from processor to RAM).  <a href="#gab61cba7fb761902029494fd524a240d6">More...</a><br /></td></tr>
<tr class="separator:gab61cba7fb761902029494fd524a240d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga438fe14fea0bb37ea4379aa7fa3630a4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#ga438fe14fea0bb37ea4379aa7fa3630a4">pi_ram_copy_2d_async</a> (struct pi_device *device, uint32_t pi_ram_addr, void *data, uint32_t size, uint32_t stride, uint32_t length, int ext2loc, pi_task_t *task)</td></tr>
<tr class="memdesc:ga438fe14fea0bb37ea4379aa7fa3630a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue an asynchronous 2D copy (rectangle area) with the RAM.  <a href="#ga438fe14fea0bb37ea4379aa7fa3630a4">More...</a><br /></td></tr>
<tr class="separator:ga438fe14fea0bb37ea4379aa7fa3630a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00fc08e32a321c7aa1430db8c09e3c11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#ga00fc08e32a321c7aa1430db8c09e3c11">pi_cl_ram_alloc</a> (struct pi_device *device, uint32_t size, <a class="el" href="group__Ram.html#ga0588f3e0ddc3c00f3097d6ba194c0bd6">pi_cl_ram_alloc_req_t</a> *req)</td></tr>
<tr class="memdesc:ga00fc08e32a321c7aa1430db8c09e3c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate RAM memory from cluster side.  <a href="#ga00fc08e32a321c7aa1430db8c09e3c11">More...</a><br /></td></tr>
<tr class="separator:ga00fc08e32a321c7aa1430db8c09e3c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e53f7827bb9d1687a1f7253f58f24df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#ga5e53f7827bb9d1687a1f7253f58f24df">pi_cl_ram_free</a> (struct pi_device *device, uint32_t chunk, uint32_t size, <a class="el" href="group__Ram.html#gaf80e1a28610f8af451f5863e881a7d11">pi_cl_ram_free_req_t</a> *req)</td></tr>
<tr class="memdesc:ga5e53f7827bb9d1687a1f7253f58f24df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free RAM memory from cluster side.  <a href="#ga5e53f7827bb9d1687a1f7253f58f24df">More...</a><br /></td></tr>
<tr class="separator:ga5e53f7827bb9d1687a1f7253f58f24df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27267fb293b25c04726d6fde92c9cd4d"><td class="memItemLeft" align="right" valign="top">static int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#ga27267fb293b25c04726d6fde92c9cd4d">pi_cl_ram_alloc_wait</a> (<a class="el" href="group__Ram.html#ga0588f3e0ddc3c00f3097d6ba194c0bd6">pi_cl_ram_alloc_req_t</a> *req, uint32_t *addr)</td></tr>
<tr class="memdesc:ga27267fb293b25c04726d6fde92c9cd4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the specified RAM alloc request has finished.  <a href="#ga27267fb293b25c04726d6fde92c9cd4d">More...</a><br /></td></tr>
<tr class="separator:ga27267fb293b25c04726d6fde92c9cd4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacee72f594aeb0400373d0ab0e660baef"><td class="memItemLeft" align="right" valign="top">static int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#gacee72f594aeb0400373d0ab0e660baef">pi_cl_ram_free_wait</a> (<a class="el" href="group__Ram.html#gaf80e1a28610f8af451f5863e881a7d11">pi_cl_ram_free_req_t</a> *req)</td></tr>
<tr class="memdesc:gacee72f594aeb0400373d0ab0e660baef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the specified RAM free request has finished.  <a href="#gacee72f594aeb0400373d0ab0e660baef">More...</a><br /></td></tr>
<tr class="separator:gacee72f594aeb0400373d0ab0e660baef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50aa1cc80002e896746d63bb4382a66b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#ga50aa1cc80002e896746d63bb4382a66b">pi_cl_ram_read</a> (struct pi_device *device, uint32_t pi_ram_addr, void *addr, uint32_t size, <a class="el" href="group__Ram.html#ga2feb6fca7f7d85de0c6d75294f240934">pi_cl_ram_req_t</a> *req)</td></tr>
<tr class="memdesc:ga50aa1cc80002e896746d63bb4382a66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a read copy to the RAM from cluster side (from RAM to processor).  <a href="#ga50aa1cc80002e896746d63bb4382a66b">More...</a><br /></td></tr>
<tr class="separator:ga50aa1cc80002e896746d63bb4382a66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga741e392ce816ecd0471fc5afead003be"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#ga741e392ce816ecd0471fc5afead003be">pi_cl_ram_write</a> (struct pi_device *device, uint32_t pi_ram_addr, void *addr, uint32_t size, <a class="el" href="group__Ram.html#ga2feb6fca7f7d85de0c6d75294f240934">pi_cl_ram_req_t</a> *req)</td></tr>
<tr class="memdesc:ga741e392ce816ecd0471fc5afead003be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a write copy to the RAM from cluster side (from RAM to processor).  <a href="#ga741e392ce816ecd0471fc5afead003be">More...</a><br /></td></tr>
<tr class="separator:ga741e392ce816ecd0471fc5afead003be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41df3f8fb3fabc5ee8f3eeabb0b61118"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#ga41df3f8fb3fabc5ee8f3eeabb0b61118">pi_cl_ram_copy</a> (struct pi_device *device, uint32_t pi_ram_addr, void *addr, uint32_t size, int ext2loc, <a class="el" href="group__Ram.html#ga2feb6fca7f7d85de0c6d75294f240934">pi_cl_ram_req_t</a> *req)</td></tr>
<tr class="memdesc:ga41df3f8fb3fabc5ee8f3eeabb0b61118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a copy with the RAM from cluster side.  <a href="#ga41df3f8fb3fabc5ee8f3eeabb0b61118">More...</a><br /></td></tr>
<tr class="separator:ga41df3f8fb3fabc5ee8f3eeabb0b61118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d988b20bf01380e2ed4bff88c313136"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#ga9d988b20bf01380e2ed4bff88c313136">pi_cl_ram_read_2d</a> (struct pi_device *device, uint32_t pi_ram_addr, void *addr, uint32_t size, uint32_t stride, uint32_t length, <a class="el" href="group__Ram.html#ga2feb6fca7f7d85de0c6d75294f240934">pi_cl_ram_req_t</a> *req)</td></tr>
<tr class="memdesc:ga9d988b20bf01380e2ed4bff88c313136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a 2D read copy (rectangle area) to the RAM from cluste side (from RAM to processor).  <a href="#ga9d988b20bf01380e2ed4bff88c313136">More...</a><br /></td></tr>
<tr class="separator:ga9d988b20bf01380e2ed4bff88c313136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc295ad6ff8f0f7f33a96ef31bc7ee84"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#gabc295ad6ff8f0f7f33a96ef31bc7ee84">pi_cl_ram_write_2d</a> (struct pi_device *device, uint32_t pi_ram_addr, void *addr, uint32_t size, uint32_t stride, uint32_t length, <a class="el" href="group__Ram.html#ga2feb6fca7f7d85de0c6d75294f240934">pi_cl_ram_req_t</a> *req)</td></tr>
<tr class="memdesc:gabc295ad6ff8f0f7f33a96ef31bc7ee84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a 2D write copy (rectangle area) to the RAM from cluster side (from RAM to processor).  <a href="#gabc295ad6ff8f0f7f33a96ef31bc7ee84">More...</a><br /></td></tr>
<tr class="separator:gabc295ad6ff8f0f7f33a96ef31bc7ee84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c7487b5296dbfdac31a948718380963"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#ga6c7487b5296dbfdac31a948718380963">pi_cl_ram_copy_2d</a> (struct pi_device *device, uint32_t pi_ram_addr, void *addr, uint32_t size, uint32_t stride, uint32_t length, int ext2loc, <a class="el" href="group__Ram.html#ga2feb6fca7f7d85de0c6d75294f240934">pi_cl_ram_req_t</a> *req)</td></tr>
<tr class="memdesc:ga6c7487b5296dbfdac31a948718380963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a 2D copy (rectangle area) with the RAM from cluster side.  <a href="#ga6c7487b5296dbfdac31a948718380963">More...</a><br /></td></tr>
<tr class="separator:ga6c7487b5296dbfdac31a948718380963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6c41de17995d3e47326a121147506cb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#gaa6c41de17995d3e47326a121147506cb">pi_cl_ram_read_wait</a> (<a class="el" href="group__Ram.html#ga2feb6fca7f7d85de0c6d75294f240934">pi_cl_ram_req_t</a> *req)</td></tr>
<tr class="memdesc:gaa6c41de17995d3e47326a121147506cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the specified RAM request has finished.  <a href="#gaa6c41de17995d3e47326a121147506cb">More...</a><br /></td></tr>
<tr class="separator:gaa6c41de17995d3e47326a121147506cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga421af58f80da2c5ec57c808c2e4bc0ea"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#ga421af58f80da2c5ec57c808c2e4bc0ea">pi_cl_ram_write_wait</a> (<a class="el" href="group__Ram.html#ga2feb6fca7f7d85de0c6d75294f240934">pi_cl_ram_req_t</a> *req)</td></tr>
<tr class="memdesc:ga421af58f80da2c5ec57c808c2e4bc0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the specified RAM request has finished.  <a href="#ga421af58f80da2c5ec57c808c2e4bc0ea">More...</a><br /></td></tr>
<tr class="separator:ga421af58f80da2c5ec57c808c2e4bc0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe3027af5307719f2a70331161343adb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ram.html#gabe3027af5307719f2a70331161343adb">pi_cl_ram_copy_wait</a> (<a class="el" href="group__Ram.html#ga2feb6fca7f7d85de0c6d75294f240934">pi_cl_ram_req_t</a> *req)</td></tr>
<tr class="memdesc:gabe3027af5307719f2a70331161343adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the specified RAM request has finished.  <a href="#gabe3027af5307719f2a70331161343adb">More...</a><br /></td></tr>
<tr class="separator:gabe3027af5307719f2a70331161343adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>The RAM driver provides support for transferring data between an external RAM chip (e.g. Hyperram or SPI ram) and the processor running this driver. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga0588f3e0ddc3c00f3097d6ba194c0bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0588f3e0ddc3c00f3097d6ba194c0bd6">&#9670;&nbsp;</a></span>pi_cl_ram_alloc_req_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct pi_cl_ram_alloc_req_s <a class="el" href="group__Ram.html#ga0588f3e0ddc3c00f3097d6ba194c0bd6">pi_cl_ram_alloc_req_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This structure is used by the runtime to manage a cluster remote allocation in the RAM. It must be instantiated once for each allocation and must be kept alive until the allocation is done. It can be instantiated as a normal variable, for example as a global variable, a local one on the stack, or through a memory allocator. </p>

</div>
</div>
<a id="gaf80e1a28610f8af451f5863e881a7d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf80e1a28610f8af451f5863e881a7d11">&#9670;&nbsp;</a></span>pi_cl_ram_free_req_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct pi_cl_ram_free_req_s <a class="el" href="group__Ram.html#gaf80e1a28610f8af451f5863e881a7d11">pi_cl_ram_free_req_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This structure is used by the runtime to manage a cluster remote free in the RAM. It must be instantiated once for each free and must be kept alive until the free is done. It can be instantiated as a normal variable, for example as a global variable, a local one on the stack, or through a memory allocator. </p>

</div>
</div>
<a id="ga2feb6fca7f7d85de0c6d75294f240934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2feb6fca7f7d85de0c6d75294f240934">&#9670;&nbsp;</a></span>pi_cl_ram_req_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct pi_cl_ram_req_s <a class="el" href="group__Ram.html#ga2feb6fca7f7d85de0c6d75294f240934">pi_cl_ram_req_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This structure is used by the runtime to manage a cluster remote copy with the RAM. It must be instantiated once for each copy and must be kept alive until the copy is finished. It can be instantiated as a normal variable, for example as a global variable, a local one on the stack, or through a memory allocator. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga00fc08e32a321c7aa1430db8c09e3c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00fc08e32a321c7aa1430db8c09e3c11">&#9670;&nbsp;</a></span>pi_cl_ram_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_cl_ram_alloc </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Ram.html#ga0588f3e0ddc3c00f3097d6ba194c0bd6">pi_cl_ram_alloc_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is a remote call that the cluster can do to the fabric-controller in order to ask for a RAM allocation. The allocated memory is 4-bytes aligned. The allocator uses some meta-data stored in the fabric controller memory for every allocation so it is advisable to do as few allocations as possible to lower the memory overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the RAM chip for which the memory must be allocated. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the memory to allocate. </td></tr>
    <tr><td class="paramname">req</td><td>The request structure used for termination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga27267fb293b25c04726d6fde92c9cd4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27267fb293b25c04726d6fde92c9cd4d">&#9670;&nbsp;</a></span>pi_cl_ram_alloc_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t pi_cl_ram_alloc_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ram.html#ga0588f3e0ddc3c00f3097d6ba194c0bd6">pi_cl_ram_alloc_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This blocks the calling core until the specified cluster RAM allocation is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>The request structure used for termination. </td></tr>
    <tr><td class="paramname">addr</td><td>A pointer to the variable where the allocated address must be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the allocation succeeded, -1 if not enough memory was available. </dd></dl>

</div>
</div>
<a id="ga41df3f8fb3fabc5ee8f3eeabb0b61118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41df3f8fb3fabc5ee8f3eeabb0b61118">&#9670;&nbsp;</a></span>pi_cl_ram_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_cl_ram_copy </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_ram_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ext2loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Ram.html#ga2feb6fca7f7d85de0c6d75294f240934">pi_cl_ram_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is a remote call that the cluster can do to the fabric-controller in order to ask for a RAM copy. The copy will make an asynchronous transfer between the RAM and one of the processor memory areas. A pointer to a request structure must be provided so that the runtime can properly do the remote call. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the RAM chip on which to do the copy. </td></tr>
    <tr><td class="paramname">pi_ram_addr</td><td>The address of the copy in the RAM. </td></tr>
    <tr><td class="paramname">addr</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
    <tr><td class="paramname">ext2loc</td><td>1 if the copy is from RAM to the chip or 0 for the contrary. </td></tr>
    <tr><td class="paramname">req</td><td>A pointer to the RAM request structure. It must be allocated by the caller and kept alive until the copy is finished. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6c7487b5296dbfdac31a948718380963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c7487b5296dbfdac31a948718380963">&#9670;&nbsp;</a></span>pi_cl_ram_copy_2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_cl_ram_copy_2d </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_ram_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ext2loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Ram.html#ga2feb6fca7f7d85de0c6d75294f240934">pi_cl_ram_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is a remote call that the cluster can do to the fabric-controller in order to ask for a RAM copy. The copy will make an asynchronous transfer between the RAM and one of the processor memory areas. A pointer to a request structure must be provided so that the runtime can properly do the remote call. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the RAM chip on which to do the copy. </td></tr>
    <tr><td class="paramname">pi_ram_addr</td><td>The address of the copy in the RAM. </td></tr>
    <tr><td class="paramname">addr</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
    <tr><td class="paramname">stride</td><td>2D stride, which is the number of bytes which are added to the beginning of the current line to switch to the next one. </td></tr>
    <tr><td class="paramname">length</td><td>2D length, which is the number of transferred bytes after which the driver will switch to the next line. </td></tr>
    <tr><td class="paramname">ext2loc</td><td>1 if the copy is from RAM to the chip or 0 for the contrary. </td></tr>
    <tr><td class="paramname">req</td><td>A pointer to the RAM request structure. It must be allocated by the caller and kept alive until the copy is finished. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabe3027af5307719f2a70331161343adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe3027af5307719f2a70331161343adb">&#9670;&nbsp;</a></span>pi_cl_ram_copy_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_cl_ram_copy_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ram.html#ga2feb6fca7f7d85de0c6d75294f240934">pi_cl_ram_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This blocks the calling core until the specified cluster remote copy is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>The request structure used for termination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5e53f7827bb9d1687a1f7253f58f24df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e53f7827bb9d1687a1f7253f58f24df">&#9670;&nbsp;</a></span>pi_cl_ram_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_cl_ram_free </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>chunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Ram.html#gaf80e1a28610f8af451f5863e881a7d11">pi_cl_ram_free_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is a remote call that the cluster can do to the fabric-controller in order to ask for a RAM allocation. The allocator does not store any information about the allocated chunks, thus the size of the allocated chunk to to be freed must be provided by the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the RAM chip for which the memory must be freed. </td></tr>
    <tr><td class="paramname">chunk</td><td>The allocated chunk to free. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the memory chunk which was allocated. </td></tr>
    <tr><td class="paramname">req</td><td>The request structure used for termination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacee72f594aeb0400373d0ab0e660baef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacee72f594aeb0400373d0ab0e660baef">&#9670;&nbsp;</a></span>pi_cl_ram_free_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t pi_cl_ram_free_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ram.html#gaf80e1a28610f8af451f5863e881a7d11">pi_cl_ram_free_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This blocks the calling core until the specified cluster RAM free is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>The request structure used for termination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation was successful, -1 otherwise </dd></dl>

</div>
</div>
<a id="ga50aa1cc80002e896746d63bb4382a66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50aa1cc80002e896746d63bb4382a66b">&#9670;&nbsp;</a></span>pi_cl_ram_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_cl_ram_read </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_ram_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Ram.html#ga2feb6fca7f7d85de0c6d75294f240934">pi_cl_ram_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is a remote call that the cluster can do to the fabric-controller in order to ask for a RAM read copy. The copy will make an asynchronous transfer between the RAM and one of the processor memory areas. A pointer to a request structure must be provided so that the runtime can properly do the remote call. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the RAM chip on which to do the copy. </td></tr>
    <tr><td class="paramname">pi_ram_addr</td><td>The address of the copy in the RAM. </td></tr>
    <tr><td class="paramname">addr</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
    <tr><td class="paramname">req</td><td>A pointer to the RAM request structure. It must be allocated by the caller and kept alive until the copy is finished. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d988b20bf01380e2ed4bff88c313136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d988b20bf01380e2ed4bff88c313136">&#9670;&nbsp;</a></span>pi_cl_ram_read_2d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_cl_ram_read_2d </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_ram_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Ram.html#ga2feb6fca7f7d85de0c6d75294f240934">pi_cl_ram_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is a remote call that the cluster can do to the fabric-controller in order to ask for a RAM read copy. The copy will make an asynchronous transfer between the RAM and one of the processor memory areas. A pointer to a request structure must be provided so that the runtime can properly do the remote call. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the RAM chip on which to do the copy. </td></tr>
    <tr><td class="paramname">pi_ram_addr</td><td>The address of the copy in the RAM. </td></tr>
    <tr><td class="paramname">addr</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy. </td></tr>
    <tr><td class="paramname">stride</td><td>2D stride, which is the number of bytes which are added to the beginning of the current line to switch to the next one. </td></tr>
    <tr><td class="paramname">length</td><td>2D length, which is the number of transferred bytes after which the driver will switch to the next line. </td></tr>
    <tr><td class="paramname">req</td><td>A pointer to the RAM request structure. It must be allocated by the caller and kept alive until the copy is finished. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa6c41de17995d3e47326a121147506cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6c41de17995d3e47326a121147506cb">&#9670;&nbsp;</a></span>pi_cl_ram_read_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_cl_ram_read_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ram.html#ga2feb6fca7f7d85de0c6d75294f240934">pi_cl_ram_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This blocks the calling core until the specified cluster remote copy is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>The request structure used for termination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga741e392ce816ecd0471fc5afead003be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga741e392ce816ecd0471fc5afead003be">&#9670;&nbsp;</a></span>pi_cl_ram_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_cl_ram_write </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_ram_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Ram.html#ga2feb6fca7f7d85de0c6d75294f240934">pi_cl_ram_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is a remote call that the cluster can do to the fabric-controller in order to ask for a RAM write copy. The copy will make an asynchronous transfer between the RAM and one of the processor memory areas. A pointer to a request structure must be provided so that the runtime can properly do the remote call. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the RAM chip on which to do the copy. </td></tr>
    <tr><td class="paramname">pi_ram_addr</td><td>The address of the copy in the RAM. </td></tr>
    <tr><td class="paramname">addr</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
    <tr><td class="paramname">req</td><td>A pointer to the RAM request structure. It must be allocated by the caller and kept alive until the copy is finished. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabc295ad6ff8f0f7f33a96ef31bc7ee84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc295ad6ff8f0f7f33a96ef31bc7ee84">&#9670;&nbsp;</a></span>pi_cl_ram_write_2d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_cl_ram_write_2d </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_ram_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Ram.html#ga2feb6fca7f7d85de0c6d75294f240934">pi_cl_ram_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is a remote call that the cluster can do to the fabric-controller in order to ask for a RAM write copy. The copy will make an asynchronous transfer between the RAM and one of the processor memory areas. A pointer to a request structure must be provided so that the runtime can properly do the remote call. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the RAM chip on which to do the copy. </td></tr>
    <tr><td class="paramname">pi_ram_addr</td><td>The address of the copy in the RAM. </td></tr>
    <tr><td class="paramname">addr</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
    <tr><td class="paramname">stride</td><td>2D stride, which is the number of bytes which are added to the beginning of the current line to switch to the next one. </td></tr>
    <tr><td class="paramname">length</td><td>2D length, which is the number of transferred bytes after which the driver will switch to the next line. </td></tr>
    <tr><td class="paramname">req</td><td>A pointer to the RAM request structure. It must be allocated by the caller and kept alive until the copy is finished. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga421af58f80da2c5ec57c808c2e4bc0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga421af58f80da2c5ec57c808c2e4bc0ea">&#9670;&nbsp;</a></span>pi_cl_ram_write_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_cl_ram_write_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ram.html#ga2feb6fca7f7d85de0c6d75294f240934">pi_cl_ram_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This blocks the calling core until the specified cluster remote copy is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>The request structure used for termination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaca76860950e783eaf4694f4c16f4057d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca76860950e783eaf4694f4c16f4057d">&#9670;&nbsp;</a></span>pi_ram_alloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int pi_ram_alloc </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The allocated memory is 4-bytes aligned. The allocator uses some meta-data stored in the chip memory for every allocation so it is advisable to do as few allocations as possible to lower the memory overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device structure of the device where to allocate the memory. </td></tr>
    <tr><td class="paramname">addr</td><td>A pointer to the variable where the allocated address must be returned. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the memory to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the allocation succeeded, -1 if not enough memory was available. </dd></dl>

</div>
</div>
<a id="ga7f1329ee9917ce7db6a17bb66785a02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f1329ee9917ce7db6a17bb66785a02c">&#9670;&nbsp;</a></span>pi_ram_close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_ram_close </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function can be called to close an opened RAM device once it is not needed anymore, in order to free all allocated resources. Once this function is called, the device is not accessible anymore and must be opened again before being used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device structure of the device to close. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad8a3767795a8b0cfd09e11713b910052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8a3767795a8b0cfd09e11713b910052">&#9670;&nbsp;</a></span>pi_ram_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_ram_copy </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_ram_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ext2loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy will make a transfer between the RAM and one of the processor memory areas. The calller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the RAM chip on which to do the copy. </td></tr>
    <tr><td class="paramname">pi_ram_addr</td><td>The address of the copy in the RAM. </td></tr>
    <tr><td class="paramname">data</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
    <tr><td class="paramname">ext2loc</td><td>1 if the copy is from RAM to the chip or 0 for the contrary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4f7f5b8c7dd7f8c5306ee6c86dac48ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f7f5b8c7dd7f8c5306ee6c86dac48ff">&#9670;&nbsp;</a></span>pi_ram_copy_2d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_ram_copy_2d </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_ram_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ext2loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy will make a transfer between the RAM and one of the processor memory areas. The calller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the RAM chip on which to do the copy. </td></tr>
    <tr><td class="paramname">pi_ram_addr</td><td>The address of the copy in the RAM. </td></tr>
    <tr><td class="paramname">data</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
    <tr><td class="paramname">stride</td><td>2D stride, which is the number of bytes which are added to the beginning of the current line to switch to the next one. </td></tr>
    <tr><td class="paramname">length</td><td>2D length, which is the number of transferred bytes after which the driver will switch to the next line. </td></tr>
    <tr><td class="paramname">ext2loc</td><td>1 if the copy is from RAM to the chip or 0 for the contrary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga438fe14fea0bb37ea4379aa7fa3630a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga438fe14fea0bb37ea4379aa7fa3630a4">&#9670;&nbsp;</a></span>pi_ram_copy_2d_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_ram_copy_2d_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_ram_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ext2loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy will make an asynchronous transfer between the RAM and one of the processor memory areas. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the RAM chip on which to do the copy. </td></tr>
    <tr><td class="paramname">pi_ram_addr</td><td>The address of the copy in the RAM. </td></tr>
    <tr><td class="paramname">data</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
    <tr><td class="paramname">stride</td><td>2D stride, which is the number of bytes which are added to the beginning of the current line to switch to the next one. </td></tr>
    <tr><td class="paramname">length</td><td>2D length, which is the number of transferred bytes after which the driver will switch to the next line. </td></tr>
    <tr><td class="paramname">ext2loc</td><td>1 if the copy is from RAM to the chip or 0 for the contrary. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga575a67f59297e6f36fa1ad54892d3436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga575a67f59297e6f36fa1ad54892d3436">&#9670;&nbsp;</a></span>pi_ram_copy_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_ram_copy_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_ram_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ext2loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy will make an asynchronous transfer between the RAM and one of the processor memory areas. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the RAM chip on which to do the copy. </td></tr>
    <tr><td class="paramname">pi_ram_addr</td><td>The address of the copy in the RAM. </td></tr>
    <tr><td class="paramname">data</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
    <tr><td class="paramname">ext2loc</td><td>1 if the copy is from RAM to the chip or 0 for the contrary. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacc8e39b8161b332c11febf3c5377db04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc8e39b8161b332c11febf3c5377db04">&#9670;&nbsp;</a></span>pi_ram_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int pi_ram_free </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The allocator does not store any information about the allocated chunks, thus the size of the allocated chunk to to be freed must be provided by the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device structure of the device where to free the memory. </td></tr>
    <tr><td class="paramname">addr</td><td>The allocated chunk to free </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the memory chunk which was allocated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation was successful, -1 otherwise </dd></dl>

</div>
</div>
<a id="ga462bf6e0cb48890d4320bfff054bd579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga462bf6e0cb48890d4320bfff054bd579">&#9670;&nbsp;</a></span>pi_ram_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pi_ram_open </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function must be called before the RAM device can be used. It will do all the needed configuration to make it usable and initialize the handle used to refer to this opened device when calling other functions. The configuration associated to the device must specify the exact model of RAM which must be opened.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the device structure of the device to open. This structure is allocated by the called and must be kept alive until the device is closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

</div>
</div>
<a id="gad143addaf51a3aa28d9694bf196c1e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad143addaf51a3aa28d9694bf196c1e5b">&#9670;&nbsp;</a></span>pi_ram_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_ram_read </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_ram_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy will make a transfer between the RAM and one of the processor memory areas. The caller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the RAM chip on which to do the copy. </td></tr>
    <tr><td class="paramname">pi_ram_addr</td><td>The address of the copy in the RAM. </td></tr>
    <tr><td class="paramname">data</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8c04ef9fd89cc4aaf5ae3e6b7e7b6fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c04ef9fd89cc4aaf5ae3e6b7e7b6fa6">&#9670;&nbsp;</a></span>pi_ram_read_2d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_ram_read_2d </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_ram_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy will make a transfer between the RAM and one of the processor memory areas. The calller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the RAM chip on which to do the copy. </td></tr>
    <tr><td class="paramname">pi_ram_addr</td><td>The address of the copy in the RAM. </td></tr>
    <tr><td class="paramname">data</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
    <tr><td class="paramname">stride</td><td>2D stride, which is the number of bytes which are added to the beginning of the current line to switch to the next one. </td></tr>
    <tr><td class="paramname">length</td><td>2D length, which is the number of transferred bytes after which the driver will switch to the next line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga19f598119d93ac6a3a3c9463dddf2f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19f598119d93ac6a3a3c9463dddf2f3f">&#9670;&nbsp;</a></span>pi_ram_read_2d_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_ram_read_2d_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_ram_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy will make an asynchronous transfer between the RAM and one of the processor memory areas. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the RAM chip on which to do the copy. </td></tr>
    <tr><td class="paramname">pi_ram_addr</td><td>The address of the copy in the RAM. </td></tr>
    <tr><td class="paramname">data</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
    <tr><td class="paramname">stride</td><td>2D stride, which is the number of bytes which are added to the beginning of the current line to switch to the next one. </td></tr>
    <tr><td class="paramname">length</td><td>2D length, which is the number of transferred bytes after which the driver will switch to the next line. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga047e0f2b13c09c2bf864fd5afff48035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga047e0f2b13c09c2bf864fd5afff48035">&#9670;&nbsp;</a></span>pi_ram_read_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_ram_read_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_ram_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy will make an asynchronous transfer between the RAM and one of the processor memory areas. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the RAM chip on which to do the copy. </td></tr>
    <tr><td class="paramname">pi_ram_addr</td><td>The address of the copy in the RAM. </td></tr>
    <tr><td class="paramname">data</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga135109c9732ef134123e4198c228b130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga135109c9732ef134123e4198c228b130">&#9670;&nbsp;</a></span>pi_ram_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_ram_write </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_ram_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy will make a transfer between the RAM and one of the processor memory areas. The calller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the RAM chip on which to do the copy. </td></tr>
    <tr><td class="paramname">pi_ram_addr</td><td>The address of the copy in the RAM. </td></tr>
    <tr><td class="paramname">data</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga52b6401706d02824b1bb8c57ec51750b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52b6401706d02824b1bb8c57ec51750b">&#9670;&nbsp;</a></span>pi_ram_write_2d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_ram_write_2d </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_ram_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy will make a transfer between the RAM and one of the processor memory areas. The calller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the RAM chip on which to do the copy. </td></tr>
    <tr><td class="paramname">pi_ram_addr</td><td>The address of the copy in the RAM. </td></tr>
    <tr><td class="paramname">data</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
    <tr><td class="paramname">stride</td><td>2D stride, which is the number of bytes which are added to the beginning of the current line to switch to the next one. </td></tr>
    <tr><td class="paramname">length</td><td>2D length, which is the number of transferred bytes after which the driver will switch to the next line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab61cba7fb761902029494fd524a240d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab61cba7fb761902029494fd524a240d6">&#9670;&nbsp;</a></span>pi_ram_write_2d_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_ram_write_2d_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_ram_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy will make an asynchronous transfer between the RAM and one of the processor memory areas. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the RAM chip on which to do the copy. </td></tr>
    <tr><td class="paramname">pi_ram_addr</td><td>The address of the copy in the RAM. </td></tr>
    <tr><td class="paramname">data</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
    <tr><td class="paramname">stride</td><td>2D stride, which is the number of bytes which are added to the beginning of the current line to switch to the next one. </td></tr>
    <tr><td class="paramname">length</td><td>2D length, which is the number of transferred bytes after which the driver will switch to the next line. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga599e29b80f5e5571c194dce13a886085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga599e29b80f5e5571c194dce13a886085">&#9670;&nbsp;</a></span>pi_ram_write_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_ram_write_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pi_ram_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy will make an asynchronous transfer between the RAM and one of the processor memory areas. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the RAM chip on which to do the copy. </td></tr>
    <tr><td class="paramname">pi_ram_addr</td><td>The address of the copy in the RAM. </td></tr>
    <tr><td class="paramname">data</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jan 24 2020 12:47:55 for  by GreenWaves Technologies
	<!--
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 
	-->
	</li>
  </ul>
</div>
</body>
</html>
