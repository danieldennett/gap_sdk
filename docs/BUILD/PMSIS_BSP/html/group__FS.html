<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>File-System</title>
<title>File-System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="pulp.css" rel="stylesheet" type="text/css" />
<link href="gap.css" rel="stylesheet" type="text/css" />
<link href="images.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="printComponentTabs.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="titlerow">
  <td id="projectlogo"><img alt="Logo" src="gap-logo-55.png" /></td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">PMSIS BSP</div>
    </td>
  <td id="extralogo"><img alt="GreenWaves" src="greenwaves-logo-55.png" /></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="CMSISnav" class="tabs1">
    <ul class="tablist">
      <script type="text/javascript">
		<!--
		writeComponentTabs.call(this);
		//-->
      </script>
	  </ul>
</div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__FS.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">File-System</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpi__fs__conf.html">pi_fs_conf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">File-system configuration structure.  <a href="structpi__fs__conf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga258a0de028a4e3726b4b9c76ab1fea4a"><td class="memItemLeft" align="right" valign="top">typedef struct pi_fs_file_s&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a></td></tr>
<tr class="memdesc:ga258a0de028a4e3726b4b9c76ab1fea4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">FS file structure.  <a href="#ga258a0de028a4e3726b4b9c76ab1fea4a">More...</a><br /></td></tr>
<tr class="separator:ga258a0de028a4e3726b4b9c76ab1fea4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95630b5a598d64884dbd2a698e1a0160"><td class="memItemLeft" align="right" valign="top">typedef struct pi_cl_fs_req_s&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#ga95630b5a598d64884dbd2a698e1a0160">pi_cl_fs_req_t</a></td></tr>
<tr class="memdesc:ga95630b5a598d64884dbd2a698e1a0160"><td class="mdescLeft">&#160;</td><td class="mdescRight">FS cluster file request structure.  <a href="#ga95630b5a598d64884dbd2a698e1a0160">More...</a><br /></td></tr>
<tr class="separator:ga95630b5a598d64884dbd2a698e1a0160"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga57993aa582df128923ee14a8ecc02a1f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#ga57993aa582df128923ee14a8ecc02a1f">pi_fs_type_e</a> <tr class="memdesc:ga57993aa582df128923ee14a8ecc02a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">File-system type.  <a href="group__FS.html#ga57993aa582df128923ee14a8ecc02a1f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga57993aa582df128923ee14a8ecc02a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadac8e4c8d946cf268f3fc32aae7113d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#gaadac8e4c8d946cf268f3fc32aae7113d">pi_fs_flags_e</a> <tr class="memdesc:gaadac8e4c8d946cf268f3fc32aae7113d"><td class="mdescLeft">&#160;</td><td class="mdescRight">File-system open flags.  <a href="group__FS.html#gaadac8e4c8d946cf268f3fc32aae7113d">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gaadac8e4c8d946cf268f3fc32aae7113d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga39725b3b0a6c44d8b9e0ba649b2f5a14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#ga39725b3b0a6c44d8b9e0ba649b2f5a14">pi_fs_conf_init</a> (struct <a class="el" href="structpi__fs__conf.html">pi_fs_conf</a> *conf)</td></tr>
<tr class="memdesc:ga39725b3b0a6c44d8b9e0ba649b2f5a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a file-system configuration with default values.  <a href="#ga39725b3b0a6c44d8b9e0ba649b2f5a14">More...</a><br /></td></tr>
<tr class="separator:ga39725b3b0a6c44d8b9e0ba649b2f5a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae56a4f54bc2107d0f8d13fb5e5135056"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#gae56a4f54bc2107d0f8d13fb5e5135056">pi_fs_mount</a> (struct pi_device *device)</td></tr>
<tr class="memdesc:gae56a4f54bc2107d0f8d13fb5e5135056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mount a file-system.  <a href="#gae56a4f54bc2107d0f8d13fb5e5135056">More...</a><br /></td></tr>
<tr class="separator:gae56a4f54bc2107d0f8d13fb5e5135056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d9c1b12955e5dad34da56d5a65b1fd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#ga8d9c1b12955e5dad34da56d5a65b1fd3">pi_fs_unmount</a> (struct pi_device *device)</td></tr>
<tr class="memdesc:ga8d9c1b12955e5dad34da56d5a65b1fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmount a mounted file-system.  <a href="#ga8d9c1b12955e5dad34da56d5a65b1fd3">More...</a><br /></td></tr>
<tr class="separator:ga8d9c1b12955e5dad34da56d5a65b1fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf85d7e62086ed06598077a461dc8cc4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#gaf85d7e62086ed06598077a461dc8cc4c">pi_fs_open</a> (struct pi_device *device, const char *file, int flags)</td></tr>
<tr class="memdesc:gaf85d7e62086ed06598077a461dc8cc4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file.  <a href="#gaf85d7e62086ed06598077a461dc8cc4c">More...</a><br /></td></tr>
<tr class="separator:gaf85d7e62086ed06598077a461dc8cc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga780d8b94b737692304217568cc942689"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#ga780d8b94b737692304217568cc942689">pi_fs_close</a> (<a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *file)</td></tr>
<tr class="memdesc:ga780d8b94b737692304217568cc942689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a file.  <a href="#ga780d8b94b737692304217568cc942689">More...</a><br /></td></tr>
<tr class="separator:ga780d8b94b737692304217568cc942689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9653e745f459274649e1d82d3d427c13"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#ga9653e745f459274649e1d82d3d427c13">pi_fs_read</a> (<a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *file, void *buffer, uint32_t size)</td></tr>
<tr class="memdesc:ga9653e745f459274649e1d82d3d427c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from a file.  <a href="#ga9653e745f459274649e1d82d3d427c13">More...</a><br /></td></tr>
<tr class="separator:ga9653e745f459274649e1d82d3d427c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49964aff3141c8d9d740a159d806eb76"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#ga49964aff3141c8d9d740a159d806eb76">pi_fs_write</a> (<a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *file, void *buffer, uint32_t size)</td></tr>
<tr class="memdesc:ga49964aff3141c8d9d740a159d806eb76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to a file.  <a href="#ga49964aff3141c8d9d740a159d806eb76">More...</a><br /></td></tr>
<tr class="separator:ga49964aff3141c8d9d740a159d806eb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a8e419b1482dc113e7fd2b29ab72601"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#ga9a8e419b1482dc113e7fd2b29ab72601">pi_fs_direct_read</a> (<a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *file, void *buffer, uint32_t size)</td></tr>
<tr class="memdesc:ga9a8e419b1482dc113e7fd2b29ab72601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from a file with no intermediate cache.  <a href="#ga9a8e419b1482dc113e7fd2b29ab72601">More...</a><br /></td></tr>
<tr class="separator:ga9a8e419b1482dc113e7fd2b29ab72601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga849a3c466a0ea22e69008ff0c2947e36"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#ga849a3c466a0ea22e69008ff0c2947e36">pi_fs_seek</a> (<a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *file, unsigned int offset)</td></tr>
<tr class="memdesc:ga849a3c466a0ea22e69008ff0c2947e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reposition the current file position.  <a href="#ga849a3c466a0ea22e69008ff0c2947e36">More...</a><br /></td></tr>
<tr class="separator:ga849a3c466a0ea22e69008ff0c2947e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8733e6ad5355f3c82de8879222d402c2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#ga8733e6ad5355f3c82de8879222d402c2">pi_fs_copy</a> (<a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *file, uint32_t index, void *buffer, uint32_t size, int32_t ext2loc)</td></tr>
<tr class="memdesc:ga8733e6ad5355f3c82de8879222d402c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data between a FS file and a chip memory.  <a href="#ga8733e6ad5355f3c82de8879222d402c2">More...</a><br /></td></tr>
<tr class="separator:ga8733e6ad5355f3c82de8879222d402c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd0388d9b55d4b8d74e4aadcf981c89f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#gafd0388d9b55d4b8d74e4aadcf981c89f">pi_fs_copy_2d</a> (<a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *file, uint32_t index, void *buffer, uint32_t size, uint32_t stride, uint32_t length, int32_t ext2loc)</td></tr>
<tr class="memdesc:gafd0388d9b55d4b8d74e4aadcf981c89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a 2D copy (rectangle area) between a FS file and a chip memory.  <a href="#gafd0388d9b55d4b8d74e4aadcf981c89f">More...</a><br /></td></tr>
<tr class="separator:gafd0388d9b55d4b8d74e4aadcf981c89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cd6d6e1058861de648f4c5d7a508fd2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#ga3cd6d6e1058861de648f4c5d7a508fd2">pi_fs_read_async</a> (<a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *file, void *buffer, uint32_t size, pi_task_t *task)</td></tr>
<tr class="memdesc:ga3cd6d6e1058861de648f4c5d7a508fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from a file asynchronously.  <a href="#ga3cd6d6e1058861de648f4c5d7a508fd2">More...</a><br /></td></tr>
<tr class="separator:ga3cd6d6e1058861de648f4c5d7a508fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93352bab7a27cc99f066298262d0a4ae"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#ga93352bab7a27cc99f066298262d0a4ae">pi_fs_write_async</a> (<a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *file, void *buffer, uint32_t size, pi_task_t *task)</td></tr>
<tr class="memdesc:ga93352bab7a27cc99f066298262d0a4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to a file asynchronously.  <a href="#ga93352bab7a27cc99f066298262d0a4ae">More...</a><br /></td></tr>
<tr class="separator:ga93352bab7a27cc99f066298262d0a4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada9822cb08cab3392cc362d86f81866f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#gada9822cb08cab3392cc362d86f81866f">pi_fs_direct_read_async</a> (<a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *file, void *buffer, uint32_t size, pi_task_t *task)</td></tr>
<tr class="memdesc:gada9822cb08cab3392cc362d86f81866f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from a file with no intermediate cache asynchronously.  <a href="#gada9822cb08cab3392cc362d86f81866f">More...</a><br /></td></tr>
<tr class="separator:gada9822cb08cab3392cc362d86f81866f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5d524741ca6648d74324c95c579bfee"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#gaa5d524741ca6648d74324c95c579bfee">pi_fs_copy_async</a> (<a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *file, uint32_t index, void *buffer, uint32_t size, int32_t ext2loc, pi_task_t *task)</td></tr>
<tr class="memdesc:gaa5d524741ca6648d74324c95c579bfee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data between a FS file and a chip memory asynchronously.  <a href="#gaa5d524741ca6648d74324c95c579bfee">More...</a><br /></td></tr>
<tr class="separator:gaa5d524741ca6648d74324c95c579bfee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaac45b7202d0386599e66a1326524b46"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#gaaac45b7202d0386599e66a1326524b46">pi_fs_copy_2d_async</a> (<a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *file, uint32_t index, void *buffer, uint32_t size, uint32_t stride, uint32_t length, int32_t ext2loc, pi_task_t *task)</td></tr>
<tr class="memdesc:gaaac45b7202d0386599e66a1326524b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a 2D copy (rectangle area) between a FS file and a chip memory asynchronously.  <a href="#gaaac45b7202d0386599e66a1326524b46">More...</a><br /></td></tr>
<tr class="separator:gaaac45b7202d0386599e66a1326524b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab18e44b0b3af4444faf016c74212d9b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#gab18e44b0b3af4444faf016c74212d9b3">pi_cl_fs_read</a> (<a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *file, void *buffer, uint32_t size, <a class="el" href="group__FS.html#ga95630b5a598d64884dbd2a698e1a0160">pi_cl_fs_req_t</a> *req)</td></tr>
<tr class="memdesc:gab18e44b0b3af4444faf016c74212d9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from a file from cluster side.  <a href="#gab18e44b0b3af4444faf016c74212d9b3">More...</a><br /></td></tr>
<tr class="separator:gab18e44b0b3af4444faf016c74212d9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ddf308472c376b1a299562286690af8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#ga5ddf308472c376b1a299562286690af8">pi_cl_fs_direct_read</a> (<a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *file, void *buffer, uint32_t size, <a class="el" href="group__FS.html#ga95630b5a598d64884dbd2a698e1a0160">pi_cl_fs_req_t</a> *req)</td></tr>
<tr class="memdesc:ga5ddf308472c376b1a299562286690af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from a file with no intermediate cache from cluster side.  <a href="#ga5ddf308472c376b1a299562286690af8">More...</a><br /></td></tr>
<tr class="separator:ga5ddf308472c376b1a299562286690af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5f42b632c501e33cfb85aa00e986fd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#gad5f42b632c501e33cfb85aa00e986fd1">pi_cl_fs_seek</a> (<a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *file, uint32_t offset, <a class="el" href="group__FS.html#ga95630b5a598d64884dbd2a698e1a0160">pi_cl_fs_req_t</a> *req)</td></tr>
<tr class="memdesc:gad5f42b632c501e33cfb85aa00e986fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reposition the current file position from cluster side.  <a href="#gad5f42b632c501e33cfb85aa00e986fd1">More...</a><br /></td></tr>
<tr class="separator:gad5f42b632c501e33cfb85aa00e986fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75e2257b3526a0a50943e990559cc36d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#ga75e2257b3526a0a50943e990559cc36d">pi_cl_fs_copy</a> (<a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *file, uint32_t index, void *buffer, uint32_t size, int32_t ext2loc, <a class="el" href="group__FS.html#ga95630b5a598d64884dbd2a698e1a0160">pi_cl_fs_req_t</a> *req)</td></tr>
<tr class="memdesc:ga75e2257b3526a0a50943e990559cc36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data between a FS file and a chip memory from cluster side.  <a href="#ga75e2257b3526a0a50943e990559cc36d">More...</a><br /></td></tr>
<tr class="separator:ga75e2257b3526a0a50943e990559cc36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab918d61793528c751f8e25592467b7de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#gab918d61793528c751f8e25592467b7de">pi_cl_fs_copy_2d</a> (<a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *file, uint32_t index, void *buffer, uint32_t size, uint32_t stride, uint32_t length, int32_t ext2loc, <a class="el" href="group__FS.html#ga95630b5a598d64884dbd2a698e1a0160">pi_cl_fs_req_t</a> *req)</td></tr>
<tr class="memdesc:gab918d61793528c751f8e25592467b7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a 2D copy (rectangle area) between a FS file and a chip memory from cluster side.  <a href="#gab918d61793528c751f8e25592467b7de">More...</a><br /></td></tr>
<tr class="separator:gab918d61793528c751f8e25592467b7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00b71b4c53955965b041992deaaddc79"><td class="memItemLeft" align="right" valign="top">static int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#ga00b71b4c53955965b041992deaaddc79">pi_cl_fs_wait</a> (<a class="el" href="group__FS.html#ga95630b5a598d64884dbd2a698e1a0160">pi_cl_fs_req_t</a> *req)</td></tr>
<tr class="memdesc:ga00b71b4c53955965b041992deaaddc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the specified fs request has finished.  <a href="#ga00b71b4c53955965b041992deaaddc79">More...</a><br /></td></tr>
<tr class="separator:ga00b71b4c53955965b041992deaaddc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>The file-system driver provides support for accessing files on a flash. The following file-systems are available:</p><ul>
<li>Read-only file system. This file-system is very basic but quite-convenient to have access to input data. The open operation does not scale well when having lots of file so this file-system should only be used with few files. </li>
</ul>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga95630b5a598d64884dbd2a698e1a0160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95630b5a598d64884dbd2a698e1a0160">&#9670;&nbsp;</a></span>pi_cl_fs_req_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct pi_cl_fs_req_s <a class="el" href="group__FS.html#ga95630b5a598d64884dbd2a698e1a0160">pi_cl_fs_req_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This structure is used by the runtime to manage a cluster remote operation with the FS. It must be instantiated once for each operation and must be kept alive until the operation is finished. It can be instantiated as a normal variable, for example as a global variable, a local one on the stack, or through a memory allocator. </p>

</div>
</div>
<a id="ga258a0de028a4e3726b4b9c76ab1fea4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga258a0de028a4e3726b4b9c76ab1fea4a">&#9670;&nbsp;</a></span>pi_fs_file_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct pi_fs_file_s <a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This structure is used by the runtime to store information about a file. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaadac8e4c8d946cf268f3fc32aae7113d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadac8e4c8d946cf268f3fc32aae7113d">&#9670;&nbsp;</a></span>pi_fs_flags_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__FS.html#gaadac8e4c8d946cf268f3fc32aae7113d">pi_fs_flags_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This can be used to select the type of file-system to mount. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaadac8e4c8d946cf268f3fc32aae7113da8211c1c5f10eaf328755215557561eb5"></a>PI_FS_FLAGS_READ&#160;</td><td class="fielddoc"><p>File is opened for reading. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaadac8e4c8d946cf268f3fc32aae7113da4db4c71ab5f46b26e3a702a260f2488b"></a>PI_FS_FLAGS_WRITE&#160;</td><td class="fielddoc"><p>File is opened for writing. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga57993aa582df128923ee14a8ecc02a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57993aa582df128923ee14a8ecc02a1f">&#9670;&nbsp;</a></span>pi_fs_type_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__FS.html#ga57993aa582df128923ee14a8ecc02a1f">pi_fs_type_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This can be used to select the type of file-system to mount. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga57993aa582df128923ee14a8ecc02a1fa673abb1cab5bd79c892c0f84c7eb36fb"></a>PI_FS_READ_ONLY&#160;</td><td class="fielddoc"><p>Read-only file system. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga57993aa582df128923ee14a8ecc02a1faed482f560e0587e2bbe315b74fc534ce"></a>PI_FS_HOST&#160;</td><td class="fielddoc"><p>Host file system. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga75e2257b3526a0a50943e990559cc36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75e2257b3526a0a50943e990559cc36d">&#9670;&nbsp;</a></span>pi_cl_fs_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_cl_fs_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>ext2loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__FS.html#ga95630b5a598d64884dbd2a698e1a0160">pi_cl_fs_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is a remote call that the cluster can do to transfer data between an opened file and a chip memory using a specified offset instead of a current position. This operation is asynchronous and its termination is managed through the request structure. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The handle of the file where to read data. </td></tr>
    <tr><td class="paramname">index</td><td>The offset in the file where to start accessing data. </td></tr>
    <tr><td class="paramname">buffer</td><td>The memory location in the chip memory where the data is accessed. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes to transfer. </td></tr>
    <tr><td class="paramname">ext2loc</td><td>1 if the copy is from file to the chip or 0 for the contrary. </td></tr>
    <tr><td class="paramname">req</td><td>The request structure used for termination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab918d61793528c751f8e25592467b7de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab918d61793528c751f8e25592467b7de">&#9670;&nbsp;</a></span>pi_cl_fs_copy_2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_cl_fs_copy_2d </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>ext2loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__FS.html#ga95630b5a598d64884dbd2a698e1a0160">pi_cl_fs_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is a remote call that the cluster can do to transfer data between an opened file and a chip memory using a specified offset instead of a current position. This operation is asynchronous and its termination is managed through the request structure. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The handle of the file where to read data. </td></tr>
    <tr><td class="paramname">index</td><td>The offset in the file where to start accessing data. </td></tr>
    <tr><td class="paramname">buffer</td><td>The memory location in the chip memory where the data is accessed. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes to transfer. </td></tr>
    <tr><td class="paramname">stride</td><td>2D stride, which is the number of bytes which are added to the beginning of the current line to switch to the next one. </td></tr>
    <tr><td class="paramname">length</td><td>2D length, which is the number of transferred bytes after which the driver will switch to the next line. </td></tr>
    <tr><td class="paramname">ext2loc</td><td>1 if the copy is from file to the chip or 0 for the contrary. </td></tr>
    <tr><td class="paramname">req</td><td>The request structure used for termination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5ddf308472c376b1a299562286690af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ddf308472c376b1a299562286690af8">&#9670;&nbsp;</a></span>pi_cl_fs_direct_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_cl_fs_direct_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__FS.html#ga95630b5a598d64884dbd2a698e1a0160">pi_cl_fs_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function implements the same feature as pi_fs_direct_read but can be called from cluster side in order to expose the feature on the cluster. This function can be called to read data from an opened file. The data is read from the current position which is the beginning of the file when the file is opened. The current position is incremented by the number of bytes read by the call to this function. This operation is asynchronous and its termination is managed through the request structure. Compared to pi_cl_fs_read, this function does direct read transfers from the flash without any cache. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The handle of the file where to read data. </td></tr>
    <tr><td class="paramname">buffer</td><td>The memory location where the read data must be copied. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes to read from the file. </td></tr>
    <tr><td class="paramname">req</td><td>The request structure used for termination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab18e44b0b3af4444faf016c74212d9b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab18e44b0b3af4444faf016c74212d9b3">&#9670;&nbsp;</a></span>pi_cl_fs_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_cl_fs_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__FS.html#ga95630b5a598d64884dbd2a698e1a0160">pi_cl_fs_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function implements the same feature as pi_fs_read but can be called from cluster side in order to expose the feature on the cluster. This function can be called to read data from an opened file. The data is read from the current position which is the beginning of the file when the file is opened. The current position is incremented by the number of bytes read by the call to this function. This operation is asynchronous and its termination is managed through the request structure. Compared to pi_fs_direct_read, this function can use a cache to optimize small transfers. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details. The only difference compared to pi_cl_fs_read is that the file position is automatically set to 0 for the next transfer if the current transfer reaches the end of the file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The handle of the file where to read data. </td></tr>
    <tr><td class="paramname">buffer</td><td>The memory location where the read data must be copied. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes to read from the file. </td></tr>
    <tr><td class="paramname">req</td><td>The request structure used for termination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad5f42b632c501e33cfb85aa00e986fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5f42b632c501e33cfb85aa00e986fd1">&#9670;&nbsp;</a></span>pi_cl_fs_seek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_cl_fs_seek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__FS.html#ga95630b5a598d64884dbd2a698e1a0160">pi_cl_fs_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called from cluster side to change the current position of a file. Note that this does not affect pending copies, but only the ones which will be enqueued after this call. This operation is asynchronous and its termination is managed through the request structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The handle of the file for which the current position is changed. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset where to set the current position. The offset can be between 0 for the beginning of the file and the file size. </td></tr>
    <tr><td class="paramname">req</td><td>The request structure used for termination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga00b71b4c53955965b041992deaaddc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00b71b4c53955965b041992deaaddc79">&#9670;&nbsp;</a></span>pi_cl_fs_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t pi_cl_fs_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__FS.html#ga95630b5a598d64884dbd2a698e1a0160">pi_cl_fs_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This blocks the calling core until the specified cluster remote copy is finished. As the remote copy is asynchronous, this also gives the number of bytes which was read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>The request structure used for termination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually read from the file. This can be smaller than the requested size if the end of file is reached. </dd></dl>

</div>
</div>
<a id="ga780d8b94b737692304217568cc942689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga780d8b94b737692304217568cc942689">&#9670;&nbsp;</a></span>pi_fs_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_fs_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to close an opened file once it is not needed anymore in order to free the allocated resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The handle of the file to be closed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga39725b3b0a6c44d8b9e0ba649b2f5a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39725b3b0a6c44d8b9e0ba649b2f5a14">&#9670;&nbsp;</a></span>pi_fs_conf_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_fs_conf_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpi__fs__conf.html">pi_fs_conf</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The structure containing the configuration must be kept allocated until the file-system is mounted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>A pointer to the file-system configuration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8733e6ad5355f3c82de8879222d402c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8733e6ad5355f3c82de8879222d402c2">&#9670;&nbsp;</a></span>pi_fs_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pi_fs_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>ext2loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to transfer data between an opened file and a chip memory using a specified offset instead of a current position. The caller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The handle of the file where to read data. </td></tr>
    <tr><td class="paramname">index</td><td>The offset in the file where to start accessing data. </td></tr>
    <tr><td class="paramname">buffer</td><td>The memory location in the chip memory where the data is accessed. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes to transfer. </td></tr>
    <tr><td class="paramname">ext2loc</td><td>1 if the copy is from file to the chip or 0 for the contrary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation was successful, -1 otherwise. </dd></dl>

</div>
</div>
<a id="gafd0388d9b55d4b8d74e4aadcf981c89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd0388d9b55d4b8d74e4aadcf981c89f">&#9670;&nbsp;</a></span>pi_fs_copy_2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pi_fs_copy_2d </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>ext2loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to transfer data between an opened file and a chip memory using a specified offset instead of a current position. The caller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The handle of the file where to read data. </td></tr>
    <tr><td class="paramname">index</td><td>The offset in the file where to start accessing data. </td></tr>
    <tr><td class="paramname">buffer</td><td>The memory location in the chip memory where the data is accessed. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes to transfer. </td></tr>
    <tr><td class="paramname">stride</td><td>2D stride, which is the number of bytes which are added to the beginning of the current line to switch to the next one. </td></tr>
    <tr><td class="paramname">length</td><td>2D length, which is the number of transferred bytes after which the driver will switch to the next line. </td></tr>
    <tr><td class="paramname">ext2loc</td><td>1 if the copy is from file to the chip or 0 for the contrary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation was successful, -1 otherwise. </dd></dl>

</div>
</div>
<a id="gaaac45b7202d0386599e66a1326524b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaac45b7202d0386599e66a1326524b46">&#9670;&nbsp;</a></span>pi_fs_copy_2d_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pi_fs_copy_2d_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>ext2loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to transfer data between an opened file and a chip memory using a specified offset instead of a current position. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The handle of the file where to read data. </td></tr>
    <tr><td class="paramname">index</td><td>The offset in the file where to start accessing data. </td></tr>
    <tr><td class="paramname">buffer</td><td>The memory location in the chip memory where the data is accessed. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes to transfer. </td></tr>
    <tr><td class="paramname">stride</td><td>2D stride, which is the number of bytes which are added to the beginning of the current line to switch to the next one. </td></tr>
    <tr><td class="paramname">length</td><td>2D length, which is the number of transferred bytes after which the driver will switch to the next line. </td></tr>
    <tr><td class="paramname">ext2loc</td><td>1 if the copy is from file to the chip or 0 for the contrary. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation was successful, -1 otherwise. </dd></dl>

</div>
</div>
<a id="gaa5d524741ca6648d74324c95c579bfee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5d524741ca6648d74324c95c579bfee">&#9670;&nbsp;</a></span>pi_fs_copy_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pi_fs_copy_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>ext2loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to transfer data between an opened file and a chip memory using a specified offset instead of a current position. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The handle of the file where to read data. </td></tr>
    <tr><td class="paramname">index</td><td>The offset in the file where to start accessing data. </td></tr>
    <tr><td class="paramname">buffer</td><td>The memory location in the chip memory where the data is accessed. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes to transfer. </td></tr>
    <tr><td class="paramname">ext2loc</td><td>1 if the copy is from file to the chip or 0 for the contrary. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation was successful, -1 otherwise. </dd></dl>

</div>
</div>
<a id="ga9a8e419b1482dc113e7fd2b29ab72601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a8e419b1482dc113e7fd2b29ab72601">&#9670;&nbsp;</a></span>pi_fs_direct_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pi_fs_direct_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to read data from an opened file. The data is read from the current position which is the beginning of the file when the file is opened. The current position is incremented by the number of bytes read by the call to this function. The caller is blocked until the transfer is finished. Compared to pi_fs_read, this function does direct read transfers from the flash without any cache. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The handle of the file where to read data. </td></tr>
    <tr><td class="paramname">buffer</td><td>The memory location where the read data must be copied. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes to read from the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually read from the file. This can be smaller than the requested size if the end of file is reached. </dd></dl>

</div>
</div>
<a id="gada9822cb08cab3392cc362d86f81866f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada9822cb08cab3392cc362d86f81866f">&#9670;&nbsp;</a></span>pi_fs_direct_read_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pi_fs_direct_read_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to read data from an opened file. The data is read from the current position which is the beginning of the file when the file is opened. The current position is incremented by the number of bytes read by the call to this function. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Compared to pi_fs_read, this function does direct read transfers from the flash without any cache. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The handle of the file where to read data. </td></tr>
    <tr><td class="paramname">buffer</td><td>The memory location where the read data must be copied. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes to read from the file. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually read from the file. This can be smaller than the requested size if the end of file is reached. </dd></dl>

</div>
</div>
<a id="gae56a4f54bc2107d0f8d13fb5e5135056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae56a4f54bc2107d0f8d13fb5e5135056">&#9670;&nbsp;</a></span>pi_fs_mount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pi_fs_mount </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function must be called before the file-system device can be used. It will do all the needed configuration to make it usable and initialize the handle used to refer to this opened device when calling other functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the device structure of the device to open. This structure is allocated by the called and must be kept alive until the device is closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

</div>
</div>
<a id="gaf85d7e62086ed06598077a461dc8cc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf85d7e62086ed06598077a461dc8cc4c">&#9670;&nbsp;</a></span>pi_fs_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a>* pi_fs_open </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to open a file on a file-system in order to read or write data to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device structure of the FS where to open the file. </td></tr>
    <tr><td class="paramname">file</td><td>The path to the file to be opened. </td></tr>
    <tr><td class="paramname">flags</td><td>Optional flags to configure how the file is opened. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if the file is not found, or a handle identifying the file which can be used with other functions. </dd></dl>

</div>
</div>
<a id="ga9653e745f459274649e1d82d3d427c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9653e745f459274649e1d82d3d427c13">&#9670;&nbsp;</a></span>pi_fs_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pi_fs_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to read data from an opened file. The data is read from the current position which is the beginning of the file when the file is opened. The current position is incremented by the number of bytes read by the call to this function. The caller is blocked until the transfer is finished. Compared to pi_fs_direct_read, this functions can use a cache to optimize small transfers. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The handle of the file where to read data. </td></tr>
    <tr><td class="paramname">buffer</td><td>The memory location where the read data must be copied. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes to read from the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually read from the file. This can be smaller than the requested size if the end of file is reached. </dd></dl>

</div>
</div>
<a id="ga3cd6d6e1058861de648f4c5d7a508fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cd6d6e1058861de648f4c5d7a508fd2">&#9670;&nbsp;</a></span>pi_fs_read_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pi_fs_read_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to read data from an opened file. The data is read from the current position which is the beginning of the file when the file is opened. The current position is incremented by the number of bytes read by the call to this function. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Compared to pi_fs_direct_read, this function can use a cache to optimize small transfers. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The handle of the file where to read data. </td></tr>
    <tr><td class="paramname">buffer</td><td>The memory location where the read data must be copied. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes to read from the file. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually read from the file. This can be smaller than the requested size if the end of file is reached. </dd></dl>

</div>
</div>
<a id="ga849a3c466a0ea22e69008ff0c2947e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga849a3c466a0ea22e69008ff0c2947e36">&#9670;&nbsp;</a></span>pi_fs_seek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pi_fs_seek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to change the current position of a file. Note that this does not affect pending copies, but only the ones which will be enqueued after this call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The handle of the file for which the current position is changed. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset where to set the current position. The offset can be between 0 for the beginning of the file and the file size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation was successful, -1 otherwise. </dd></dl>

</div>
</div>
<a id="ga8d9c1b12955e5dad34da56d5a65b1fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d9c1b12955e5dad34da56d5a65b1fd3">&#9670;&nbsp;</a></span>pi_fs_unmount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_fs_unmount </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to close a mounted file-system once it is not needed anymore, in order to free all allocated resources. Once this function is called, the file-system is not accessible anymore and must be mounted again before being used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device structure of the FS to unmount. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga49964aff3141c8d9d740a159d806eb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49964aff3141c8d9d740a159d806eb76">&#9670;&nbsp;</a></span>pi_fs_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pi_fs_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to write data to an opened file. The data is written to the current position which is the beginning of the file when the file is opened. The current position is incremented by the number of bytes written by the call to this function. This functionmay not be supported by each file-system. The caller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The handle of the file where to write data. </td></tr>
    <tr><td class="paramname">buffer</td><td>The memory location where the data to be written must be read. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes to write to the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually written to the file. This can be smaller than the requested size if the end of file is reached. </dd></dl>

</div>
</div>
<a id="ga93352bab7a27cc99f066298262d0a4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93352bab7a27cc99f066298262d0a4ae">&#9670;&nbsp;</a></span>pi_fs_write_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pi_fs_write_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__FS.html#ga258a0de028a4e3726b4b9c76ab1fea4a">pi_fs_file_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to write data to an opened file. The data is written to the current position which is the beginning of the file when the file is opened. The current position is incremented by the number of bytes written by the call to this function. This functionmay not be supported by each file-system. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The handle of the file where to write data. </td></tr>
    <tr><td class="paramname">buffer</td><td>The memory location where the data to be written must be written. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes to write to the file. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually written to the file. This can be smaller than the requested size if the end of file is reached. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jan 24 2020 12:47:55 for  by GreenWaves Technologies
	<!--
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 
	-->
	</li>
  </ul>
</div>
</body>
</html>
