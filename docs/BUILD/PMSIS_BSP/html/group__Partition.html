<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Partition</title>
<title>Partition</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="pulp.css" rel="stylesheet" type="text/css" />
<link href="gap.css" rel="stylesheet" type="text/css" />
<link href="images.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="printComponentTabs.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="titlerow">
  <td id="projectlogo"><img alt="Logo" src="gap-logo-55.png" /></td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">PMSIS BSP</div>
    </td>
  <td id="extralogo"><img alt="GreenWaves" src="greenwaves-logo-55.png" /></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="CMSISnav" class="tabs1">
    <ul class="tablist">
      <script type="text/javascript">
		<!--
		writeComponentTabs.call(this);
		//-->
      </script>
	  </ul>
</div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__Partition.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Partition</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpi__partition__t.html">pi_partition_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partition information structure  <a href="structpi__partition__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaaf6606e382925f1531f3327319b986fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#gaaf6606e382925f1531f3327319b986fd">PI_PARTITION_MAX_OTA_SLOTS</a></td></tr>
<tr class="separator:gaaf6606e382925f1531f3327319b986fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gace45669be5a15c9d93be451f071f0b41"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#gace45669be5a15c9d93be451f071f0b41">pi_partition_table_t</a></td></tr>
<tr class="memdesc:gace45669be5a15c9d93be451f071f0b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">partition table object  <a href="#gace45669be5a15c9d93be451f071f0b41">More...</a><br /></td></tr>
<tr class="separator:gace45669be5a15c9d93be451f071f0b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga0f3b9ec315325b6b9de6848a8f80582a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#ga0f3b9ec315325b6b9de6848a8f80582a">pi_partition_type_t</a> <tr class="memdesc:ga0f3b9ec315325b6b9de6848a8f80582a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition type.  <a href="group__Partition.html#ga0f3b9ec315325b6b9de6848a8f80582a">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga0f3b9ec315325b6b9de6848a8f80582a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga177446b0f31c934e6917c60ca49176b6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#ga177446b0f31c934e6917c60ca49176b6">pi_partition_subtype_t</a> <tr class="memdesc:ga177446b0f31c934e6917c60ca49176b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition subtype.  <a href="group__Partition.html#ga177446b0f31c934e6917c60ca49176b6">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga177446b0f31c934e6917c60ca49176b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaadd4a636470dd1f0a1f7649a52330135"><td class="memItemLeft" align="right" valign="top">pi_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#gaadd4a636470dd1f0a1f7649a52330135">pi_partition_table_load</a> (pi_device_t *flash, const <a class="el" href="group__Partition.html#gace45669be5a15c9d93be451f071f0b41">pi_partition_table_t</a> *table)</td></tr>
<tr class="memdesc:gaadd4a636470dd1f0a1f7649a52330135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a partition table from a flash device.  <a href="#gaadd4a636470dd1f0a1f7649a52330135">More...</a><br /></td></tr>
<tr class="separator:gaadd4a636470dd1f0a1f7649a52330135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeee252a486f6477dec406d75539c12d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#gaeee252a486f6477dec406d75539c12d9">pi_partition_table_free</a> (<a class="el" href="group__Partition.html#gace45669be5a15c9d93be451f071f0b41">pi_partition_table_t</a> table)</td></tr>
<tr class="memdesc:gaeee252a486f6477dec406d75539c12d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an opened partition table from pi_partition_table_load.  <a href="#gaeee252a486f6477dec406d75539c12d9">More...</a><br /></td></tr>
<tr class="separator:gaeee252a486f6477dec406d75539c12d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb93b104d8995036f87089694088c44b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpi__partition__t.html">pi_partition_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#gacb93b104d8995036f87089694088c44b">pi_partition_find_first</a> (const <a class="el" href="group__Partition.html#gace45669be5a15c9d93be451f071f0b41">pi_partition_table_t</a> table, const <a class="el" href="group__Partition.html#ga0f3b9ec315325b6b9de6848a8f80582a">pi_partition_type_t</a> type, const <a class="el" href="group__Partition.html#ga177446b0f31c934e6917c60ca49176b6">pi_partition_subtype_t</a> subtype, const char *label)</td></tr>
<tr class="memdesc:gacb93b104d8995036f87089694088c44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first partition based on one or more parameters.  <a href="#gacb93b104d8995036f87089694088c44b">More...</a><br /></td></tr>
<tr class="separator:gacb93b104d8995036f87089694088c44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga907e3539702f1a344550df2d7c53ebda"><td class="memItemLeft" align="right" valign="top">static pi_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#ga907e3539702f1a344550df2d7c53ebda">pi_partition_close</a> (const <a class="el" href="structpi__partition__t.html">pi_partition_t</a> *partition)</td></tr>
<tr class="memdesc:ga907e3539702f1a344550df2d7c53ebda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an opened partition device.  <a href="#ga907e3539702f1a344550df2d7c53ebda">More...</a><br /></td></tr>
<tr class="separator:ga907e3539702f1a344550df2d7c53ebda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a68354a0b59f4e454132bc1998b0860"><td class="memItemLeft" align="right" valign="top">static pi_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#ga1a68354a0b59f4e454132bc1998b0860">pi_partition_read_async</a> (const <a class="el" href="structpi__partition__t.html">pi_partition_t</a> *partition, const uint32_t partition_addr, void *data, const size_t size, pi_task_t *task)</td></tr>
<tr class="memdesc:ga1a68354a0b59f4e454132bc1998b0860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue an asynchronous read copy to the flash partition (from flash partition to processor).  <a href="#ga1a68354a0b59f4e454132bc1998b0860">More...</a><br /></td></tr>
<tr class="separator:ga1a68354a0b59f4e454132bc1998b0860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7e27c6d7c898e5a7143d46aa2e5fa4b"><td class="memItemLeft" align="right" valign="top">static pi_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#gab7e27c6d7c898e5a7143d46aa2e5fa4b">pi_partition_read</a> (const <a class="el" href="structpi__partition__t.html">pi_partition_t</a> *partition, const uint32_t partition_addr, void *data, const size_t size)</td></tr>
<tr class="memdesc:gab7e27c6d7c898e5a7143d46aa2e5fa4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a read copy to the flash partition (from flash to processor).  <a href="#gab7e27c6d7c898e5a7143d46aa2e5fa4b">More...</a><br /></td></tr>
<tr class="separator:gab7e27c6d7c898e5a7143d46aa2e5fa4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7f17e20504898ac330d3b51ca35faf9"><td class="memItemLeft" align="right" valign="top">static pi_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#gae7f17e20504898ac330d3b51ca35faf9">pi_partition_write_async</a> (const <a class="el" href="structpi__partition__t.html">pi_partition_t</a> *partition, const uint32_t partition_addr, const void *data, const size_t size, pi_task_t *task)</td></tr>
<tr class="memdesc:gae7f17e20504898ac330d3b51ca35faf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue an asynchronous read copy to the flash partition (from processor to flash partition).  <a href="#gae7f17e20504898ac330d3b51ca35faf9">More...</a><br /></td></tr>
<tr class="separator:gae7f17e20504898ac330d3b51ca35faf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9d924e779c4d0ccd3890fa3fe15a728"><td class="memItemLeft" align="right" valign="top">static pi_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#gaa9d924e779c4d0ccd3890fa3fe15a728">pi_partition_write</a> (const <a class="el" href="structpi__partition__t.html">pi_partition_t</a> *partition, const uint32_t partition_addr, const void *data, const size_t size)</td></tr>
<tr class="memdesc:gaa9d924e779c4d0ccd3890fa3fe15a728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a write copy to the flash partition (from processor to flash).  <a href="#gaa9d924e779c4d0ccd3890fa3fe15a728">More...</a><br /></td></tr>
<tr class="separator:gaa9d924e779c4d0ccd3890fa3fe15a728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf4cb131645eae77ac4259ac3c303b91"><td class="memItemLeft" align="right" valign="top">static pi_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#gadf4cb131645eae77ac4259ac3c303b91">pi_partition_erase_async</a> (const <a class="el" href="structpi__partition__t.html">pi_partition_t</a> *partition, uint32_t partition_addr, int size, pi_task_t *task)</td></tr>
<tr class="memdesc:gadf4cb131645eae77ac4259ac3c303b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an area in the flash partition asynchronously.  <a href="#gadf4cb131645eae77ac4259ac3c303b91">More...</a><br /></td></tr>
<tr class="separator:gadf4cb131645eae77ac4259ac3c303b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf46fc0d54865b910c96d6374a5c56f5"><td class="memItemLeft" align="right" valign="top">static pi_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#gadf46fc0d54865b910c96d6374a5c56f5">pi_partition_erase</a> (const <a class="el" href="structpi__partition__t.html">pi_partition_t</a> *partition, uint32_t partition_addr, int size)</td></tr>
<tr class="memdesc:gadf46fc0d54865b910c96d6374a5c56f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an area in the flash partition.  <a href="#gadf46fc0d54865b910c96d6374a5c56f5">More...</a><br /></td></tr>
<tr class="separator:gadf46fc0d54865b910c96d6374a5c56f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa886bbf9c7a9c778b45a89f492c4cbaa"><td class="memItemLeft" align="right" valign="top">static pi_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#gaa886bbf9c7a9c778b45a89f492c4cbaa">pi_partition_format_async</a> (const <a class="el" href="structpi__partition__t.html">pi_partition_t</a> *partition, pi_task_t *task)</td></tr>
<tr class="memdesc:gaa886bbf9c7a9c778b45a89f492c4cbaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the whole flash partition asynchronously.  <a href="#gaa886bbf9c7a9c778b45a89f492c4cbaa">More...</a><br /></td></tr>
<tr class="separator:gaa886bbf9c7a9c778b45a89f492c4cbaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae44fab3b197b65f85c3ca846016dfe84"><td class="memItemLeft" align="right" valign="top">static pi_err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#gae44fab3b197b65f85c3ca846016dfe84">pi_partition_format</a> (const <a class="el" href="structpi__partition__t.html">pi_partition_t</a> *partition)</td></tr>
<tr class="memdesc:gae44fab3b197b65f85c3ca846016dfe84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the whole flash partition.  <a href="#gae44fab3b197b65f85c3ca846016dfe84">More...</a><br /></td></tr>
<tr class="separator:gae44fab3b197b65f85c3ca846016dfe84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23052a9fb817276c897ed7c7b69d0b34"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#ga23052a9fb817276c897ed7c7b69d0b34">pi_partition_get_size</a> (const <a class="el" href="structpi__partition__t.html">pi_partition_t</a> *partition)</td></tr>
<tr class="memdesc:ga23052a9fb817276c897ed7c7b69d0b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size in byte of the partition.  <a href="#ga23052a9fb817276c897ed7c7b69d0b34">More...</a><br /></td></tr>
<tr class="separator:ga23052a9fb817276c897ed7c7b69d0b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7b3875a697ae43ee8d8adcf1e65c300"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Partition.html#gac7b3875a697ae43ee8d8adcf1e65c300">pi_partition_get_flash_offset</a> (const <a class="el" href="structpi__partition__t.html">pi_partition_t</a> *partition)</td></tr>
<tr class="memdesc:gac7b3875a697ae43ee8d8adcf1e65c300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get flash partition start offset.  <a href="#gac7b3875a697ae43ee8d8adcf1e65c300">More...</a><br /></td></tr>
<tr class="separator:gac7b3875a697ae43ee8d8adcf1e65c300"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>The partition driver provides support for handling partition contained into a device storage. Currently, PMSIS and GAP SDK provide both partitions, binary firmware and filesystem.</p>
<ul>
<li>0 -&gt; Binary firmware;</li>
<li>1 -&gt; Filesystem or Free space.</li>
</ul>
<p>The beginning of the filesystem partition is aligned on a flash sector. Thus, an erase partition operation at address zero does not affect the data of the previous partition. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaaf6606e382925f1531f3327319b986fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf6606e382925f1531f3327319b986fd">&#9670;&nbsp;</a></span>PI_PARTITION_MAX_OTA_SLOTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PI_PARTITION_MAX_OTA_SLOTS</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gace45669be5a15c9d93be451f071f0b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace45669be5a15c9d93be451f071f0b41">&#9670;&nbsp;</a></span>pi_partition_table_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="group__Partition.html#gace45669be5a15c9d93be451f071f0b41">pi_partition_table_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga177446b0f31c934e6917c60ca49176b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga177446b0f31c934e6917c60ca49176b6">&#9670;&nbsp;</a></span>pi_partition_subtype_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Partition.html#ga177446b0f31c934e6917c60ca49176b6">pi_partition_subtype_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Keep this enum in sync with PartitionDefinition class in gapy tool. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga177446b0f31c934e6917c60ca49176b6af4a2c50544a5ea072bea6bd549c18a62"></a>PI_PARTITION_SUBTYPE_APP_FACTORY&#160;</td><td class="fielddoc"><p>Factory application partition. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga177446b0f31c934e6917c60ca49176b6a7028891e3a2c3200d9bed25ccb4e61e1"></a>PI_PARTITION_SUBTYPE_APP_OTA_MIN&#160;</td><td class="fielddoc"><p>Base for OTA partition subtypes. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga177446b0f31c934e6917c60ca49176b6a7e0f501f1956af39fbe8883a8b050631"></a>PI_PARTITION_SUBTYPE_APP_OTA_0&#160;</td><td class="fielddoc"><p>OTA partition 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga177446b0f31c934e6917c60ca49176b6ab584a3613512b76f819583364895692d"></a>PI_PARTITION_SUBTYPE_APP_OTA_1&#160;</td><td class="fielddoc"><p>OTA partition 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga177446b0f31c934e6917c60ca49176b6a1de017e73fd30e1ed86e113f18c72a45"></a>PI_PARTITION_SUBTYPE_APP_OTA_2&#160;</td><td class="fielddoc"><p>OTA partition 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga177446b0f31c934e6917c60ca49176b6a20bc634c8cd5847d35b0c811eaba017b"></a>PI_PARTITION_SUBTYPE_APP_OTA_3&#160;</td><td class="fielddoc"><p>OTA partition 3. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga177446b0f31c934e6917c60ca49176b6a974f6a15d852eab97d7324f1e354fccf"></a>PI_PARTITION_SUBTYPE_APP_OTA_4&#160;</td><td class="fielddoc"><p>OTA partition 4. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga177446b0f31c934e6917c60ca49176b6af5404d58d4c61948ef3a55a1c5be8ca7"></a>PI_PARTITION_SUBTYPE_APP_OTA_5&#160;</td><td class="fielddoc"><p>OTA partition 5. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga177446b0f31c934e6917c60ca49176b6a5fddc2a399ab372a78f0c260d6b090b1"></a>PI_PARTITION_SUBTYPE_APP_OTA_6&#160;</td><td class="fielddoc"><p>OTA partition 6. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga177446b0f31c934e6917c60ca49176b6aa8c0da02310fc813b23daaec7185bdd2"></a>PI_PARTITION_SUBTYPE_APP_OTA_7&#160;</td><td class="fielddoc"><p>OTA partition 7. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga177446b0f31c934e6917c60ca49176b6a8b9daca3e6d9b5c27f691f01fb12b03a"></a>PI_PARTITION_SUBTYPE_APP_OTA_8&#160;</td><td class="fielddoc"><p>OTA partition 8. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga177446b0f31c934e6917c60ca49176b6a5caf82add9506dc5e8c4ef87aed28e46"></a>PI_PARTITION_SUBTYPE_APP_OTA_9&#160;</td><td class="fielddoc"><p>OTA partition 9. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga177446b0f31c934e6917c60ca49176b6a8bc125456415ad12229bca3739ea3f81"></a>PI_PARTITION_SUBTYPE_APP_OTA_10&#160;</td><td class="fielddoc"><p>OTA partition 10. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga177446b0f31c934e6917c60ca49176b6ae88cf703f5bafc440f84a012cc9eacb2"></a>PI_PARTITION_SUBTYPE_APP_OTA_11&#160;</td><td class="fielddoc"><p>OTA partition 11. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga177446b0f31c934e6917c60ca49176b6aeb69e5dcdb56b62d153313eb4974deaf"></a>PI_PARTITION_SUBTYPE_APP_OTA_12&#160;</td><td class="fielddoc"><p>OTA partition 12. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga177446b0f31c934e6917c60ca49176b6a8e85d6991b86c01358738837bb2fee19"></a>PI_PARTITION_SUBTYPE_APP_OTA_13&#160;</td><td class="fielddoc"><p>OTA partition 13. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga177446b0f31c934e6917c60ca49176b6a73fb855bf0fdc8e2661170f048028799"></a>PI_PARTITION_SUBTYPE_APP_OTA_14&#160;</td><td class="fielddoc"><p>OTA partition 14. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga177446b0f31c934e6917c60ca49176b6a7361a96e68bc154762756059cea4a0e0"></a>PI_PARTITION_SUBTYPE_APP_OTA_15&#160;</td><td class="fielddoc"><p>OTA partition 15. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga177446b0f31c934e6917c60ca49176b6aac3068be55dd8d1674bde8a4ef92a611"></a>PI_PARTITION_SUBTYPE_APP_OTA_MAX&#160;</td><td class="fielddoc"><p>Max subtype of OTA partition. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga177446b0f31c934e6917c60ca49176b6a45e69df1b09d6673f5fd28aed2556f13"></a>PI_PARTITION_SUBTYPE_APP_TEST&#160;</td><td class="fielddoc"><p>Test application partition. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga177446b0f31c934e6917c60ca49176b6aa9f3933e6ba2db5f40dff7c94dc51c3b"></a>PI_PARTITION_SUBTYPE_DATA_OTA&#160;</td><td class="fielddoc"><p>OTA selection partition. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga177446b0f31c934e6917c60ca49176b6aa1f20e9d2e9209009d8dfb99f5f68e23"></a>PI_PARTITION_SUBTYPE_DATA_PHY&#160;</td><td class="fielddoc"><p>PHY init data partition. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga177446b0f31c934e6917c60ca49176b6ab4c7d7cc4fdf33eb493eac431f0ebbfb"></a>PI_PARTITION_SUBTYPE_DATA_RAW&#160;</td><td class="fielddoc"><p>RAW space partition. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga177446b0f31c934e6917c60ca49176b6a7291c0853c6d329ab043c1a49b97f3b6"></a>PI_PARTITION_SUBTYPE_DATA_READFS&#160;</td><td class="fielddoc"><p>Readonly filesystem partition. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga177446b0f31c934e6917c60ca49176b6aaaeb76d0a4a1880af17d7897b1e59959"></a>PI_PARTITION_SUBTYPE_DATA_LFS&#160;</td><td class="fielddoc"><p>LittleFS filesystem partition. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga177446b0f31c934e6917c60ca49176b6a378af8f45b65ecd07d38b3642f7661d3"></a>pi_PARTITION_SUBTYPE_ANY&#160;</td><td class="fielddoc"><p>Used to search for partitions with any subtype. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga0f3b9ec315325b6b9de6848a8f80582a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f3b9ec315325b6b9de6848a8f80582a">&#9670;&nbsp;</a></span>pi_partition_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Partition.html#ga0f3b9ec315325b6b9de6848a8f80582a">pi_partition_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Keep this enum in sync with PartitionDefinition class in gapy tool </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga0f3b9ec315325b6b9de6848a8f80582aa7c66659f6ad836cf1c89f86d4ffc53ca"></a>PI_PARTITION_TYPE_APP&#160;</td><td class="fielddoc"><p>Application partition type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0f3b9ec315325b6b9de6848a8f80582aac7c9d1dec8a06e628de03b6de5f9d4e4"></a>PI_PARTITION_TYPE_DATA&#160;</td><td class="fielddoc"><p>Data partition type. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga907e3539702f1a344550df2d7c53ebda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga907e3539702f1a344550df2d7c53ebda">&#9670;&nbsp;</a></span>pi_partition_close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static pi_err_t pi_partition_close </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpi__partition__t.html">pi_partition_t</a> *&#160;</td>
          <td class="paramname"><em>partition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function can be called to close an opened partition device once it is not needed anymore, in order to free all allocated resources. Once this function is called, the device is not accessible anymore and must be opened again before being used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partition</td><td>The partition structure of the device to close. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PI_OK if the operation is successfull, PI_FAIL if there was an error. </dd></dl>

</div>
</div>
<a id="gadf46fc0d54865b910c96d6374a5c56f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf46fc0d54865b910c96d6374a5c56f5">&#9670;&nbsp;</a></span>pi_partition_erase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static pi_err_t pi_partition_erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpi__partition__t.html">pi_partition_t</a> *&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>partition_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will erase the specified area. The duration of this operation may be long and may be retrieved from the datasheet. If the flash only supports sector erasing, all the sectors partially or entirely covered by this aread will be erased. The caller is blocked until the operation is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partition</td><td>The partition descriptor on which to do the operation. </td></tr>
    <tr><td class="paramname">partition_addr</td><td>The address of the partition area to be erased. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the area to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PI_OK if the operation is successfull, PI_ERR_INVALID_ARG if adress is out of range. </dd></dl>

</div>
</div>
<a id="gadf4cb131645eae77ac4259ac3c303b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf4cb131645eae77ac4259ac3c303b91">&#9670;&nbsp;</a></span>pi_partition_erase_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static pi_err_t pi_partition_erase_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpi__partition__t.html">pi_partition_t</a> *&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>partition_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will erase the specified area. The duration of this operation may be long and may be retrieved from the datasheet. If the flash only supports sector erasing, all the sectors partially or entirely covered by this aread will be erased. A task must be specified in order to specify how the caller should be notified when the transfer is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partition</td><td>The partition descriptor on which to do the operation. </td></tr>
    <tr><td class="paramname">partition_addr</td><td>The address of the partition area to be erased. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the area to be erased. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PI_OK if the operation is successfull, PI_ERR_INVALID_ARG if adress is out of range. </dd></dl>

</div>
</div>
<a id="gacb93b104d8995036f87089694088c44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb93b104d8995036f87089694088c44b">&#9670;&nbsp;</a></span>pi_partition_find_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpi__partition__t.html">pi_partition_t</a>* pi_partition_find_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Partition.html#gace45669be5a15c9d93be451f071f0b41">pi_partition_table_t</a>&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Partition.html#ga0f3b9ec315325b6b9de6848a8f80582a">pi_partition_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Partition.html#ga177446b0f31c934e6917c60ca49176b6">pi_partition_subtype_t</a>&#160;</td>
          <td class="paramname"><em>subtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>the partition table descriptor on which to do the operation. This table must be loaded before with pi_partition_table_load(...) </td></tr>
    <tr><td class="paramname">type</td><td>Partition type, one of pi_partition_type_t values </td></tr>
    <tr><td class="paramname">subtype</td><td>Partition subtype, one of pi_partition_subtype_t values. To find all partitions of given type, use pi_PARTITION_SUBTYPE_ANY. </td></tr>
    <tr><td class="paramname">label</td><td>(optional) Partition label. Set this value if looking for partition with a specific name. Pass NULL otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to <a class="el" href="structpi__partition__t.html" title="partition information structure ">pi_partition_t</a> structure, or NULL if no partition is found. This pointer is valid for the lifetime of the application. </dd></dl>

</div>
</div>
<a id="gae44fab3b197b65f85c3ca846016dfe84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae44fab3b197b65f85c3ca846016dfe84">&#9670;&nbsp;</a></span>pi_partition_format()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static pi_err_t pi_partition_format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpi__partition__t.html">pi_partition_t</a> *&#160;</td>
          <td class="paramname"><em>partition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will erase the entire partition. The duration of this operation may be long and may be retrieved from the datasheet. The caller is blocked until the operation is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partition</td><td>The partition descriptor on which to do the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PI_OK if the operation is successfull, PI_FAIL if there was an error. </dd></dl>

</div>
</div>
<a id="gaa886bbf9c7a9c778b45a89f492c4cbaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa886bbf9c7a9c778b45a89f492c4cbaa">&#9670;&nbsp;</a></span>pi_partition_format_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static pi_err_t pi_partition_format_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpi__partition__t.html">pi_partition_t</a> *&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will erase the entire partition. The duration of this operation may be long and may be retrieved from the datasheet. A task must be specified in order to specify how the caller should be notified when the transfer is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partition</td><td>The partition descriptor on which to do the operation. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PI_OK if the operation is successfull, PI_FAIL if there was an error. </dd></dl>

</div>
</div>
<a id="gac7b3875a697ae43ee8d8adcf1e65c300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7b3875a697ae43ee8d8adcf1e65c300">&#9670;&nbsp;</a></span>pi_partition_get_flash_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pi_partition_get_flash_offset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpi__partition__t.html">pi_partition_t</a> *&#160;</td>
          <td class="paramname"><em>partition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partition</td><td>The partition where the offset will be fetched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The flash offset in byte where the partition starts. </dd></dl>

</div>
</div>
<a id="ga23052a9fb817276c897ed7c7b69d0b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23052a9fb817276c897ed7c7b69d0b34">&#9670;&nbsp;</a></span>pi_partition_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pi_partition_get_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpi__partition__t.html">pi_partition_t</a> *&#160;</td>
          <td class="paramname"><em>partition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partition</td><td>The partition where the size will be fetched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size in byte of the partition </dd></dl>

</div>
</div>
<a id="gab7e27c6d7c898e5a7143d46aa2e5fa4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7e27c6d7c898e5a7143d46aa2e5fa4b">&#9670;&nbsp;</a></span>pi_partition_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static pi_err_t pi_partition_read </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpi__partition__t.html">pi_partition_t</a> *&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>partition_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy will make a transfer between the flash partition and one of the processor memory areas. The caller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partition</td><td>The partition descriptor on which to do the copy. </td></tr>
    <tr><td class="paramname">partition_addr</td><td>The address of the copy in the partition. </td></tr>
    <tr><td class="paramname">data</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PI_OK if the operation is successfull, PI_ERR_INVALID_ARG if adress is out of range. </dd></dl>

</div>
</div>
<a id="ga1a68354a0b59f4e454132bc1998b0860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a68354a0b59f4e454132bc1998b0860">&#9670;&nbsp;</a></span>pi_partition_read_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static pi_err_t pi_partition_read_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpi__partition__t.html">pi_partition_t</a> *&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>partition_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy will make a transfer between the flash partition and one of the processor memory areas. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partition</td><td>The partition descriptor on which to do the copy. </td></tr>
    <tr><td class="paramname">partition_addr</td><td>The address of the copy in the partition. </td></tr>
    <tr><td class="paramname">data</td><td>The buffer address of the copy. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PI_OK if the operation is successfull, PI_ERR_INVALID_ARG if adress is out of range. </dd></dl>

</div>
</div>
<a id="gaeee252a486f6477dec406d75539c12d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeee252a486f6477dec406d75539c12d9">&#9670;&nbsp;</a></span>pi_partition_table_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_partition_table_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Partition.html#gace45669be5a15c9d93be451f071f0b41">pi_partition_table_t</a>&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>A reference of the partition table to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaadd4a636470dd1f0a1f7649a52330135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadd4a636470dd1f0a1f7649a52330135">&#9670;&nbsp;</a></span>pi_partition_table_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pi_err_t pi_partition_table_load </td>
          <td>(</td>
          <td class="paramtype">pi_device_t *&#160;</td>
          <td class="paramname"><em>flash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Partition.html#gace45669be5a15c9d93be451f071f0b41">pi_partition_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flash</td><td>The flash device in which to fetch the partition table. </td></tr>
    <tr><td class="paramname">table</td><td>A reference to the user table variable. if the return code is PI_OK, this pointer contains a reference to the new partition table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PI_OK on success; PI_ERR_INVALID_ARG if the table pointer is NULL or if the flash device is invalid; PI_ERR_L2_NO_MEM if the allocation of the table in L2 memory fails; PI_ERR_NOT_FOUND if the partition table is not present on the flash device; PI_ERR_INVALID_VERSION if the format version of the partition table missmatch between flash data and BSP program; PI_ERR_INVALID_STATE if partition table MD5 missmatch (Partition table data corrupted). </dd></dl>

</div>
</div>
<a id="gaa9d924e779c4d0ccd3890fa3fe15a728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9d924e779c4d0ccd3890fa3fe15a728">&#9670;&nbsp;</a></span>pi_partition_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static pi_err_t pi_partition_write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpi__partition__t.html">pi_partition_t</a> *&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>partition_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy will make a write transfer from one of the processor memory areas to the partition. The locations in the flash being written should have first been erased. The caller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partition</td><td>The partition descriptor on which to do the copy. </td></tr>
    <tr><td class="paramname">partition_addr</td><td>The address of the copy in the partition. </td></tr>
    <tr><td class="paramname">data</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PI_OK if the operation is successfull, PI_ERR_INVALID_ARG if adress is out of range. </dd></dl>

</div>
</div>
<a id="gae7f17e20504898ac330d3b51ca35faf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7f17e20504898ac330d3b51ca35faf9">&#9670;&nbsp;</a></span>pi_partition_write_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static pi_err_t pi_partition_write_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpi__partition__t.html">pi_partition_t</a> *&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>partition_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy will make a transfer between the flash partition and one of the processor memory areas.</p>
<p>A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partition</td><td>The partition descriptor on which to do the copy. </td></tr>
    <tr><td class="paramname">partition_addr</td><td>The address of the copy in the partition. </td></tr>
    <tr><td class="paramname">data</td><td>The buffer address of the copy. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PI_OK if the operation is successfull, PI_ERR_INVALID_ARG if adress is out of range. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Feb 12 2020 11:11:35 for  by GreenWaves Technologies
	<!--
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 
	-->
	</li>
  </ul>
</div>
</body>
</html>
